#+TITLE: Advent of Code
#+STARTUP: inlineimages
#+LANGUAGE: en
#+EXPORT_FILE_NAME: index.html
#+date: @@html:<!--@@{{{git-rev}}}@@html:-->@@@@latex:\\\Large\bfseries@@ {{{modification-time(%Y-%m-%d, t)}}} @@latex:\\\normalsize\mdseries@@{{{modification-time(%H:%M, t)}}} @@latex:\acr{\lowercase{@@{{{timezone}}}@@latex:}}\iffalse@@, {{{git-rev}}}@@latex:\fi@@
#+macro: timezone (eval (substring (shell-command-to-string "date +%Z") 0 -1))
#+macro: git-rev (eval (format "@@html:<a href=\"https://github.com/Nan0Scho1ar/adventofcode/commit/%1$s\" style=\"text-decoration: none\"><code style=\"padding: 0; color: var(--text-light); font-size: inherit; opacity: 0.7\">%1$s</code></a>@@@@latex:\\href{https://github.com/Nan0Scho1ar/adventofcode/commit/%1$s}{\\normalsize\\texttt{%1$s}}@@" (substring (shell-command-to-string "git rev-parse --short HEAD") 0 -1)))
#+HTML_HEAD:
#+begin_export html
<a href="https://github.com/Nan0Scho1ar/adventofcode"
   style="font-family: 'Open Sans'; background-image: none; color: inherit;
          text-decoration: none; position: relative; top: clamp(-26px, calc(1280px - 100vw), 0px); opacity: 0.7;">
   <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTggMEMzLjU4IDAgMCAzLjU4IDAgOEMwIDExLjU0IDIuMjkgMTQuNTMgNS40NyAxNS41OUM1Ljg3IDE1LjY2IDYuMDIgMTUuNDIgNi4wMiAxNS4yMUM2LjAyIDE1LjAyIDYuMDEgMTQuMzkgNi4wMSAxMy43MkM0IDE0LjA5IDMuNDggMTMuMjMgMy4zMiAxMi43OEMzLjIzIDEyLjU1IDIuODQgMTEuODQgMi41IDExLjY1QzIuMjIgMTEuNSAxLjgyIDExLjEzIDIuNDkgMTEuMTJDMy4xMiAxMS4xMSAzLjU3IDExLjcgMy43MiAxMS45NEM0LjQ0IDEzLjE1IDUuNTkgMTIuODEgNi4wNSAxMi42QzYuMTIgMTIuMDggNi4zMyAxMS43MyA2LjU2IDExLjUzQzQuNzggMTEuMzMgMi45MiAxMC42NCAyLjkyIDcuNThDMi45MiA2LjcxIDMuMjMgNS45OSAzLjc0IDUuNDNDMy42NiA1LjIzIDMuMzggNC40MSAzLjgyIDMuMzFDMy44MiAzLjMxIDQuNDkgMy4xIDYuMDIgNC4xM0M2LjY2IDMuOTUgNy4zNCAzLjg2IDguMDIgMy44NkM4LjcgMy44NiA5LjM4IDMuOTUgMTAuMDIgNC4xM0MxMS41NSAzLjA5IDEyLjIyIDMuMzEgMTIuMjIgMy4zMUMxMi42NiA0LjQxIDEyLjM4IDUuMjMgMTIuMyA1LjQzQzEyLjgxIDUuOTkgMTMuMTIgNi43IDEzLjEyIDcuNThDMTMuMTIgMTAuNjUgMTEuMjUgMTEuMzMgOS40NyAxMS41M0M5Ljc2IDExLjc4IDEwLjAxIDEyLjI2IDEwLjAxIDEzLjAxQzEwLjAxIDE0LjA4IDEwIDE0Ljk0IDEwIDE1LjIxQzEwIDE1LjQyIDEwLjE1IDE1LjY3IDEwLjU1IDE1LjU5QzEzLjcxIDE0LjUzIDE2IDExLjUzIDE2IDhDMTYgMy41OCAxMi40MiAwIDggMFoiIHRyYW5zZm9ybT0ic2NhbGUoNjQpIiBmaWxsPSIjMUIxRjIzIi8+Cjwvc3ZnPgo="
       class="invertible" alt="GitHub Octicon"
       style="height: 1em; position: relative; top: 0.1em;">
  View on GitHub</a>&ensp;
#+end_export

Nan0Scho1ar's solutions to the [[https://adventofcode.com/][Advent of Code]] problems.
* Solutions
** 2015
*** Day 01: Not Quite Lisp
**** Part 1
***** Description
Collect stars by helping Santa solve puzzles.  Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first.  Each puzzle grants <em class="star">one star~. <span title="Also, some puzzles contain Easter eggs like this one. Yes, I know it's not traditional to do Advent calendars for Easter.">Good luck!</span>
Here's an easy puzzle to warm you up.
Santa is trying to deliver presents in a large apartment building, but he can't find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.
An opening parenthesis, (, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.
The apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.
For example:

~(()) and ()() both result in floor 0.~
~((( and (()(()( both result in floor 3.~
~))((((( also results in floor 3.~
~()) and ))( both result in floor -1 (the first basement level).~
~))) and )())()) both result in floor -3.~

To ~what floor~ do the instructions take Santa?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-01 :var input_data=input-2015-01 :tangle /tmp/advent_of_code/aoc2015-01-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-01 :var input_data=input-2015-01 :tangle /tmp/advent_of_code/aoc2015-01-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-01 :var input_data=input-2015-01 :tangle /tmp/advent_of_code/aoc2015-01-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-01 :var input_data=input-2015-01 :tangle /tmp/advent_of_code/aoc2015-01-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-01 :var input_data=input-2015-01 :tangle /tmp/advent_of_code/aoc2015-01-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-01 :var input_data=input-2015-01 :tangle /tmp/advent_of_code/aoc2015-01-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-01 :var input_data=input-2015-01 :tangle /tmp/advent_of_code/aoc2015-01-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-01 :var input_data=input-2015-01 :tangle /tmp/advent_of_code/aoc2015-01-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-01 :var input_data=input-2015-01 :tangle /tmp/advent_of_code/aoc2015-01-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-01 :var input_data=input-2015-01 :tangle /tmp/advent_of_code/aoc2015-01-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-01 :var input_data=input-2015-01 :tangle /tmp/advent_of_code/aoc2015-01-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-01 :var input_data=input-2015-01 :tangle /tmp/advent_of_code/aoc2015-01-2.pl :results output 
#+end_src
*** Day 02: I Was Told There Would Be No Math
**** Part 1
***** Description
Fortunately, every present is a box (a perfect <a href="https://en.wikipedia.org/wiki/Cuboid#Rectangular_cuboid">right rectangular prism</a>), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is 2*l*w + 2*w*h + 2*h*l.  The elves also need a little extra paper for each present: the area of the smallest side.
For example:

~A present with dimensions 2x3x4 requires 2*6 + 2*12 + 2*8 = 52 square feet of wrapping paper plus 6 square feet of slack, for a total of 58 square feet.~
~A present with dimensions 1x1x10 requires 2*1 + 2*10 + 2*10 = 42 square feet of wrapping paper plus 1 square foot of slack, for a total of 43 square feet.~

All numbers in the elves' list are in <span title="Yes, I realize most of these presents are luxury yachts.">feet</span>.  How many total ~square feet of wrapping paper~ should they order?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-02 :var input_data=input-2015-02 :tangle /tmp/advent_of_code/aoc2015-02-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-02 :var input_data=input-2015-02 :tangle /tmp/advent_of_code/aoc2015-02-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-02 :var input_data=input-2015-02 :tangle /tmp/advent_of_code/aoc2015-02-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-02 :var input_data=input-2015-02 :tangle /tmp/advent_of_code/aoc2015-02-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-02 :var input_data=input-2015-02 :tangle /tmp/advent_of_code/aoc2015-02-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-02 :var input_data=input-2015-02 :tangle /tmp/advent_of_code/aoc2015-02-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-02 :var input_data=input-2015-02 :tangle /tmp/advent_of_code/aoc2015-02-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-02 :var input_data=input-2015-02 :tangle /tmp/advent_of_code/aoc2015-02-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-02 :var input_data=input-2015-02 :tangle /tmp/advent_of_code/aoc2015-02-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-02 :var input_data=input-2015-02 :tangle /tmp/advent_of_code/aoc2015-02-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-02 :var input_data=input-2015-02 :tangle /tmp/advent_of_code/aoc2015-02-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-02 :var input_data=input-2015-02 :tangle /tmp/advent_of_code/aoc2015-02-2.pl :results output 
#+end_src
*** Day 03: Perfectly Spherical Houses in a Vacuum
**** Part 1
***** Description
He begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next.  Moves are always exactly one house to the north (^), south (v), east (&gt;), or west (&lt;).  After each move, he delivers another present to the house at his new location.
However, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once.  How many houses receive ~at least one present~?
For example:

~&gt; delivers presents to 2 houses: one at the starting location, and one to the east.~
~^&gt;v&lt; delivers presents to 4 houses in a square, including twice to the house at his starting/ending location.~
~^v^v^v^v^v delivers a bunch of presents to some very lucky children at only 2 houses.~

 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-03 :var input_data=input-2015-03 :tangle /tmp/advent_of_code/aoc2015-03-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-03 :var input_data=input-2015-03 :tangle /tmp/advent_of_code/aoc2015-03-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-03 :var input_data=input-2015-03 :tangle /tmp/advent_of_code/aoc2015-03-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-03 :var input_data=input-2015-03 :tangle /tmp/advent_of_code/aoc2015-03-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-03 :var input_data=input-2015-03 :tangle /tmp/advent_of_code/aoc2015-03-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-03 :var input_data=input-2015-03 :tangle /tmp/advent_of_code/aoc2015-03-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-03 :var input_data=input-2015-03 :tangle /tmp/advent_of_code/aoc2015-03-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-03 :var input_data=input-2015-03 :tangle /tmp/advent_of_code/aoc2015-03-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-03 :var input_data=input-2015-03 :tangle /tmp/advent_of_code/aoc2015-03-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-03 :var input_data=input-2015-03 :tangle /tmp/advent_of_code/aoc2015-03-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-03 :var input_data=input-2015-03 :tangle /tmp/advent_of_code/aoc2015-03-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-03 :var input_data=input-2015-03 :tangle /tmp/advent_of_code/aoc2015-03-2.pl :results output 
#+end_src
*** Day 04: The Ideal Stocking Stuffer
**** Part 1
***** Description
To do this, he needs to find <a href="https://en.wikipedia.org/wiki/MD5">MD5</a> hashes which, in <a href="https://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a>, start with at least ~five zeroes~.  The input to the MD5 hash is some secret key (your puzzle input, given below) followed by a number in decimal. To mine AdventCoins, you must find Santa the lowest positive number (no leading zeroes: 1, 2, 3, ...) that produces such a hash.
For example:

~If your secret key is abcdef, the answer is 609043, because the MD5 hash of abcdef609043 starts with five zeroes (000001dbbfa...), and it is the lowest such number to do so.~
~If your secret key is pqrstuv, the lowest number it combines with to make an MD5 hash starting with five zeroes is 1048970; that is, the MD5 hash of pqrstuv1048970 looks like 000006136ef....~

 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-04 :var input_data=input-2015-04 :tangle /tmp/advent_of_code/aoc2015-04-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-04 :var input_data=input-2015-04 :tangle /tmp/advent_of_code/aoc2015-04-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-04 :var input_data=input-2015-04 :tangle /tmp/advent_of_code/aoc2015-04-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-04 :var input_data=input-2015-04 :tangle /tmp/advent_of_code/aoc2015-04-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-04 :var input_data=input-2015-04 :tangle /tmp/advent_of_code/aoc2015-04-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-04 :var input_data=input-2015-04 :tangle /tmp/advent_of_code/aoc2015-04-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-04 :var input_data=input-2015-04 :tangle /tmp/advent_of_code/aoc2015-04-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-04 :var input_data=input-2015-04 :tangle /tmp/advent_of_code/aoc2015-04-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-04 :var input_data=input-2015-04 :tangle /tmp/advent_of_code/aoc2015-04-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-04 :var input_data=input-2015-04 :tangle /tmp/advent_of_code/aoc2015-04-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-04 :var input_data=input-2015-04 :tangle /tmp/advent_of_code/aoc2015-04-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-04 :var input_data=input-2015-04 :tangle /tmp/advent_of_code/aoc2015-04-2.pl :results output 
#+end_src
*** Day 05: Doesn't He Have Intern-Elves For This?
**** Part 1
***** Description
A ~nice string~ is one with all of the following properties:

~It contains at least three vowels (aeiou only), like aei, xazegov, or <code title="John Madden John Madden John Madden">aeiouaeiouaeiou.~
~It contains at least one letter that appears twice in a row, like xx, abcdde (dd), or aabbccdd (aa, bb, cc, or dd).~
~It does ~not~ contain the strings ab, cd, pq, or xy, even if they are part of one of the other requirements.~

For example:

~ugknbfddgicrmopn is nice because it has at least three vowels (u...i...o...), a double letter (...dd...), and none of the disallowed substrings.~
~aaa is nice because it has at least three vowels and a double letter, even though the letters used by different rules overlap.~
~jchzalrnumimnmhp is naughty because it has no double letter.~
~haegwjzuvuyypxyu is naughty because it contains the string xy.~
~dvszwmarrgswjxmb is naughty because it contains only one vowel.~

How many strings are nice?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-05 :var input_data=input-2015-05 :tangle /tmp/advent_of_code/aoc2015-05-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-05 :var input_data=input-2015-05 :tangle /tmp/advent_of_code/aoc2015-05-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-05 :var input_data=input-2015-05 :tangle /tmp/advent_of_code/aoc2015-05-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-05 :var input_data=input-2015-05 :tangle /tmp/advent_of_code/aoc2015-05-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-05 :var input_data=input-2015-05 :tangle /tmp/advent_of_code/aoc2015-05-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-05 :var input_data=input-2015-05 :tangle /tmp/advent_of_code/aoc2015-05-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-05 :var input_data=input-2015-05 :tangle /tmp/advent_of_code/aoc2015-05-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-05 :var input_data=input-2015-05 :tangle /tmp/advent_of_code/aoc2015-05-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-05 :var input_data=input-2015-05 :tangle /tmp/advent_of_code/aoc2015-05-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-05 :var input_data=input-2015-05 :tangle /tmp/advent_of_code/aoc2015-05-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-05 :var input_data=input-2015-05 :tangle /tmp/advent_of_code/aoc2015-05-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-05 :var input_data=input-2015-05 :tangle /tmp/advent_of_code/aoc2015-05-2.pl :results output 
#+end_src
*** Day 06: Probably a Fire Hazard
**** Part 1
***** Description
Furthermore, because you've been especially nice this year, Santa has mailed you instructions on how to display the ideal lighting configuration.
Lights in your grid are numbered from 0 to 999 in each direction; the lights at each corner are at 0,0, 0,999, 999,999, and 999,0. The instructions include whether to turn on, turn off, or toggle various inclusive ranges given as coordinate pairs.  Each coordinate pair represents opposite corners of a rectangle, inclusive; a coordinate pair like 0,0 through 2,2 therefore refers to 9 lights in a 3x3 square.  The lights all start turned off.
To defeat your neighbors this year, all you have to do is set up your lights by doing the instructions Santa sent you in order.
For example:

~turn on 0,0 through 999,999 would turn on (or leave on) every light.~
~toggle 0,0 through 999,0 would toggle the first line of 1000 lights, turning off the ones that were on, and turning on the ones that were off.~
~turn off 499,499 through 500,500 would turn off (or leave off) the middle four lights.~

After following the instructions, ~how many lights are lit~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-06 :var input_data=input-2015-06 :tangle /tmp/advent_of_code/aoc2015-06-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-06 :var input_data=input-2015-06 :tangle /tmp/advent_of_code/aoc2015-06-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-06 :var input_data=input-2015-06 :tangle /tmp/advent_of_code/aoc2015-06-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-06 :var input_data=input-2015-06 :tangle /tmp/advent_of_code/aoc2015-06-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-06 :var input_data=input-2015-06 :tangle /tmp/advent_of_code/aoc2015-06-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-06 :var input_data=input-2015-06 :tangle /tmp/advent_of_code/aoc2015-06-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-06 :var input_data=input-2015-06 :tangle /tmp/advent_of_code/aoc2015-06-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-06 :var input_data=input-2015-06 :tangle /tmp/advent_of_code/aoc2015-06-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-06 :var input_data=input-2015-06 :tangle /tmp/advent_of_code/aoc2015-06-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-06 :var input_data=input-2015-06 :tangle /tmp/advent_of_code/aoc2015-06-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-06 :var input_data=input-2015-06 :tangle /tmp/advent_of_code/aoc2015-06-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-06 :var input_data=input-2015-06 :tangle /tmp/advent_of_code/aoc2015-06-2.pl :results output 
#+end_src
*** Day 07: Some Assembly Required
**** Part 1
***** Description
Each wire has an identifier (some lowercase letters) and can carry a <a href="https://en.wikipedia.org/wiki/16-bit">16-bit</a> signal (a number from 0 to 65535).  A signal is provided to each wire by a gate, another wire, or some specific value. Each wire can only get a signal from one source, but can provide its signal to multiple destinations.  A gate provides no signal until all of its inputs have a signal.
The included instructions booklet describes how to connect the parts together: x AND y -&gt; z means to connect wires x and y to an AND gate, and then connect its output to wire z.
For example:

~123 -&gt; x means that the signal 123 is provided to wire x.~
~x AND y -&gt; z means that the <a href="https://en.wikipedia.org/wiki/Bitwise_operation#AND">bitwise AND</a> of wire x and wire y is provided to wire z.~
~p LSHIFT 2 -&gt; q means that the value from wire p is <a href="https://en.wikipedia.org/wiki/Logical_shift">left-shifted</a> by 2 and then provided to wire q.~
~NOT e -&gt; f means that the <a href="https://en.wikipedia.org/wiki/Bitwise_operation#NOT">bitwise complement</a> of the value from wire e is provided to wire f.~

Other possible gates include OR (<a href="https://en.wikipedia.org/wiki/Bitwise_operation#OR">bitwise OR</a>) and RSHIFT (<a href="https://en.wikipedia.org/wiki/Logical_shift">right-shift</a>).  If, for some reason, you'd like to ~emulate~ the circuit instead, almost all programming languages (for example, <a href="https://en.wikipedia.org/wiki/Bitwise_operations_in_C">C</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators">JavaScript</a>, or <a href="https://wiki.python.org/moin/BitwiseOperators">Python</a>) provide operators for these gates.
For example, here is a simple circuit:

#+begin_src text
123 -&gt; x
456 -&gt; y
x AND y -&gt; d
x OR y -&gt; e
x LSHIFT 2 -&gt; f
y RSHIFT 2 -&gt; g
NOT x -&gt; h
NOT y -&gt; i

#+end_src

After it is run, these are the signals on the wires:

#+begin_src text
d: 72
e: 507
f: 492
g: 114
h: 65412
i: 65079
x: 123
y: 456

#+end_src

In little Bobby's kit's instructions booklet (provided as your puzzle input), what signal is ultimately provided to ~wire a~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-07 :var input_data=input-2015-07 :tangle /tmp/advent_of_code/aoc2015-07-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-07 :var input_data=input-2015-07 :tangle /tmp/advent_of_code/aoc2015-07-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-07 :var input_data=input-2015-07 :tangle /tmp/advent_of_code/aoc2015-07-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-07 :var input_data=input-2015-07 :tangle /tmp/advent_of_code/aoc2015-07-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-07 :var input_data=input-2015-07 :tangle /tmp/advent_of_code/aoc2015-07-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-07 :var input_data=input-2015-07 :tangle /tmp/advent_of_code/aoc2015-07-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-07 :var input_data=input-2015-07 :tangle /tmp/advent_of_code/aoc2015-07-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-07 :var input_data=input-2015-07 :tangle /tmp/advent_of_code/aoc2015-07-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-07 :var input_data=input-2015-07 :tangle /tmp/advent_of_code/aoc2015-07-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-07 :var input_data=input-2015-07 :tangle /tmp/advent_of_code/aoc2015-07-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-07 :var input_data=input-2015-07 :tangle /tmp/advent_of_code/aoc2015-07-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-07 :var input_data=input-2015-07 :tangle /tmp/advent_of_code/aoc2015-07-2.pl :results output 
#+end_src
*** Day 08: Matchsticks
**** Part 1
***** Description
It is common in many programming languages to provide a way to <span title="It is common for many programmers to try to escape from string escaping.  No such luck here.">escape</span> special characters in strings.  For example, <a href="https://en.wikipedia.org/wiki/Escape_sequences_in_C">C</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">JavaScript</a>, <a href="http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators">Perl</a>, <a href="https://docs.python.org/2.0/ref/strings.html">Python</a>, and even <a href="http://php.net/manual/en/language.types.string.php#language.types.string.syntax.double">PHP</a> handle special characters in very similar ways.
However, it is important to realize the difference between the number of characters ~in the code representation of the string literal~ and the number of characters ~in the in-memory string itself~.
For example:

~"" is 2 characters of code (the two double quotes), but the string contains zero characters.~
~"abc" is 5 characters of code, but 3 characters in the string data.~
~"aaa\"aaa" is 10 characters of code, but the string itself contains six "a" characters and a single, escaped quote character, for a total of 7 characters in the string data.~
~"\x27" is 6 characters of code, but the string itself contains just one - an apostrophe ('), escaped using hexadecimal notation.~

Santa's list is a file that contains many double-quoted string literals, one on each line.  The only escape sequences used are \\ (which represents a single backslash), \" (which represents a lone double-quote character), and \x plus two hexadecimal characters (which represents a single character with that ASCII code).
Disregarding the whitespace in the file, what is ~the number of characters of code for string literals~ minus ~the number of characters in memory for the values of the strings~ in total for the entire file?
For example, given the four strings above, the total number of characters of string code (2 + 5 + 10 + 6 = 23) minus the total number of characters in memory for string values (0 + 3 + 7 + 1 = 11) is 23 - 11 = 12.
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-08 :var input_data=input-2015-08 :tangle /tmp/advent_of_code/aoc2015-08-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-08 :var input_data=input-2015-08 :tangle /tmp/advent_of_code/aoc2015-08-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-08 :var input_data=input-2015-08 :tangle /tmp/advent_of_code/aoc2015-08-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-08 :var input_data=input-2015-08 :tangle /tmp/advent_of_code/aoc2015-08-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-08 :var input_data=input-2015-08 :tangle /tmp/advent_of_code/aoc2015-08-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-08 :var input_data=input-2015-08 :tangle /tmp/advent_of_code/aoc2015-08-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-08 :var input_data=input-2015-08 :tangle /tmp/advent_of_code/aoc2015-08-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-08 :var input_data=input-2015-08 :tangle /tmp/advent_of_code/aoc2015-08-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-08 :var input_data=input-2015-08 :tangle /tmp/advent_of_code/aoc2015-08-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-08 :var input_data=input-2015-08 :tangle /tmp/advent_of_code/aoc2015-08-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-08 :var input_data=input-2015-08 :tangle /tmp/advent_of_code/aoc2015-08-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-08 :var input_data=input-2015-08 :tangle /tmp/advent_of_code/aoc2015-08-2.pl :results output 
#+end_src
*** Day 09: All in a Single Night
**** Part 1
***** Description
This year, however, he has some <span title="Bonus points if you recognize all of the locations.">new locations</span> to visit; his elves have provided him the distances between every pair of locations.  He can start and end at any two (different) locations he wants, but he must visit each location exactly once.  What is the ~shortest distance~ he can travel to achieve this?
For example, given the following distances:

#+begin_src text
London to Dublin = 464
London to Belfast = 518
Dublin to Belfast = 141

#+end_src

The possible routes are therefore:

#+begin_src text
Dublin -&gt; London -&gt; Belfast = 982
London -&gt; Dublin -&gt; Belfast = 605
London -&gt; Belfast -&gt; Dublin = 659
Dublin -&gt; Belfast -&gt; London = 659
Belfast -&gt; Dublin -&gt; London = 605
Belfast -&gt; London -&gt; Dublin = 982

#+end_src

The shortest of these is London -&gt; Dublin -&gt; Belfast = 605, and so the answer is 605 in this example.
What is the distance of the shortest route?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-09 :var input_data=input-2015-09 :tangle /tmp/advent_of_code/aoc2015-09-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-09 :var input_data=input-2015-09 :tangle /tmp/advent_of_code/aoc2015-09-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-09 :var input_data=input-2015-09 :tangle /tmp/advent_of_code/aoc2015-09-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-09 :var input_data=input-2015-09 :tangle /tmp/advent_of_code/aoc2015-09-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-09 :var input_data=input-2015-09 :tangle /tmp/advent_of_code/aoc2015-09-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-09 :var input_data=input-2015-09 :tangle /tmp/advent_of_code/aoc2015-09-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-09 :var input_data=input-2015-09 :tangle /tmp/advent_of_code/aoc2015-09-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-09 :var input_data=input-2015-09 :tangle /tmp/advent_of_code/aoc2015-09-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-09 :var input_data=input-2015-09 :tangle /tmp/advent_of_code/aoc2015-09-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-09 :var input_data=input-2015-09 :tangle /tmp/advent_of_code/aoc2015-09-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-09 :var input_data=input-2015-09 :tangle /tmp/advent_of_code/aoc2015-09-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-09 :var input_data=input-2015-09 :tangle /tmp/advent_of_code/aoc2015-09-2.pl :results output 
#+end_src
*** Day 10: Elves Look, Elves Say
**** Part 1
***** Description
Look-and-say sequences are generated iteratively, using the previous value as input for the next step.  For each step, take the previous value, and replace each run of digits (like 111) with the number of digits (3) followed by the digit itself (1).
For example:

~1 becomes 11 (1 copy of digit 1).~
~11 becomes 21 (2 copies of digit 1).~
~21 becomes 1211 (one 2 followed by one 1).~
~1211 becomes 111221 (one 1, one 2, and two 1s).~
~111221 becomes 312211 (three 1s, two 2s, and one 1).~

Starting with the digits in your puzzle input, apply this process 40 times.  What is ~the length of the result~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-10 :var input_data=input-2015-10 :tangle /tmp/advent_of_code/aoc2015-10-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-10 :var input_data=input-2015-10 :tangle /tmp/advent_of_code/aoc2015-10-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-10 :var input_data=input-2015-10 :tangle /tmp/advent_of_code/aoc2015-10-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-10 :var input_data=input-2015-10 :tangle /tmp/advent_of_code/aoc2015-10-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-10 :var input_data=input-2015-10 :tangle /tmp/advent_of_code/aoc2015-10-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-10 :var input_data=input-2015-10 :tangle /tmp/advent_of_code/aoc2015-10-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-10 :var input_data=input-2015-10 :tangle /tmp/advent_of_code/aoc2015-10-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-10 :var input_data=input-2015-10 :tangle /tmp/advent_of_code/aoc2015-10-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-10 :var input_data=input-2015-10 :tangle /tmp/advent_of_code/aoc2015-10-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-10 :var input_data=input-2015-10 :tangle /tmp/advent_of_code/aoc2015-10-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-10 :var input_data=input-2015-10 :tangle /tmp/advent_of_code/aoc2015-10-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-10 :var input_data=input-2015-10 :tangle /tmp/advent_of_code/aoc2015-10-2.pl :results output 
#+end_src
*** Day 11: Corporate Policy
**** Part 1
***** Description
To help him remember his new password after the old one expires, Santa has devised a method of coming up with a password based on the previous one.  Corporate policy dictates that passwords must be exactly eight lowercase letters (for security reasons), so he finds his new password by ~incrementing~ his old password string repeatedly until it is valid.
Incrementing is just like counting with numbers: xx, xy, xz, ya, yb, and so on. Increase the rightmost letter one step; if it was z, it wraps around to a, and repeat with the next letter to the left until one doesn't wrap around.
Unfortunately for Santa, a new Security-Elf recently started, and he has imposed some additional password requirements:

~Passwords must include one increasing straight of at least three letters, like abc, bcd, cde, and so on, up to xyz. They cannot skip letters; abd doesn't count.~
~Passwords may not contain the letters i, o, or l, as these letters can be mistaken for other characters and are therefore confusing.~
~Passwords must contain at least two different, non-overlapping pairs of letters, like aa, bb, or zz.~

For example:

~hijklmmn meets the first requirement (because it contains the straight hij) but fails the second requirement requirement (because it contains i and l).~
~abbceffg meets the third requirement (because it repeats bb and ff) but fails the first requirement.~
~abbcegjk fails the third requirement, because it only has one double letter (bb).~
~The next password after abcdefgh is abcdffaa.~
~The next password after ghijklmn is ghjaabcc, because you eventually skip all the passwords that start with ghi..., since i is not allowed.~

Given Santa's current password (your puzzle input), what should his ~next password~ be?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-11 :var input_data=input-2015-11 :tangle /tmp/advent_of_code/aoc2015-11-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-11 :var input_data=input-2015-11 :tangle /tmp/advent_of_code/aoc2015-11-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-11 :var input_data=input-2015-11 :tangle /tmp/advent_of_code/aoc2015-11-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-11 :var input_data=input-2015-11 :tangle /tmp/advent_of_code/aoc2015-11-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-11 :var input_data=input-2015-11 :tangle /tmp/advent_of_code/aoc2015-11-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-11 :var input_data=input-2015-11 :tangle /tmp/advent_of_code/aoc2015-11-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-11 :var input_data=input-2015-11 :tangle /tmp/advent_of_code/aoc2015-11-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-11 :var input_data=input-2015-11 :tangle /tmp/advent_of_code/aoc2015-11-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-11 :var input_data=input-2015-11 :tangle /tmp/advent_of_code/aoc2015-11-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-11 :var input_data=input-2015-11 :tangle /tmp/advent_of_code/aoc2015-11-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-11 :var input_data=input-2015-11 :tangle /tmp/advent_of_code/aoc2015-11-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-11 :var input_data=input-2015-11 :tangle /tmp/advent_of_code/aoc2015-11-2.pl :results output 
#+end_src
*** Day 12: JSAbacusFramework.io
**** Part 1
***** Description
They have a <a href="http://json.org/">JSON</a> document which contains a variety of things: arrays ([1,2,3]), objects ({"a":1, "b":2}), numbers, and strings.  Your first job is to simply find all of the ~numbers~ throughout the document and add them together.
For example:

~[1,2,3] and {"a":2,"b":4} both have a sum of 6.~
~[[[3]]] and {"a":{"b":4},"c":-1} both have a sum of 3.~
~{"a":[-1,1]} and [-1,{"a":1}] both have a sum of 0.~
~[] and {} both have a sum of 0.~

You will not <span title="Nor are you likely to be eaten by a grue... during *this* puzzle, anyway.">encounter</span> any strings containing numbers.
What is the ~sum of all numbers~ in the document?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-12 :var input_data=input-2015-12 :tangle /tmp/advent_of_code/aoc2015-12-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-12 :var input_data=input-2015-12 :tangle /tmp/advent_of_code/aoc2015-12-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-12 :var input_data=input-2015-12 :tangle /tmp/advent_of_code/aoc2015-12-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-12 :var input_data=input-2015-12 :tangle /tmp/advent_of_code/aoc2015-12-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-12 :var input_data=input-2015-12 :tangle /tmp/advent_of_code/aoc2015-12-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-12 :var input_data=input-2015-12 :tangle /tmp/advent_of_code/aoc2015-12-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-12 :var input_data=input-2015-12 :tangle /tmp/advent_of_code/aoc2015-12-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-12 :var input_data=input-2015-12 :tangle /tmp/advent_of_code/aoc2015-12-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-12 :var input_data=input-2015-12 :tangle /tmp/advent_of_code/aoc2015-12-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-12 :var input_data=input-2015-12 :tangle /tmp/advent_of_code/aoc2015-12-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-12 :var input_data=input-2015-12 :tangle /tmp/advent_of_code/aoc2015-12-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-12 :var input_data=input-2015-12 :tangle /tmp/advent_of_code/aoc2015-12-2.pl :results output 
#+end_src
*** Day 13: Knights of the Dinner Table
**** Part 1
***** Description
You start by writing up a list of everyone invited and the amount their happiness would increase or decrease if they were to find themselves sitting next to each other person.  You have a circular table that will be just big enough to fit everyone comfortably, and so each person will have exactly two neighbors.
For example, suppose you have only four attendees planned, and you <span title="Finding a method to calculate happiness units is left as an exercise for the reader.">calculate</span> their potential happiness as follows:

#+begin_src text
Alice would gain 54 happiness units by sitting next to Bob.
Alice would lose 79 happiness units by sitting next to Carol.
Alice would lose 2 happiness units by sitting next to David.
Bob would gain 83 happiness units by sitting next to Alice.
Bob would lose 7 happiness units by sitting next to Carol.
Bob would lose 63 happiness units by sitting next to David.
Carol would lose 62 happiness units by sitting next to Alice.
Carol would gain 60 happiness units by sitting next to Bob.
Carol would gain 55 happiness units by sitting next to David.
David would gain 46 happiness units by sitting next to Alice.
David would lose 7 happiness units by sitting next to Bob.
David would gain 41 happiness units by sitting next to Carol.

#+end_src

Then, if you seat Alice next to David, Alice would lose 2 happiness units (because David talks so much), but David would gain 46 happiness units (because Alice is such a good listener), for a total change of 44.
If you continue around the table, you could then seat Bob next to Alice (Bob gains 83, Alice gains 54).  Finally, seat Carol, who sits next to Bob (Carol gains 60, Bob loses 7) and David (Carol gains 55, David gains 41).  The arrangement looks like this:

#+begin_src text
     +41 +46
+55   David    -2
Carol       Alice
+60    Bob    +54
     -7  +83

#+end_src

After trying every other seating arrangement in this hypothetical scenario, you find that this one is the most optimal, with a total change in happiness of 330.
What is the ~total change in happiness~ for the optimal seating arrangement of the actual guest list?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-13 :var input_data=input-2015-13 :tangle /tmp/advent_of_code/aoc2015-13-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-13 :var input_data=input-2015-13 :tangle /tmp/advent_of_code/aoc2015-13-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-13 :var input_data=input-2015-13 :tangle /tmp/advent_of_code/aoc2015-13-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-13 :var input_data=input-2015-13 :tangle /tmp/advent_of_code/aoc2015-13-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-13 :var input_data=input-2015-13 :tangle /tmp/advent_of_code/aoc2015-13-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-13 :var input_data=input-2015-13 :tangle /tmp/advent_of_code/aoc2015-13-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-13 :var input_data=input-2015-13 :tangle /tmp/advent_of_code/aoc2015-13-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-13 :var input_data=input-2015-13 :tangle /tmp/advent_of_code/aoc2015-13-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-13 :var input_data=input-2015-13 :tangle /tmp/advent_of_code/aoc2015-13-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-13 :var input_data=input-2015-13 :tangle /tmp/advent_of_code/aoc2015-13-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-13 :var input_data=input-2015-13 :tangle /tmp/advent_of_code/aoc2015-13-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-13 :var input_data=input-2015-13 :tangle /tmp/advent_of_code/aoc2015-13-2.pl :results output 
#+end_src
*** Day 14: Reindeer Olympics
**** Part 1
***** Description
Reindeer can only either be ~flying~ (always at their top speed) or ~resting~ (not moving at all), and always spend whole seconds in either state.
For example, suppose you have the following Reindeer:

~Comet can fly ~14 km/s for 10 seconds~, but then must rest for ~127 seconds~.~
~Dancer can fly ~16 km/s for 11 seconds~, but then must rest for ~162 seconds~.~

After one second, Comet has gone 14 km, while Dancer has gone 16 km.  After ten seconds, Comet has gone 140 km, while Dancer has gone 160 km.  On the eleventh second, Comet begins resting (staying at 140 km), and Dancer continues on for a total distance of 176 km.  On the 12th second, both reindeer are resting.  They continue to rest until the 138th second, when Comet flies for another ten seconds.  On the 174th second, Dancer flies for another 11 seconds.
In this example, after the 1000th second, both reindeer are resting, and Comet is in the lead at ~1120~ km (poor Dancer has only gotten 1056 km by that point).  So, in this situation, Comet would win (if the race ended at 1000 seconds).
Given the descriptions of each reindeer (in your puzzle input), after exactly 2503 seconds, ~what distance has the winning reindeer traveled~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-14 :var input_data=input-2015-14 :tangle /tmp/advent_of_code/aoc2015-14-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-14 :var input_data=input-2015-14 :tangle /tmp/advent_of_code/aoc2015-14-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-14 :var input_data=input-2015-14 :tangle /tmp/advent_of_code/aoc2015-14-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-14 :var input_data=input-2015-14 :tangle /tmp/advent_of_code/aoc2015-14-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-14 :var input_data=input-2015-14 :tangle /tmp/advent_of_code/aoc2015-14-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-14 :var input_data=input-2015-14 :tangle /tmp/advent_of_code/aoc2015-14-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-14 :var input_data=input-2015-14 :tangle /tmp/advent_of_code/aoc2015-14-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-14 :var input_data=input-2015-14 :tangle /tmp/advent_of_code/aoc2015-14-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-14 :var input_data=input-2015-14 :tangle /tmp/advent_of_code/aoc2015-14-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-14 :var input_data=input-2015-14 :tangle /tmp/advent_of_code/aoc2015-14-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-14 :var input_data=input-2015-14 :tangle /tmp/advent_of_code/aoc2015-14-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-14 :var input_data=input-2015-14 :tangle /tmp/advent_of_code/aoc2015-14-2.pl :results output 
#+end_src
*** Day 15: Science for Hungry People
**** Part 1
***** Description
Your recipe leaves room for exactly 100 teaspoons of ingredients.  You make a list of the ~remaining ingredients you could use to finish the recipe~ (your puzzle input) and their ~properties per teaspoon~:

~capacity (how well it helps the cookie absorb milk)~
~durability (how well it keeps the cookie intact when full of milk)~
~flavor (how tasty it makes the cookie)~
~texture (how it improves the feel of the cookie)~
~calories (how many calories it adds to the cookie)~

You can only measure ingredients in whole-teaspoon amounts accurately, and you have to be accurate so you can reproduce your results in the future.  The ~total score~ of a cookie can be found by adding up each of the properties (negative totals become 0) and then multiplying together everything except calories.
For instance, suppose you have <span title="* I know what your preference is, but...">these two ingredients</span>:

#+begin_src text
Butterscotch: capacity -1, durability -2, flavor 6, texture 3, calories 8
Cinnamon: capacity 2, durability 3, flavor -2, texture -1, calories 3

#+end_src

Then, choosing to use 44 teaspoons of butterscotch and 56 teaspoons of cinnamon (because the amounts of each ingredient must add up to 100) would result in a cookie with the following properties:

~A capacity of 44*-1 + 56*2 = 68~
~A durability of 44*-2 + 56*3 = 80~
~A flavor of 44*6 + 56*-2 = 152~
~A texture of 44*3 + 56*-1 = 76~

Multiplying these together (68 * 80 * 152 * 76, ignoring calories for now) results in a total score of  62842880, which happens to be the best score possible given these ingredients.  If any properties had produced a negative total, it would have instead become zero, causing the whole score to multiply to zero.
Given the ingredients in your kitchen and their properties, what is the ~total score~ of the highest-scoring cookie you can make?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-15 :var input_data=input-2015-15 :tangle /tmp/advent_of_code/aoc2015-15-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-15 :var input_data=input-2015-15 :tangle /tmp/advent_of_code/aoc2015-15-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-15 :var input_data=input-2015-15 :tangle /tmp/advent_of_code/aoc2015-15-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-15 :var input_data=input-2015-15 :tangle /tmp/advent_of_code/aoc2015-15-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-15 :var input_data=input-2015-15 :tangle /tmp/advent_of_code/aoc2015-15-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-15 :var input_data=input-2015-15 :tangle /tmp/advent_of_code/aoc2015-15-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-15 :var input_data=input-2015-15 :tangle /tmp/advent_of_code/aoc2015-15-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-15 :var input_data=input-2015-15 :tangle /tmp/advent_of_code/aoc2015-15-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-15 :var input_data=input-2015-15 :tangle /tmp/advent_of_code/aoc2015-15-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-15 :var input_data=input-2015-15 :tangle /tmp/advent_of_code/aoc2015-15-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-15 :var input_data=input-2015-15 :tangle /tmp/advent_of_code/aoc2015-15-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-15 :var input_data=input-2015-15 :tangle /tmp/advent_of_code/aoc2015-15-2.pl :results output 
#+end_src
*** Day 16: Aunt Sue
**** Part 1
***** Description
You have 500 Aunts named "Sue".
So, to avoid sending the card to the wrong person, you need to figure out which Aunt Sue (which you conveniently number 1 to 500, for sanity) gave you the gift.  You open the present and, as luck would have it, good ol' Aunt Sue got you a My First Crime Scene Analysis Machine!  Just what you wanted.  Or needed, as the case may be.
The My First Crime Scene Analysis Machine (MFCSAM for short) can detect a few specific compounds in a given sample, as well as how many distinct kinds of those compounds there are. According to the instructions, these are what the MFCSAM can detect:

~children, by human DNA age analysis.~
~cats.  It doesn't differentiate individual breeds.~
~Several <span title="It can tell them apart by their distinct Dog Residue.">seemingly random breeds of dog</span>: <a href="https://en.wikipedia.org/wiki/Samoyed_%28dog%29">samoyeds</a>, <a href="https://en.wikipedia.org/wiki/Pomeranian_%28dog%29">pomeranians</a>, <a href="https://en.wikipedia.org/wiki/Akita_%28dog%29">akitas</a>, and <a href="https://en.wikipedia.org/wiki/Vizsla">vizslas</a>.~
~goldfish.  No other kinds of fish.~
~trees, all in one group.~
~cars, presumably by exhaust or gasoline or something.~
~perfumes, which is handy, since many of your Aunts Sue wear a few kinds.~

In fact, many of your Aunts Sue have many of these.  You put the wrapping from the gift into the MFCSAM.  It beeps inquisitively at you a few times and then prints out a message on <a href="https://en.wikipedia.org/wiki/Ticker_tape">ticker tape</a>:

#+begin_src text
children: 3
cats: 7
samoyeds: 2
pomeranians: 3
akitas: 0
vizslas: 0
goldfish: 5
trees: 3
cars: 2
perfumes: 1

#+end_src

You make a list of the things you can remember about each Aunt Sue.  Things missing from your list aren't zero - you simply don't remember the value.
What is the ~number~ of the Sue that got you the gift?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-16 :var input_data=input-2015-16 :tangle /tmp/advent_of_code/aoc2015-16-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-16 :var input_data=input-2015-16 :tangle /tmp/advent_of_code/aoc2015-16-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-16 :var input_data=input-2015-16 :tangle /tmp/advent_of_code/aoc2015-16-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-16 :var input_data=input-2015-16 :tangle /tmp/advent_of_code/aoc2015-16-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-16 :var input_data=input-2015-16 :tangle /tmp/advent_of_code/aoc2015-16-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-16 :var input_data=input-2015-16 :tangle /tmp/advent_of_code/aoc2015-16-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-16 :var input_data=input-2015-16 :tangle /tmp/advent_of_code/aoc2015-16-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-16 :var input_data=input-2015-16 :tangle /tmp/advent_of_code/aoc2015-16-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-16 :var input_data=input-2015-16 :tangle /tmp/advent_of_code/aoc2015-16-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-16 :var input_data=input-2015-16 :tangle /tmp/advent_of_code/aoc2015-16-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-16 :var input_data=input-2015-16 :tangle /tmp/advent_of_code/aoc2015-16-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-16 :var input_data=input-2015-16 :tangle /tmp/advent_of_code/aoc2015-16-2.pl :results output 
#+end_src
*** Day 17: No Such Thing as Too Much
**** Part 1
***** Description
For example, suppose you have containers of size 20, 15, 10, 5, and 5 liters.  If you need to store 25 liters, there are four ways to do it:

~15 and 10~
~20 and 5 (the first 5)~
~20 and 5 (the second 5)~
~15, 5, and 5~

Filling all containers entirely, how many different ~combinations of containers~ can exactly fit all 150 liters of eggnog?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-17 :var input_data=input-2015-17 :tangle /tmp/advent_of_code/aoc2015-17-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-17 :var input_data=input-2015-17 :tangle /tmp/advent_of_code/aoc2015-17-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-17 :var input_data=input-2015-17 :tangle /tmp/advent_of_code/aoc2015-17-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-17 :var input_data=input-2015-17 :tangle /tmp/advent_of_code/aoc2015-17-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-17 :var input_data=input-2015-17 :tangle /tmp/advent_of_code/aoc2015-17-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-17 :var input_data=input-2015-17 :tangle /tmp/advent_of_code/aoc2015-17-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-17 :var input_data=input-2015-17 :tangle /tmp/advent_of_code/aoc2015-17-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-17 :var input_data=input-2015-17 :tangle /tmp/advent_of_code/aoc2015-17-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-17 :var input_data=input-2015-17 :tangle /tmp/advent_of_code/aoc2015-17-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-17 :var input_data=input-2015-17 :tangle /tmp/advent_of_code/aoc2015-17-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-17 :var input_data=input-2015-17 :tangle /tmp/advent_of_code/aoc2015-17-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-17 :var input_data=input-2015-17 :tangle /tmp/advent_of_code/aoc2015-17-2.pl :results output 
#+end_src
*** Day 18: Like a GIF For Your Yard
**** Part 1
***** Description
Never one to let you down, Santa again mails you instructions on the ideal lighting configuration.  With so few lights, he says, you'll have to resort to ~animation~.
Start by setting your lights to the included initial configuration (your puzzle input).  A # means "on", and a . means "off".
Then, animate your grid in steps, where each step decides the next configuration based on the current one.  Each light's next state (either on or off) depends on its current state and the current states of the eight lights adjacent to it (including diagonals).  Lights on the edge of the grid might have fewer than eight neighbors; the missing ones always count as "off".
For example, in a simplified 6x6 grid, the light marked A has the neighbors numbered 1 through 8, and the light marked B, which is on an edge, only has the neighbors marked 1 through 5:

#+begin_src text
1B5...
234...
......
..123.
..8A4.
..765.

#+end_src

The state a light should have next is based on its current state (on or off) plus the ~number of neighbors that are on~:

~A light which is ~on~ stays on when 2 or 3 neighbors are on, and turns off otherwise.~
~A light which is ~off~ turns on if exactly 3 neighbors are on, and stays off otherwise.~

All of the lights update simultaneously; they all consider the same current state before moving to the next.
Here's a few steps from an example configuration of another 6x6 grid:

#+begin_src text
Initial state:
.#.#.#
...##.
#....#
..#...
#.#..#
####..

After 1 step:
..##..
..##.#
...##.
......
#.....
#.##..

After 2 steps:
..###.
......
..###.
......
.#....
.#....

After 3 steps:
...#..
......
...#..
..##..
......
......

After 4 steps:
......
......
..##..
..##..
......
......

#+end_src

After 4 steps, this example has four lights on.
In your grid of 100x100 lights, given your initial configuration, ~how many lights are on after 100 steps~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-18 :var input_data=input-2015-18 :tangle /tmp/advent_of_code/aoc2015-18-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-18 :var input_data=input-2015-18 :tangle /tmp/advent_of_code/aoc2015-18-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-18 :var input_data=input-2015-18 :tangle /tmp/advent_of_code/aoc2015-18-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-18 :var input_data=input-2015-18 :tangle /tmp/advent_of_code/aoc2015-18-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-18 :var input_data=input-2015-18 :tangle /tmp/advent_of_code/aoc2015-18-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-18 :var input_data=input-2015-18 :tangle /tmp/advent_of_code/aoc2015-18-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-18 :var input_data=input-2015-18 :tangle /tmp/advent_of_code/aoc2015-18-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-18 :var input_data=input-2015-18 :tangle /tmp/advent_of_code/aoc2015-18-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-18 :var input_data=input-2015-18 :tangle /tmp/advent_of_code/aoc2015-18-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-18 :var input_data=input-2015-18 :tangle /tmp/advent_of_code/aoc2015-18-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-18 :var input_data=input-2015-18 :tangle /tmp/advent_of_code/aoc2015-18-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-18 :var input_data=input-2015-18 :tangle /tmp/advent_of_code/aoc2015-18-2.pl :results output 
#+end_src
*** Day 19: Medicine for Rudolph
**** Part 1
***** Description
Red-Nosed Reindeer biology isn't similar to regular reindeer biology; Rudolph is going to need custom-made medicine.  Unfortunately, Red-Nosed Reindeer chemistry isn't similar to regular reindeer chemistry, either.
The North Pole is equipped with a Red-Nosed Reindeer nuclear fusion/fission plant, capable of constructing any Red-Nosed Reindeer molecule you need.  It works by starting with some input molecule and then doing a series of ~replacements~, one per step, until it has the right molecule.
However, the machine has to be calibrated before it can be used.  Calibration involves determining the number of molecules that can be generated in one step from a given starting point.
For example, imagine a simpler machine that supports only the following replacements:

#+begin_src text
H =&gt; HO
H =&gt; OH
O =&gt; HH

#+end_src

Given the replacements above and starting with HOH, the following molecules could be generated:

~HOOH (via H =&gt; HO on the first H).~
~HOHO (via H =&gt; HO on the second H).~
~OHOH (via H =&gt; OH on the first H).~
~HOOH (via H =&gt; OH on the second H).~
~HHHH (via O =&gt; HH).~

So, in the example above, there are 4 ~distinct~ molecules (not five, because HOOH appears twice) after one replacement from HOH. Santa's favorite molecule, HOHOHO, can become 7 ~distinct~ molecules (over nine replacements: six from H, and three from O).
The machine replaces without regard for the surrounding characters.  For example, given the string H2O, the transition H =&gt; OO would result in OO2O.
Your puzzle input describes all of the possible replacements and, at the bottom, the medicine molecule for which you need to calibrate the machine.  ~How many distinct molecules can be created~ after all the different ways you can do one replacement on the medicine molecule?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-19 :var input_data=input-2015-19 :tangle /tmp/advent_of_code/aoc2015-19-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-19 :var input_data=input-2015-19 :tangle /tmp/advent_of_code/aoc2015-19-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-19 :var input_data=input-2015-19 :tangle /tmp/advent_of_code/aoc2015-19-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-19 :var input_data=input-2015-19 :tangle /tmp/advent_of_code/aoc2015-19-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-19 :var input_data=input-2015-19 :tangle /tmp/advent_of_code/aoc2015-19-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-19 :var input_data=input-2015-19 :tangle /tmp/advent_of_code/aoc2015-19-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-19 :var input_data=input-2015-19 :tangle /tmp/advent_of_code/aoc2015-19-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-19 :var input_data=input-2015-19 :tangle /tmp/advent_of_code/aoc2015-19-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-19 :var input_data=input-2015-19 :tangle /tmp/advent_of_code/aoc2015-19-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-19 :var input_data=input-2015-19 :tangle /tmp/advent_of_code/aoc2015-19-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-19 :var input_data=input-2015-19 :tangle /tmp/advent_of_code/aoc2015-19-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-19 :var input_data=input-2015-19 :tangle /tmp/advent_of_code/aoc2015-19-2.pl :results output 
#+end_src
*** Day 20: Infinite Elves and Infinite Houses
**** Part 1
***** Description
Each Elf is assigned a number, too, and delivers presents to houses based on that number:

~The first Elf (number 1) delivers presents to every house: 1, 2, 3, 4, 5, ....~
~The second Elf (number 2) delivers presents to every second house: 2, 4, 6, 8, 10, ....~
~Elf number 3 delivers presents to every third house: 3, 6, 9, 12, 15, ....~

There are infinitely many Elves, numbered starting with 1.  Each Elf delivers presents equal to ~ten times~ his or her number at each house.
So, the first nine houses on the street end up like this:

#+begin_src text
House 1 got 10 presents.
House 2 got 30 presents.
House 3 got 40 presents.
House 4 got 70 presents.
House 5 got 60 presents.
House 6 got 120 presents.
House 7 got 80 presents.
House 8 got 150 presents.
House 9 got 130 presents.

#+end_src

The first house gets 10 presents: it is visited only by Elf 1, which delivers 1 * 10 = 10 presents.  The fourth house gets 70 presents, because it is visited by Elves 1, 2, and 4, for a total of 10 + 20 + 40 = 70 presents.
What is the ~lowest house number~ of the house to get at least as many presents as the number in your puzzle input?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-20 :var input_data=input-2015-20 :tangle /tmp/advent_of_code/aoc2015-20-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-20 :var input_data=input-2015-20 :tangle /tmp/advent_of_code/aoc2015-20-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-20 :var input_data=input-2015-20 :tangle /tmp/advent_of_code/aoc2015-20-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-20 :var input_data=input-2015-20 :tangle /tmp/advent_of_code/aoc2015-20-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-20 :var input_data=input-2015-20 :tangle /tmp/advent_of_code/aoc2015-20-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-20 :var input_data=input-2015-20 :tangle /tmp/advent_of_code/aoc2015-20-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-20 :var input_data=input-2015-20 :tangle /tmp/advent_of_code/aoc2015-20-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-20 :var input_data=input-2015-20 :tangle /tmp/advent_of_code/aoc2015-20-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-20 :var input_data=input-2015-20 :tangle /tmp/advent_of_code/aoc2015-20-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-20 :var input_data=input-2015-20 :tangle /tmp/advent_of_code/aoc2015-20-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-20 :var input_data=input-2015-20 :tangle /tmp/advent_of_code/aoc2015-20-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-20 :var input_data=input-2015-20 :tangle /tmp/advent_of_code/aoc2015-20-2.pl :results output 
#+end_src
*** Day 21: RPG Simulator 20XX
**** Part 1
***** Description
In this game, the player (you) and the enemy (the boss) take turns attacking.  The player always goes first.  Each attack reduces the opponent's hit points by at least 1.  The first character at or below 0 hit points loses.
Damage dealt by an attacker each turn is equal to the attacker's damage score minus the defender's armor score.  An attacker always does at least 1 damage.  So, if the attacker has a damage score of 8, and the defender has an armor score of 3, the defender loses 5 hit points.  If the defender had an armor score of 300, the defender would still lose 1 hit point.
Your damage score and armor score both start at zero.  They can be increased by buying items in exchange for gold.  You start with no items and have as much gold as you need.  Your total damage or armor is equal to the sum of those stats from all of your items.  You have ~100 hit points~.
Here is what the item shop is selling:

#+begin_src text
Weapons:    Cost  Damage  Armor
Dagger        8     4       0
Shortsword   10     5       0
Warhammer    25     6       0
Longsword    40     7       0
Greataxe     74     8       0

Armor:      Cost  Damage  Armor
Leather      13     0       1
Chainmail    31     0       2
Splintmail   53     0       3
Bandedmail   75     0       4
Platemail   102     0       5

Rings:      Cost  Damage  Armor
Damage +1    25     1       0
Damage +2    50     2       0
Damage +3   100     3       0
Defense +1   20     0       1
Defense +2   40     0       2
Defense +3   80     0       3

#+end_src

You must buy exactly one weapon; no dual-wielding.  Armor is optional, but you can't use more than one.  You can buy 0-2 rings (at most one for each hand).  You must use any items you buy.  The shop only has one of each item, so you can't buy, for example, two rings of Damage +3.
For example, suppose you have 8 hit points, 5 damage, and 5 armor, and that the boss has 12 hit points, 7 damage, and 2 armor:

~The player deals 5-2 = 3 damage; the boss goes down to 9 hit points.~
~The boss deals 7-5 = 2 damage; the player goes down to 6 hit points.~
~The player deals 5-2 = 3 damage; the boss goes down to 6 hit points.~
~The boss deals 7-5 = 2 damage; the player goes down to 4 hit points.~
~The player deals 5-2 = 3 damage; the boss goes down to 3 hit points.~
~The boss deals 7-5 = 2 damage; the player goes down to 2 hit points.~
~The player deals 5-2 = 3 damage; the boss goes down to 0 hit points.~

In this scenario, the player wins!  (Barely.)
You have ~100 hit points~.  The boss's actual stats are in your puzzle input.  What is ~the least amount of gold you can spend~ and still win the fight?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-21 :var input_data=input-2015-21 :tangle /tmp/advent_of_code/aoc2015-21-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-21 :var input_data=input-2015-21 :tangle /tmp/advent_of_code/aoc2015-21-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-21 :var input_data=input-2015-21 :tangle /tmp/advent_of_code/aoc2015-21-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-21 :var input_data=input-2015-21 :tangle /tmp/advent_of_code/aoc2015-21-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-21 :var input_data=input-2015-21 :tangle /tmp/advent_of_code/aoc2015-21-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-21 :var input_data=input-2015-21 :tangle /tmp/advent_of_code/aoc2015-21-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-21 :var input_data=input-2015-21 :tangle /tmp/advent_of_code/aoc2015-21-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-21 :var input_data=input-2015-21 :tangle /tmp/advent_of_code/aoc2015-21-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-21 :var input_data=input-2015-21 :tangle /tmp/advent_of_code/aoc2015-21-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-21 :var input_data=input-2015-21 :tangle /tmp/advent_of_code/aoc2015-21-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-21 :var input_data=input-2015-21 :tangle /tmp/advent_of_code/aoc2015-21-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-21 :var input_data=input-2015-21 :tangle /tmp/advent_of_code/aoc2015-21-2.pl :results output 
#+end_src
*** Day 22: Wizard Simulator 20XX
**** Part 1
***** Description
In this version, combat still proceeds with the player and the boss taking alternating turns.  The player still goes first.  Now, however, you don't get any equipment; instead, you must choose one of your spells to cast.  The first character at or below 0 hit points loses.
Since you're a wizard, you don't get to wear armor, and you can't attack normally.  However, since you do ~magic damage~, your opponent's armor is ignored, and so the boss effectively has zero armor as well.  As before, if armor (from a spell, in this case) would reduce damage below 1, it becomes 1 instead - that is, the boss' attacks always deal at least 1 damage.
On each of your turns, you must select one of your spells to cast.  If you cannot afford to cast any spell, you lose.  Spells cost ~mana~; you start with ~500~ mana, but have no maximum limit.  You must have enough mana to cast a spell, and its cost is immediately deducted when you cast it.  Your spells are Magic Missile, Drain, Shield, Poison, and Recharge.

~~Magic Missile~ costs 53 mana.  It instantly does 4 damage.~
~~Drain~ costs 73 mana.  It instantly does 2 damage and heals you for 2 hit points.~
~~Shield~ costs 113 mana.  It starts an ~effect~ that lasts for 6 turns.  While it is active, your armor is increased by 7.~
~~Poison~ costs 173 mana.  It starts an ~effect~ that lasts for 6 turns.  At the start of each turn while it is active, it deals the boss 3 damage.~
~~Recharge~ costs 229 mana.  It starts an ~effect~ that lasts for 5 turns.  At the start of each turn while it is active, it gives you 101 new mana.~

~Effects~ all work the same way.  Effects apply at the start of both the player's turns and the boss' turns.  Effects are created with a timer (the number of turns they last); at the start of each turn, after they apply any effect they have, their timer is decreased by one.  If this decreases the timer to zero, the effect ends.  You cannot cast a spell that would start an effect which is already active.  However, effects can be started on the same turn they end.
For example, suppose the player has 10 hit points and 250 mana, and that the boss has 13 hit points and 8 damage:

#+begin_src text
-- Player turn --
- Player has 10 hit points, 0 armor, 250 mana
- Boss has 13 hit points
Player casts Poison.

-- Boss turn --
- Player has 10 hit points, 0 armor, 77 mana
- Boss has 13 hit points
Poison deals 3 damage; its timer is now 5.
Boss attacks for 8 damage.

-- Player turn --
- Player has 2 hit points, 0 armor, 77 mana
- Boss has 10 hit points
Poison deals 3 damage; its timer is now 4.
Player casts Magic Missile, dealing 4 damage.

-- Boss turn --
- Player has 2 hit points, 0 armor, 24 mana
- Boss has 3 hit points
Poison deals 3 damage. This kills the boss, and the player wins.

#+end_src

Now, suppose the same initial conditions, except that the boss has 14 hit points instead:

#+begin_src text
-- Player turn --
- Player has 10 hit points, 0 armor, 250 mana
- Boss has 14 hit points
Player casts Recharge.

-- Boss turn --
- Player has 10 hit points, 0 armor, 21 mana
- Boss has 14 hit points
Recharge provides 101 mana; its timer is now 4.
Boss attacks for 8 damage!

-- Player turn --
- Player has 2 hit points, 0 armor, 122 mana
- Boss has 14 hit points
Recharge provides 101 mana; its timer is now 3.
Player casts Shield, increasing armor by 7.

-- Boss turn --
- Player has 2 hit points, 7 armor, 110 mana
- Boss has 14 hit points
Shield's timer is now 5.
Recharge provides 101 mana; its timer is now 2.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 1 hit point, 7 armor, 211 mana
- Boss has 14 hit points
Shield's timer is now 4.
Recharge provides 101 mana; its timer is now 1.
Player casts Drain, dealing 2 damage, and healing 2 hit points.

-- Boss turn --
- Player has 3 hit points, 7 armor, 239 mana
- Boss has 12 hit points
Shield's timer is now 3.
Recharge provides 101 mana; its timer is now 0.
Recharge wears off.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 2 hit points, 7 armor, 340 mana
- Boss has 12 hit points
Shield's timer is now 2.
Player casts Poison.

-- Boss turn --
- Player has 2 hit points, 7 armor, 167 mana
- Boss has 12 hit points
Shield's timer is now 1.
Poison deals 3 damage; its timer is now 5.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 1 hit point, 7 armor, 167 mana
- Boss has 9 hit points
Shield's timer is now 0.
Shield wears off, decreasing armor by 7.
Poison deals 3 damage; its timer is now 4.
Player casts Magic Missile, dealing 4 damage.

-- Boss turn --
- Player has 1 hit point, 0 armor, 114 mana
- Boss has 2 hit points
Poison deals 3 damage. This kills the boss, and the player wins.

#+end_src

You start with ~50 hit points~ and ~500 mana points~. The boss's actual stats are in your puzzle input. What is the ~least amount of mana~ you can spend and still win the fight?  (Do not include mana recharge effects as "spending" negative mana.)
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-22 :var input_data=input-2015-22 :tangle /tmp/advent_of_code/aoc2015-22-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-22 :var input_data=input-2015-22 :tangle /tmp/advent_of_code/aoc2015-22-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-22 :var input_data=input-2015-22 :tangle /tmp/advent_of_code/aoc2015-22-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-22 :var input_data=input-2015-22 :tangle /tmp/advent_of_code/aoc2015-22-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-22 :var input_data=input-2015-22 :tangle /tmp/advent_of_code/aoc2015-22-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-22 :var input_data=input-2015-22 :tangle /tmp/advent_of_code/aoc2015-22-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-22 :var input_data=input-2015-22 :tangle /tmp/advent_of_code/aoc2015-22-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-22 :var input_data=input-2015-22 :tangle /tmp/advent_of_code/aoc2015-22-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-22 :var input_data=input-2015-22 :tangle /tmp/advent_of_code/aoc2015-22-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-22 :var input_data=input-2015-22 :tangle /tmp/advent_of_code/aoc2015-22-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-22 :var input_data=input-2015-22 :tangle /tmp/advent_of_code/aoc2015-22-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-22 :var input_data=input-2015-22 :tangle /tmp/advent_of_code/aoc2015-22-2.pl :results output 
#+end_src
*** Day 23: Opening the Turing Lock
**** Part 1
***** Description
The manual explains that the computer supports two <a href="https://en.wikipedia.org/wiki/Processor_register">registers</a> and six <a href="https://en.wikipedia.org/wiki/Instruction_set">instructions</a> (truly, it goes on to remind the reader, a state-of-the-art technology). The registers are named a and b, can hold any <a href="https://en.wikipedia.org/wiki/Natural_number">non-negative integer</a>, and begin with a value of 0.  The instructions are as follows:

~hlf r sets register r to ~half~ its current value, then continues with the next instruction.~
~tpl r sets register r to ~triple~ its current value, then continues with the next instruction.~
~inc r ~increments~ register r, adding 1 to it, then continues with the next instruction.~
~jmp offset is a ~jump~; it continues with the instruction offset away ~relative to itself~.~
~jie r, offset is like jmp, but only jumps if register r is ~even~ ("jump if even").~
~jio r, offset is like jmp, but only jumps if register r is 1 ("jump if ~one~", not odd).~

All three jump instructions work with an ~offset~ relative to that instruction.  The offset is always written with a prefix + or - to indicate the direction of the jump (forward or backward, respectively).  For example, jmp +1 would simply continue with the next instruction, while jmp +0 would continuously jump back to itself forever.
The program exits when it tries to run an instruction beyond the ones defined.
For example, this program sets a to 2, because the jio instruction causes it to skip the tpl instruction:

#+begin_src text
inc a
jio a, +2
tpl a
inc a

#+end_src

What is ~the value in register b~ when the program in your puzzle input is finished executing?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-23 :var input_data=input-2015-23 :tangle /tmp/advent_of_code/aoc2015-23-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-23 :var input_data=input-2015-23 :tangle /tmp/advent_of_code/aoc2015-23-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-23 :var input_data=input-2015-23 :tangle /tmp/advent_of_code/aoc2015-23-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-23 :var input_data=input-2015-23 :tangle /tmp/advent_of_code/aoc2015-23-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-23 :var input_data=input-2015-23 :tangle /tmp/advent_of_code/aoc2015-23-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-23 :var input_data=input-2015-23 :tangle /tmp/advent_of_code/aoc2015-23-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-23 :var input_data=input-2015-23 :tangle /tmp/advent_of_code/aoc2015-23-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-23 :var input_data=input-2015-23 :tangle /tmp/advent_of_code/aoc2015-23-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-23 :var input_data=input-2015-23 :tangle /tmp/advent_of_code/aoc2015-23-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-23 :var input_data=input-2015-23 :tangle /tmp/advent_of_code/aoc2015-23-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-23 :var input_data=input-2015-23 :tangle /tmp/advent_of_code/aoc2015-23-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-23 :var input_data=input-2015-23 :tangle /tmp/advent_of_code/aoc2015-23-2.pl :results output 
#+end_src
*** Day 24: It Hangs in the Balance
**** Part 1
***** Description
No pressure.
Santa has provided you a list of the weights of every package he needs to fit on the sleigh.  The packages need to be split into ~three groups of exactly the same weight~, and every package has to fit.  The first group goes in the passenger compartment of the sleigh, and the second and third go in containers on either side.  Only when all three groups weigh exactly the same amount will the sleigh be able to fly.  Defying physics has rules, you know!
Of course, that's not the only problem.  The first group - the one going in the passenger compartment - needs ~as few packages as possible~ so that Santa has some legroom left over.  It doesn't matter how many packages are in either of the other two groups, so long as all of the groups weigh the same.
Furthermore, Santa tells you, if there are multiple ways to arrange the packages such that the fewest possible are in the first group, you need to choose the way where the first group has ~the smallest quantum entanglement~ to reduce the chance of any <span title="Santa does not elaborate on what he means by this, but the cringe he makes indicates that it wouldn't be pretty.">"complications"</span>.  The quantum entanglement of a group of packages is the <a href="https://en.wikipedia.org/wiki/Product_%28mathematics%29">product</a> of their weights, that is, the value you get when you multiply their weights together.  Only consider quantum entanglement if the first group has the fewest possible number of packages in it and all groups weigh the same amount.
For example, suppose you have ten packages with weights 1 through 5 and 7 through 11.  For this situation, some of the unique first groups, their quantum entanglements, and a way to divide the remaining packages are as follows:

#+begin_src text
Group 1;             Group 2; Group 3
11 9       (QE= 99); 10 8 2;  7 5 4 3 1
10 9 1     (QE= 90); 11 7 2;  8 5 4 3
10 8 2     (QE=160); 11 9;    7 5 4 3 1
10 7 3     (QE=210); 11 9;    8 5 4 2 1
10 5 4 1   (QE=200); 11 9;    8 7 3 2
10 5 3 2   (QE=300); 11 9;    8 7 4 1
10 4 3 2 1 (QE=240); 11 9;    8 7 5
9 8 3      (QE=216); 11 7 2;  10 5 4 1
9 7 4      (QE=252); 11 8 1;  10 5 3 2
9 5 4 2    (QE=360); 11 8 1;  10 7 3
8 7 5      (QE=280); 11 9;    10 4 3 2 1
8 5 4 3    (QE=480); 11 9;    10 7 2 1
7 5 4 3 1  (QE=420); 11 9;    10 8 2

#+end_src

Of these, although 10 9 1 has the smallest quantum entanglement (90), the configuration with only two packages, 11 9, in the passenger compartment gives Santa the most legroom and wins.  In this situation, the quantum entanglement for the ideal configuration is therefore 99.  Had there been two configurations with only two packages in the first group, the one with the smaller quantum entanglement would be chosen.
What is the ~quantum entanglement~ of the first group of packages in the ideal configuration?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-24 :var input_data=input-2015-24 :tangle /tmp/advent_of_code/aoc2015-24-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-24 :var input_data=input-2015-24 :tangle /tmp/advent_of_code/aoc2015-24-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-24 :var input_data=input-2015-24 :tangle /tmp/advent_of_code/aoc2015-24-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-24 :var input_data=input-2015-24 :tangle /tmp/advent_of_code/aoc2015-24-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-24 :var input_data=input-2015-24 :tangle /tmp/advent_of_code/aoc2015-24-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-24 :var input_data=input-2015-24 :tangle /tmp/advent_of_code/aoc2015-24-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-24 :var input_data=input-2015-24 :tangle /tmp/advent_of_code/aoc2015-24-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-24 :var input_data=input-2015-24 :tangle /tmp/advent_of_code/aoc2015-24-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-24 :var input_data=input-2015-24 :tangle /tmp/advent_of_code/aoc2015-24-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-24 :var input_data=input-2015-24 :tangle /tmp/advent_of_code/aoc2015-24-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-24 :var input_data=input-2015-24 :tangle /tmp/advent_of_code/aoc2015-24-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-24 :var input_data=input-2015-24 :tangle /tmp/advent_of_code/aoc2015-24-2.pl :results output 
#+end_src
*** Day 25: Let It Snow
**** Part 1
***** Description
The weather machine beeps!  On the console of the machine is a copy protection message asking you to <a href="https://en.wikipedia.org/wiki/Copy_protection#Early_video_games">enter a code from the instruction manual</a>.  Apparently, it refuses to run unless you give it that code.  No problem; you'll just look up the code in the--
"Ho ho ho", Santa ponders aloud.  "I can't seem to find the manual."
You look up the support number for the manufacturer and give them a call.  Good thing, too - that 49th star wasn't going to earn itself.
"Oh, that machine is quite old!", they tell you.  "That model went out of support six minutes ago, and we just finished shredding all of the manuals.  I bet we can find you the code generation algorithm, though."
After putting you on hold for twenty minutes (your call is ~very~ important to them, it reminded you repeatedly), they finally find an engineer that remembers how the code system works.
The codes are printed on an <span title="The paper is very thin so it can be folded up neatly into the manual.">infinite sheet of paper</span>, starting in the top-left corner.  The codes are filled in by diagonals: starting with the first row with an empty first box, the codes are filled in diagonally up and to the right.  This process repeats until the <a href="https://en.wikipedia.org/wiki/Cantor's_diagonal_argument">infinite paper is covered</a>.  So, the first few codes are filled in in this order:

#+begin_src text
   | 1   2   3   4   5   6  
---+---+---+---+---+---+---+
 1 |  1   3   6  10  15  21
 2 |  2   5   9  14  20
 3 |  4   8  13  19
 4 |  7  12  18
 5 | 11  17
 6 | 16

#+end_src

For example, the 12th code would be written to row 4, column 2; the 15th code would be written to row 1, column 5.
The voice on the other end of the phone continues with how the codes are actually generated.  The first code is 20151125.  After that, each code is generated by taking the previous one, multiplying it by 252533, and then keeping the remainder from dividing that value by 33554393.
So, to find the second code (which ends up in row 2, column 1), start with the previous value, 20151125.  Multiply it by 252533 to get 5088824049625.  Then, divide that by 33554393, which leaves a remainder of 31916031.  That remainder is the second code.
"Oh!", says the voice.  "It looks like we missed a scrap from one of the manuals.  Let me read it to you."  You write down his numbers:

#+begin_src text
   |    1         2         3         4         5         6
---+---------+---------+---------+---------+---------+---------+
 1 | 20151125  18749137  17289845  30943339  10071777  33511524
 2 | 31916031  21629792  16929656   7726640  15514188   4041754
 3 | 16080970   8057251   1601130   7981243  11661866  16474243
 4 | 24592653  32451966  21345942   9380097  10600672  31527494
 5 |    77061  17552253  28094349   6899651   9250759  31663883
 6 | 33071741   6796745  25397450  24659492   1534922  27995004

#+end_src

"Now remember", the voice continues, "that's not even all of the first few numbers; for example, you're missing the one at 7,1 that would come before 6,2.  But, it should be enough to let your-- oh, it's time for lunch!  Bye!"  The call disconnects.
Santa looks nervous.  Your puzzle input contains the message on the machine's console.  ~What code do you give the machine?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-25 :var input_data=input-2015-25 :tangle /tmp/advent_of_code/aoc2015-25-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-25 :var input_data=input-2015-25 :tangle /tmp/advent_of_code/aoc2015-25-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-25 :var input_data=input-2015-25 :tangle /tmp/advent_of_code/aoc2015-25-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-25 :var input_data=input-2015-25 :tangle /tmp/advent_of_code/aoc2015-25-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-25 :var input_data=input-2015-25 :tangle /tmp/advent_of_code/aoc2015-25-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-25 :var input_data=input-2015-25 :tangle /tmp/advent_of_code/aoc2015-25-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2015-25 :var input_data=input-2015-25 :tangle /tmp/advent_of_code/aoc2015-25-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2015-25 :var input_data=input-2015-25 :tangle /tmp/advent_of_code/aoc2015-25-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2015-25 :var input_data=input-2015-25 :tangle /tmp/advent_of_code/aoc2015-25-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2015-25 :var input_data=input-2015-25 :tangle /tmp/advent_of_code/aoc2015-25-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2015-25 :var input_data=input-2015-25 :tangle /tmp/advent_of_code/aoc2015-25-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2015-25 :var input_data=input-2015-25 :tangle /tmp/advent_of_code/aoc2015-25-2.pl :results output 
#+end_src
** 2016
*** Day 01: No Time for a Taxicab
**** Part 1
***** Description
Collect stars by solving puzzles.  Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first.  Each puzzle grants <em class="star">one star~. Good luck!
You're airdropped near ~Easter Bunny Headquarters~ in a city somewhere.  "Near", unfortunately, is as close as you can get - the instructions on the Easter Bunny Recruiting Document the Elves intercepted start here, and nobody had time to work them out further.
The Document indicates that you should start at the given coordinates (where you just landed) and face North.  Then, follow the provided sequence: either turn left (L) or right (R) 90 degrees, then walk forward the given number of blocks, ending at a new intersection.
There's no time to follow such ridiculous instructions on foot, though, so you take a moment and work out the destination.  Given that you can only walk on the <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">street grid of the city</a>, how far is the shortest path to the destination?
For example:

~Following R2, L3 leaves you 2 blocks East and 3 blocks North, or 5 blocks away.~
~R2, R2, R2 leaves you 2 blocks due South of your starting position, which is 2 blocks away.~
~R5, L5, R5, R3 leaves you 12 blocks away.~

~How many blocks away~ is Easter Bunny HQ?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-01 :var input_data=input-2016-01 :tangle /tmp/advent_of_code/aoc2016-01-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-01 :var input_data=input-2016-01 :tangle /tmp/advent_of_code/aoc2016-01-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-01 :var input_data=input-2016-01 :tangle /tmp/advent_of_code/aoc2016-01-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-01 :var input_data=input-2016-01 :tangle /tmp/advent_of_code/aoc2016-01-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-01 :var input_data=input-2016-01 :tangle /tmp/advent_of_code/aoc2016-01-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-01 :var input_data=input-2016-01 :tangle /tmp/advent_of_code/aoc2016-01-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-01 :var input_data=input-2016-01 :tangle /tmp/advent_of_code/aoc2016-01-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-01 :var input_data=input-2016-01 :tangle /tmp/advent_of_code/aoc2016-01-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-01 :var input_data=input-2016-01 :tangle /tmp/advent_of_code/aoc2016-01-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-01 :var input_data=input-2016-01 :tangle /tmp/advent_of_code/aoc2016-01-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-01 :var input_data=input-2016-01 :tangle /tmp/advent_of_code/aoc2016-01-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-01 :var input_data=input-2016-01 :tangle /tmp/advent_of_code/aoc2016-01-2.pl :results output 
#+end_src
*** Day 02: Bathroom Security
**** Part 1
***** Description
"In order to improve security," the document you find says, "bathroom codes will no longer be written down.  Instead, please memorize and follow the procedure below to access the bathrooms."
The document goes on to explain that each button to be pressed can be found by starting on the previous button and moving to adjacent buttons on the keypad: U moves up, D moves down, L moves left, and R moves right. Each line of instructions corresponds to one button, starting at the previous button (or, for the first line, ~the "5" button~); press whatever button you're on at the end of each line. If a move doesn't lead to a button, ignore it.
You can't hold it much longer, so you decide to figure out the code as you walk to the bathroom. You picture a keypad like this:

#+begin_src text
1 2 3
4 5 6
7 8 9

#+end_src

Suppose your instructions are:

#+begin_src text
ULL
RRDDD
LURDL
UUUUD

#+end_src


~You start at "5" and move up (to "2"), left (to "1"), and left (you can't, and stay on "1"), so the first button is 1.~
~Starting from the previous button ("1"), you move right twice (to "3") and then down three times (stopping at "9" after two moves and ignoring the third), ending up with 9.~
~Continuing from "9", you move left, up, right, down, and left, ending with 8.~
~Finally, you move up four times (stopping at "2"), then down once, ending with 5.~

So, in this example, the bathroom code is 1985.
Your puzzle input is the instructions from the document you found at the front desk. What is the ~bathroom code~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-02 :var input_data=input-2016-02 :tangle /tmp/advent_of_code/aoc2016-02-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-02 :var input_data=input-2016-02 :tangle /tmp/advent_of_code/aoc2016-02-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-02 :var input_data=input-2016-02 :tangle /tmp/advent_of_code/aoc2016-02-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-02 :var input_data=input-2016-02 :tangle /tmp/advent_of_code/aoc2016-02-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-02 :var input_data=input-2016-02 :tangle /tmp/advent_of_code/aoc2016-02-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-02 :var input_data=input-2016-02 :tangle /tmp/advent_of_code/aoc2016-02-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-02 :var input_data=input-2016-02 :tangle /tmp/advent_of_code/aoc2016-02-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-02 :var input_data=input-2016-02 :tangle /tmp/advent_of_code/aoc2016-02-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-02 :var input_data=input-2016-02 :tangle /tmp/advent_of_code/aoc2016-02-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-02 :var input_data=input-2016-02 :tangle /tmp/advent_of_code/aoc2016-02-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-02 :var input_data=input-2016-02 :tangle /tmp/advent_of_code/aoc2016-02-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-02 :var input_data=input-2016-02 :tangle /tmp/advent_of_code/aoc2016-02-2.pl :results output 
#+end_src
*** Day 03: Squares With Three Sides
**** Part 1
***** Description
Or are they?
The design document gives the side lengths of each triangle it describes, but... 5 10 25?  Some of these aren't triangles. You can't help but mark the impossible ones.
In a valid triangle, the sum of any two sides must be larger than the remaining side.  For example, the "triangle" given above is <span title="Unless it's on a sphere!">impossible</span>, because 5 + 10 is not larger than 25.
In your puzzle input, ~how many~ of the listed triangles are ~possible~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-03 :var input_data=input-2016-03 :tangle /tmp/advent_of_code/aoc2016-03-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-03 :var input_data=input-2016-03 :tangle /tmp/advent_of_code/aoc2016-03-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-03 :var input_data=input-2016-03 :tangle /tmp/advent_of_code/aoc2016-03-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-03 :var input_data=input-2016-03 :tangle /tmp/advent_of_code/aoc2016-03-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-03 :var input_data=input-2016-03 :tangle /tmp/advent_of_code/aoc2016-03-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-03 :var input_data=input-2016-03 :tangle /tmp/advent_of_code/aoc2016-03-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-03 :var input_data=input-2016-03 :tangle /tmp/advent_of_code/aoc2016-03-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-03 :var input_data=input-2016-03 :tangle /tmp/advent_of_code/aoc2016-03-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-03 :var input_data=input-2016-03 :tangle /tmp/advent_of_code/aoc2016-03-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-03 :var input_data=input-2016-03 :tangle /tmp/advent_of_code/aoc2016-03-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-03 :var input_data=input-2016-03 :tangle /tmp/advent_of_code/aoc2016-03-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-03 :var input_data=input-2016-03 :tangle /tmp/advent_of_code/aoc2016-03-2.pl :results output 
#+end_src
*** Day 04: Security Through Obscurity
**** Part 1
***** Description
Each room consists of an encrypted name (lowercase letters separated by dashes) followed by a dash, a sector ID, and a checksum in square brackets.
A room is real (not a decoy) if the checksum is the five most common letters in the encrypted name, in order, with ties broken by alphabetization.  For example:

~aaaaa-bbb-z-y-x-123[abxyz] is a real room because the most common letters are a (5), b (3), and then a tie between x, y, and z, which are listed alphabetically.~
~a-b-c-d-e-f-g-h-987[abcde] is a real room because although the letters are all tied (1 of each), the first five are listed alphabetically.~
~not-a-real-room-404[oarel] is a real room.~
~totally-real-room-200[decoy] is not.~

Of the real rooms from the list above, the sum of their sector IDs is 1514.
What is the ~sum of the sector IDs of the real rooms~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-04 :var input_data=input-2016-04 :tangle /tmp/advent_of_code/aoc2016-04-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-04 :var input_data=input-2016-04 :tangle /tmp/advent_of_code/aoc2016-04-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-04 :var input_data=input-2016-04 :tangle /tmp/advent_of_code/aoc2016-04-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-04 :var input_data=input-2016-04 :tangle /tmp/advent_of_code/aoc2016-04-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-04 :var input_data=input-2016-04 :tangle /tmp/advent_of_code/aoc2016-04-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-04 :var input_data=input-2016-04 :tangle /tmp/advent_of_code/aoc2016-04-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-04 :var input_data=input-2016-04 :tangle /tmp/advent_of_code/aoc2016-04-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-04 :var input_data=input-2016-04 :tangle /tmp/advent_of_code/aoc2016-04-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-04 :var input_data=input-2016-04 :tangle /tmp/advent_of_code/aoc2016-04-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-04 :var input_data=input-2016-04 :tangle /tmp/advent_of_code/aoc2016-04-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-04 :var input_data=input-2016-04 :tangle /tmp/advent_of_code/aoc2016-04-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-04 :var input_data=input-2016-04 :tangle /tmp/advent_of_code/aoc2016-04-2.pl :results output 
#+end_src
*** Day 05: How About a Nice Game of Chess?
**** Part 1
***** Description
The ~eight-character password~ for the door is generated one character at a time by finding the <a href="https://en.wikipedia.org/wiki/MD5">MD5</a> hash of some Door ID (your puzzle input) and an increasing integer index (starting with 0).
A hash indicates the ~next character~ in the password if its <a href="https://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a> representation starts with ~five zeroes~. If it does, the sixth character in the hash is the next character of the password.
For example, if the Door ID is abc:

~The first index which produces a hash that starts with five zeroes is 3231929, which we find by hashing abc3231929; the sixth character of the hash, and thus the first character of the password, is 1.~
~5017308 produces the next interesting hash, which starts with 000008f82..., so the second character of the password is 8.~
~The third time a hash starts with five zeroes is for abc5278568, discovering the character f.~

In this example, after continuing this search a total of eight times, the password is 18f47a30.
Given the actual Door ID, ~what is the password~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-05 :var input_data=input-2016-05 :tangle /tmp/advent_of_code/aoc2016-05-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-05 :var input_data=input-2016-05 :tangle /tmp/advent_of_code/aoc2016-05-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-05 :var input_data=input-2016-05 :tangle /tmp/advent_of_code/aoc2016-05-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-05 :var input_data=input-2016-05 :tangle /tmp/advent_of_code/aoc2016-05-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-05 :var input_data=input-2016-05 :tangle /tmp/advent_of_code/aoc2016-05-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-05 :var input_data=input-2016-05 :tangle /tmp/advent_of_code/aoc2016-05-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-05 :var input_data=input-2016-05 :tangle /tmp/advent_of_code/aoc2016-05-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-05 :var input_data=input-2016-05 :tangle /tmp/advent_of_code/aoc2016-05-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-05 :var input_data=input-2016-05 :tangle /tmp/advent_of_code/aoc2016-05-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-05 :var input_data=input-2016-05 :tangle /tmp/advent_of_code/aoc2016-05-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-05 :var input_data=input-2016-05 :tangle /tmp/advent_of_code/aoc2016-05-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-05 :var input_data=input-2016-05 :tangle /tmp/advent_of_code/aoc2016-05-2.pl :results output 
#+end_src
*** Day 06: Signals and Noise
**** Part 1
***** Description
In this model, the same message is sent repeatedly.  You've recorded the repeating message signal (your puzzle input), but the data seems quite corrupted - almost too badly to recover. ~Almost~.
All you need to do is figure out which character is most frequent for each position. For example, suppose you had recorded the following messages:

#+begin_src text
eedadn
drvtee
eandsr
raavrd
atevrs
tsrnev
sdttsa
rasrtv
nssdts
ntnada
svetve
tesnvt
vntsnd
vrdear
dvrsen
enarar

#+end_src

The most common character in the first column is e; in the second, a; in the third, s, and so on. Combining these characters returns the error-corrected message, easter.
Given the recording in your puzzle input, ~what is the error-corrected version~ of the message being sent?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-06 :var input_data=input-2016-06 :tangle /tmp/advent_of_code/aoc2016-06-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-06 :var input_data=input-2016-06 :tangle /tmp/advent_of_code/aoc2016-06-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-06 :var input_data=input-2016-06 :tangle /tmp/advent_of_code/aoc2016-06-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-06 :var input_data=input-2016-06 :tangle /tmp/advent_of_code/aoc2016-06-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-06 :var input_data=input-2016-06 :tangle /tmp/advent_of_code/aoc2016-06-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-06 :var input_data=input-2016-06 :tangle /tmp/advent_of_code/aoc2016-06-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-06 :var input_data=input-2016-06 :tangle /tmp/advent_of_code/aoc2016-06-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-06 :var input_data=input-2016-06 :tangle /tmp/advent_of_code/aoc2016-06-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-06 :var input_data=input-2016-06 :tangle /tmp/advent_of_code/aoc2016-06-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-06 :var input_data=input-2016-06 :tangle /tmp/advent_of_code/aoc2016-06-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-06 :var input_data=input-2016-06 :tangle /tmp/advent_of_code/aoc2016-06-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-06 :var input_data=input-2016-06 :tangle /tmp/advent_of_code/aoc2016-06-2.pl :results output 
#+end_src
*** Day 07: Internet Protocol Version 7
**** Part 1
***** Description
An IP supports TLS if it has an Autonomous Bridge Bypass Annotation, or <span title="Any similarity to the pattern it describes is purely coincidental.">~ABBA~</span>.  An ABBA is any four-character sequence which consists of a pair of two different characters followed by the reverse of that pair, such as xyyx or abba.  However, the IP also must not have an ABBA within any hypernet sequences, which are contained by ~square brackets~.
For example:

~abba[mnop]qrst supports TLS (abba outside square brackets).~
~abcd[bddb]xyyx does ~not~ support TLS (bddb is within square brackets, even though xyyx is outside square brackets).~
~aaaa[qwer]tyui does ~not~ support TLS (aaaa is invalid; the interior characters must be different).~
~ioxxoj[asdfgh]zxcvbn supports TLS (oxxo is outside square brackets, even though it's within a larger string).~

~How many IPs~ in your puzzle input support TLS?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-07 :var input_data=input-2016-07 :tangle /tmp/advent_of_code/aoc2016-07-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-07 :var input_data=input-2016-07 :tangle /tmp/advent_of_code/aoc2016-07-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-07 :var input_data=input-2016-07 :tangle /tmp/advent_of_code/aoc2016-07-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-07 :var input_data=input-2016-07 :tangle /tmp/advent_of_code/aoc2016-07-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-07 :var input_data=input-2016-07 :tangle /tmp/advent_of_code/aoc2016-07-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-07 :var input_data=input-2016-07 :tangle /tmp/advent_of_code/aoc2016-07-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-07 :var input_data=input-2016-07 :tangle /tmp/advent_of_code/aoc2016-07-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-07 :var input_data=input-2016-07 :tangle /tmp/advent_of_code/aoc2016-07-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-07 :var input_data=input-2016-07 :tangle /tmp/advent_of_code/aoc2016-07-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-07 :var input_data=input-2016-07 :tangle /tmp/advent_of_code/aoc2016-07-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-07 :var input_data=input-2016-07 :tangle /tmp/advent_of_code/aoc2016-07-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-07 :var input_data=input-2016-07 :tangle /tmp/advent_of_code/aoc2016-07-2.pl :results output 
#+end_src
*** Day 08: Two-Factor Authentication
**** Part 1
***** Description
To get past the door, you first swipe a keycard (no problem; there was one on a nearby desk). Then, it displays a code on a <a href="https://www.google.com/search?q=tiny+lcd&amp;tbm=isch">little screen</a>, and you type that code on a keypad. Then, presumably, the door unlocks.
Unfortunately, the screen has been <span title="BUT BY WHOM?!">smashed</span>. After a few minutes, you've taken everything apart and figured out how it works. Now you just have to work out what the screen ~would~ have displayed.
The magnetic strip on the card you swiped encodes a series of instructions for the screen; these instructions are your puzzle input. The screen is ~50 pixels wide and 6 pixels tall~, all of which start ~off~, and is capable of three somewhat peculiar operations:

~rect AxB turns ~on~ all of the pixels in a rectangle at the top-left of the screen which is A wide and B tall.~
~rotate row y=A by B shifts all of the pixels in row A (0 is the top row) ~right~ by B pixels. Pixels that would fall off the right end appear at the left end of the row.~
~rotate column x=A by B shifts all of the pixels in column A (0 is the left column) ~down~ by B pixels. Pixels that would fall off the bottom appear at the top of the column.~

For example, here is a simple sequence on a smaller screen:

~rect 3x2 creates a small rectangle in the top-left corner:
#+begin_src text
###....
###....
.......
#+end_src
~
~rotate column x=1 by 1 rotates the second column down by one pixel:
#+begin_src text
#.#....
###....
.#.....
#+end_src
~
~rotate row y=0 by 4 rotates the top row right by four pixels:
#+begin_src text
....#.#
###....
.#.....
#+end_src
~
~rotate column x=1 by 1 again rotates the second column down by one pixel, causing the bottom pixel to wrap back to the top:
#+begin_src text
.#..#.#
#.#....
.#.....
#+end_src
~

As you can see, this display technology is extremely powerful, and will soon dominate the tiny-code-displaying-screen market.  That's what the advertisement on the back of the display tries to convince you, anyway.
There seems to be an intermediate check of the voltage used by the display: after you swipe your card, if the screen did work, ~how many pixels should be lit?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-08 :var input_data=input-2016-08 :tangle /tmp/advent_of_code/aoc2016-08-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-08 :var input_data=input-2016-08 :tangle /tmp/advent_of_code/aoc2016-08-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-08 :var input_data=input-2016-08 :tangle /tmp/advent_of_code/aoc2016-08-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-08 :var input_data=input-2016-08 :tangle /tmp/advent_of_code/aoc2016-08-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-08 :var input_data=input-2016-08 :tangle /tmp/advent_of_code/aoc2016-08-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-08 :var input_data=input-2016-08 :tangle /tmp/advent_of_code/aoc2016-08-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-08 :var input_data=input-2016-08 :tangle /tmp/advent_of_code/aoc2016-08-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-08 :var input_data=input-2016-08 :tangle /tmp/advent_of_code/aoc2016-08-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-08 :var input_data=input-2016-08 :tangle /tmp/advent_of_code/aoc2016-08-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-08 :var input_data=input-2016-08 :tangle /tmp/advent_of_code/aoc2016-08-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-08 :var input_data=input-2016-08 :tangle /tmp/advent_of_code/aoc2016-08-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-08 :var input_data=input-2016-08 :tangle /tmp/advent_of_code/aoc2016-08-2.pl :results output 
#+end_src
*** Day 09: Explosives in Cyberspace
**** Part 1
***** Description
The format compresses a sequence of characters. Whitespace is ignored. To indicate that some sequence should be repeated, a marker is added to the file, like (10x2). To decompress this marker, take the subsequent 10 characters and repeat them 2 times. Then, continue reading the file ~after~ the repeated data.  The marker itself is not included in the decompressed output.
If parentheses or other characters appear within the data referenced by a marker, that's okay - treat it like normal data, not a marker, and then resume looking for markers after the decompressed section.
For example:

~ADVENT contains no markers and decompresses to itself with no changes, resulting in a decompressed length of 6.~
~A(1x5)BC repeats only the B a total of 5 times, becoming ABBBBBC for a decompressed length of 7.~
~(3x3)XYZ becomes XYZXYZXYZ for a decompressed length of 9.~
~A(2x2)BCD(2x2)EFG doubles the BC and EF, becoming ABCBCDEFEFG for a decompressed length of 11.~
~(6x1)(1x3)A simply becomes (1x3)A - the (1x3) looks like a marker, but because it's within a data section of another marker, it is not treated any differently from the A that comes after it. It has a decompressed length of 6.~
~X(8x2)(3x3)ABCY becomes X(3x3)ABC(3x3)ABCY (for a decompressed length of 18), because the decompressed data from the (8x2) marker (the (3x3)ABC) is skipped and not processed further.~

What is the ~decompressed length~ of the file (your puzzle input)? Don't count whitespace.
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-09 :var input_data=input-2016-09 :tangle /tmp/advent_of_code/aoc2016-09-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-09 :var input_data=input-2016-09 :tangle /tmp/advent_of_code/aoc2016-09-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-09 :var input_data=input-2016-09 :tangle /tmp/advent_of_code/aoc2016-09-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-09 :var input_data=input-2016-09 :tangle /tmp/advent_of_code/aoc2016-09-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-09 :var input_data=input-2016-09 :tangle /tmp/advent_of_code/aoc2016-09-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-09 :var input_data=input-2016-09 :tangle /tmp/advent_of_code/aoc2016-09-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-09 :var input_data=input-2016-09 :tangle /tmp/advent_of_code/aoc2016-09-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-09 :var input_data=input-2016-09 :tangle /tmp/advent_of_code/aoc2016-09-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-09 :var input_data=input-2016-09 :tangle /tmp/advent_of_code/aoc2016-09-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-09 :var input_data=input-2016-09 :tangle /tmp/advent_of_code/aoc2016-09-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-09 :var input_data=input-2016-09 :tangle /tmp/advent_of_code/aoc2016-09-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-09 :var input_data=input-2016-09 :tangle /tmp/advent_of_code/aoc2016-09-2.pl :results output 
#+end_src
*** Day 10: Balance Bots
**** Part 1
***** Description
Upon closer examination, you notice that each bot only proceeds when it has ~two~ microchips, and once it does, it gives each one to a different bot or puts it in a marked "output" bin. Sometimes, bots take microchips from "input" bins, too.
Inspecting one of the microchips, it seems like they each contain a single number; the bots must use some logic to decide what to do with each chip. You access the local control computer and download the bots' instructions (your puzzle input).
Some of the instructions specify that a specific-valued microchip should be given to a specific bot; the rest of the instructions indicate what a given bot should do with its ~lower-value~ or ~higher-value~ chip.
For example, consider the following instructions:

#+begin_src text
value 5 goes to bot 2
bot 2 gives low to bot 1 and high to bot 0
value 3 goes to bot 1
bot 1 gives low to output 1 and high to bot 0
bot 0 gives low to output 2 and high to output 0
value 2 goes to bot 2

#+end_src


~Initially, bot 1 starts with a value-3 chip, and bot 2 starts with a value-2 chip and a value-5 chip.~
~Because bot 2 has two microchips, it gives its lower one (2) to bot 1 and its higher one (5) to bot 0.~
~Then, bot 1 has two microchips; it puts the value-2 chip in output 1 and gives the value-3 chip to bot 0.~
~Finally, bot 0 has two microchips; it puts the 3 in output 2 and the 5 in output 0.~

In the end, output bin 0 contains a value-5 microchip, output bin 1 contains a value-2 microchip, and output bin 2 contains a value-3 microchip. In this configuration, bot number ~2~ is responsible for comparing value-5 microchips with value-2 microchips.
Based on your instructions, ~what is the number of the bot~ that is responsible for comparing value-61 microchips with value-17 microchips?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-10 :var input_data=input-2016-10 :tangle /tmp/advent_of_code/aoc2016-10-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-10 :var input_data=input-2016-10 :tangle /tmp/advent_of_code/aoc2016-10-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-10 :var input_data=input-2016-10 :tangle /tmp/advent_of_code/aoc2016-10-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-10 :var input_data=input-2016-10 :tangle /tmp/advent_of_code/aoc2016-10-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-10 :var input_data=input-2016-10 :tangle /tmp/advent_of_code/aoc2016-10-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-10 :var input_data=input-2016-10 :tangle /tmp/advent_of_code/aoc2016-10-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-10 :var input_data=input-2016-10 :tangle /tmp/advent_of_code/aoc2016-10-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-10 :var input_data=input-2016-10 :tangle /tmp/advent_of_code/aoc2016-10-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-10 :var input_data=input-2016-10 :tangle /tmp/advent_of_code/aoc2016-10-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-10 :var input_data=input-2016-10 :tangle /tmp/advent_of_code/aoc2016-10-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-10 :var input_data=input-2016-10 :tangle /tmp/advent_of_code/aoc2016-10-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-10 :var input_data=input-2016-10 :tangle /tmp/advent_of_code/aoc2016-10-2.pl :results output 
#+end_src
*** Day 11: Radioisotope Thermoelectric Generators
**** Part 1
***** Description
According to the project status board, this facility is currently being used to experiment with <a href="https://en.wikipedia.org/wiki/Radioisotope_thermoelectric_generator">Radioisotope Thermoelectric Generators</a> (RTGs, or simply "generators") that are designed to be paired with specially-constructed microchips. Basically, an RTG is a highly radioactive rock that generates electricity through heat.
The <span title="The previous version, model number PB-NUK, used Blutonium.">experimental RTGs</span> have poor radiation containment, so they're dangerously radioactive. The chips are prototypes and don't have normal radiation shielding, but they do have the ability to ~generate an electromagnetic radiation shield when powered~.  Unfortunately, they can ~only~ be powered by their corresponding RTG. An RTG powering a microchip is still dangerous to other microchips.
In other words, if a chip is ever left in the same area as another RTG, and it's not connected to its own RTG, the chip will be ~fried~. Therefore, it is assumed that you will follow procedure and keep chips connected to their corresponding RTG when they're in the same room, and away from other RTGs otherwise.
These microchips sound very interesting and useful to your current activities, and you'd like to try to retrieve them.  The fourth floor of the facility has an assembling machine which can make a self-contained, shielded computer for you to take with you - that is, if you can bring it all of the RTGs and microchips.
Within the radiation-shielded part of the facility (in which it's safe to have these pre-assembly RTGs), there is an elevator that can move between the four floors. Its capacity rating means it can carry at most yourself and two RTGs or microchips in any combination. (They're rigged to some heavy diagnostic equipment - the assembling machine will detach it for you.) As a security measure, the elevator will only function if it contains at least one RTG or microchip. The elevator always stops on each floor to recharge, and this takes long enough that the items within it and the items on that floor can irradiate each other. (You can prevent this if a Microchip and its Generator end up on the same floor in this way, as they can be connected while the elevator is recharging.)
You make some notes of the locations of each component of interest (your puzzle input). Before you don a hazmat suit and start moving things around, you'd like to have an idea of what you need to do.
When you enter the containment area, you and the elevator will start on the first floor.
For example, suppose the isolated area has the following arrangement:
<pre class="wrap">The first floor contains a hydrogen-compatible microchip and a lithium-compatible microchip.
The second floor contains a hydrogen generator.
The third floor contains a lithium generator.
The fourth floor contains nothing relevant.

#+end_src

As a diagram (F# for a Floor number, E for Elevator, H for Hydrogen, L for Lithium, M for Microchip, and G for Generator), the initial state looks like this:

#+begin_src text
F4 .  .  .  .  .  
F3 .  .  .  LG .  
F2 .  HG .  .  .  
F1 E  .  HM .  LM 

#+end_src

Then, to get everything up to the assembling machine on the fourth floor, the following steps could be taken:

~Bring the Hydrogen-compatible Microchip to the second floor, which is safe because it can get power from the Hydrogen Generator:
#+begin_src text
F4 .  .  .  .  .  
F3 .  .  .  LG .  
F2 E  HG HM .  .  
F1 .  .  .  .  LM 

#+end_src
~
~Bring both Hydrogen-related items to the third floor, which is safe because the Hydrogen-compatible microchip is getting power from its generator:
#+begin_src text
F4 .  .  .  .  .  
F3 E  HG HM LG .  
F2 .  .  .  .  .  
F1 .  .  .  .  LM 

#+end_src
~
~Leave the Hydrogen Generator on floor three, but bring the Hydrogen-compatible Microchip back down with you so you can still use the elevator:
#+begin_src text
F4 .  .  .  .  .  
F3 .  HG .  LG .  
F2 E  .  HM .  .  
F1 .  .  .  .  LM 

#+end_src
~
~At the first floor, grab the Lithium-compatible Microchip, which is safe because Microchips don't affect each other:
#+begin_src text
F4 .  .  .  .  .  
F3 .  HG .  LG .  
F2 .  .  .  .  .  
F1 E  .  HM .  LM 

#+end_src
~
~Bring both Microchips up one floor, where there is nothing to fry them:
#+begin_src text
F4 .  .  .  .  .  
F3 .  HG .  LG .  
F2 E  .  HM .  LM 
F1 .  .  .  .  .  

#+end_src
~
~Bring both Microchips up again to floor three, where they can be temporarily connected to their corresponding generators while the elevator recharges, preventing either of them from being fried:
#+begin_src text
F4 .  .  .  .  .  
F3 E  HG HM LG LM 
F2 .  .  .  .  .  
F1 .  .  .  .  .  

#+end_src
~
~Bring both Microchips to the fourth floor:
#+begin_src text
F4 E  .  HM .  LM 
F3 .  HG .  LG .  
F2 .  .  .  .  .  
F1 .  .  .  .  .  

#+end_src
~
~Leave the Lithium-compatible microchip on the fourth floor, but bring the Hydrogen-compatible one so you can still use the elevator; this is safe because although the Lithium Generator is on the destination floor, you can connect Hydrogen-compatible microchip to the Hydrogen Generator there:
#+begin_src text
F4 .  .  .  .  LM 
F3 E  HG HM LG .  
F2 .  .  .  .  .  
F1 .  .  .  .  .  

#+end_src
~
~Bring both Generators up to the fourth floor, which is safe because you can connect the Lithium-compatible Microchip to the Lithium Generator upon arrival:
#+begin_src text
F4 E  HG .  LG LM 
F3 .  .  HM .  .  
F2 .  .  .  .  .  
F1 .  .  .  .  .  

#+end_src
~
~Bring the Lithium Microchip with you to the third floor so you can use the elevator:
#+begin_src text
F4 .  HG .  LG .  
F3 E  .  HM .  LM 
F2 .  .  .  .  .  
F1 .  .  .  .  .  

#+end_src
~
~Bring both Microchips to the fourth floor:
#+begin_src text
F4 E  HG HM LG LM 
F3 .  .  .  .  .  
F2 .  .  .  .  .  
F1 .  .  .  .  .  

#+end_src
~

In this arrangement, it takes 11 steps to collect all of the objects at the fourth floor for assembly. (Each elevator stop counts as one step, even if nothing is added to or removed from it.)
In your situation, what is the ~minimum number of steps~ required to bring all of the objects to the fourth floor?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-11 :var input_data=input-2016-11 :tangle /tmp/advent_of_code/aoc2016-11-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-11 :var input_data=input-2016-11 :tangle /tmp/advent_of_code/aoc2016-11-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-11 :var input_data=input-2016-11 :tangle /tmp/advent_of_code/aoc2016-11-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-11 :var input_data=input-2016-11 :tangle /tmp/advent_of_code/aoc2016-11-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-11 :var input_data=input-2016-11 :tangle /tmp/advent_of_code/aoc2016-11-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-11 :var input_data=input-2016-11 :tangle /tmp/advent_of_code/aoc2016-11-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-11 :var input_data=input-2016-11 :tangle /tmp/advent_of_code/aoc2016-11-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-11 :var input_data=input-2016-11 :tangle /tmp/advent_of_code/aoc2016-11-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-11 :var input_data=input-2016-11 :tangle /tmp/advent_of_code/aoc2016-11-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-11 :var input_data=input-2016-11 :tangle /tmp/advent_of_code/aoc2016-11-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-11 :var input_data=input-2016-11 :tangle /tmp/advent_of_code/aoc2016-11-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-11 :var input_data=input-2016-11 :tangle /tmp/advent_of_code/aoc2016-11-2.pl :results output 
#+end_src
*** Day 12: Leonardo's Monorail
**** Part 1
***** Description
While sitting on a nearby bench amidst some <a href="https://www.google.com/search?q=tiger+lilies&amp;tbm=isch">tiger lilies</a>, you manage to decrypt some of the files you extracted from the servers downstairs.
According to these documents, Easter Bunny HQ isn't just this building - it's a collection of buildings in the nearby area. They're all connected by a local monorail, and there's another building not far from here! Unfortunately, being night, the monorail is currently not operating.
You remotely connect to the monorail control systems and discover that the boot sequence expects a password. The password-checking logic (your puzzle input) is easy to extract, but the code it uses is strange: it's <span title="Strangely, this assembunny code doesn't seem to be very good at multiplying.">assembunny</span> code designed for the <a href="11">new computer</a> you just assembled. You'll have to execute the code and get the password.
The assembunny code you've extracted operates on four <a href="https://en.wikipedia.org/wiki/Processor_register">registers</a> (a, b, c, and d) that start at 0 and can hold any <a href="https://en.wikipedia.org/wiki/Integer">integer</a>. However, it seems to make use of only a few <a href="https://en.wikipedia.org/wiki/Instruction_set">instructions</a>:

~cpy x y ~copies~ x (either an integer or the ~value~ of a register) into register y.~
~inc x ~increases~ the value of register x by one.~
~dec x ~decreases~ the value of register x by one.~
~jnz x y ~jumps~ to an instruction y away (positive means forward; negative means backward), but only if x is ~not zero~.~

The jnz instruction moves relative to itself: an offset of -1 would continue at the previous instruction, while an offset of 2 would ~skip over~ the next instruction.
For example:

#+begin_src text
cpy 41 a
inc a
inc a
dec a
jnz a 2
dec a

#+end_src

The above code would set register a to 41, increase its value by 2, decrease its value by 1, and then skip the last dec a (because a is not zero, so the jnz a 2 skips it), leaving register a at 42. When you move past the last instruction, the program halts.
After executing the assembunny code in your puzzle input, ~what value is left in register a?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-12 :var input_data=input-2016-12 :tangle /tmp/advent_of_code/aoc2016-12-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-12 :var input_data=input-2016-12 :tangle /tmp/advent_of_code/aoc2016-12-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-12 :var input_data=input-2016-12 :tangle /tmp/advent_of_code/aoc2016-12-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-12 :var input_data=input-2016-12 :tangle /tmp/advent_of_code/aoc2016-12-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-12 :var input_data=input-2016-12 :tangle /tmp/advent_of_code/aoc2016-12-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-12 :var input_data=input-2016-12 :tangle /tmp/advent_of_code/aoc2016-12-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-12 :var input_data=input-2016-12 :tangle /tmp/advent_of_code/aoc2016-12-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-12 :var input_data=input-2016-12 :tangle /tmp/advent_of_code/aoc2016-12-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-12 :var input_data=input-2016-12 :tangle /tmp/advent_of_code/aoc2016-12-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-12 :var input_data=input-2016-12 :tangle /tmp/advent_of_code/aoc2016-12-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-12 :var input_data=input-2016-12 :tangle /tmp/advent_of_code/aoc2016-12-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-12 :var input_data=input-2016-12 :tangle /tmp/advent_of_code/aoc2016-12-2.pl :results output 
#+end_src
*** Day 13: A Maze of Twisty Little Cubicles
**** Part 1
***** Description
Every location in this area is addressed by a pair of non-negative integers (x,y). Each such coordinate is either a wall or an open space. You can't move diagonally. The cube maze starts at 0,0 and seems to extend infinitely toward ~positive~ x and y; negative values are ~invalid~, as they represent a location outside the building. You are in a small waiting area at 1,1.
While it seems chaotic, a nearby morale-boosting poster explains, the layout is actually quite logical. You can determine whether a given x,y coordinate will be a wall or an open space using a simple system:

~Find x*x + 3*x + 2*x*y + y + y*y.~
~Add the office designer's favorite number (your puzzle input).~
~Find the <a href="https://en.wikipedia.org/wiki/Binary_number">binary representation</a> of that sum; count the ~number~ of <a href="https://en.wikipedia.org/wiki/Bit">bits</a> that are 1.

~If the number of bits that are 1 is ~even~, it's an ~open space~.~
~If the number of bits that are 1 is ~odd~, it's a ~wall~.~

~

For example, if the office designer's favorite number were 10, drawing walls as # and open spaces as ., the corner of the building containing 0,0 would look like this:

#+begin_src text
  0123456789
0 .#.####.##
1 ..#..#...#
2 #....##...
3 ###.#.###.
4 .##..#..#.
5 ..##....#.
6 #...##.###

#+end_src

Now, suppose you wanted to reach 7,4. The shortest route you could take is marked as O:

#+begin_src text
  0123456789
0 .#.####.##
1 .O#..#...#
2 #OOO.##...
3 ###O#.###.
4 .##OO#OO#.
5 ..##OOO.#.
6 #...##.###

#+end_src

Thus, reaching 7,4 would take a minimum of 11 steps (starting from your current location, 1,1).
What is the ~fewest number of steps required~ for you to reach 31,39?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-13 :var input_data=input-2016-13 :tangle /tmp/advent_of_code/aoc2016-13-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-13 :var input_data=input-2016-13 :tangle /tmp/advent_of_code/aoc2016-13-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-13 :var input_data=input-2016-13 :tangle /tmp/advent_of_code/aoc2016-13-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-13 :var input_data=input-2016-13 :tangle /tmp/advent_of_code/aoc2016-13-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-13 :var input_data=input-2016-13 :tangle /tmp/advent_of_code/aoc2016-13-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-13 :var input_data=input-2016-13 :tangle /tmp/advent_of_code/aoc2016-13-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-13 :var input_data=input-2016-13 :tangle /tmp/advent_of_code/aoc2016-13-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-13 :var input_data=input-2016-13 :tangle /tmp/advent_of_code/aoc2016-13-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-13 :var input_data=input-2016-13 :tangle /tmp/advent_of_code/aoc2016-13-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-13 :var input_data=input-2016-13 :tangle /tmp/advent_of_code/aoc2016-13-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-13 :var input_data=input-2016-13 :tangle /tmp/advent_of_code/aoc2016-13-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-13 :var input_data=input-2016-13 :tangle /tmp/advent_of_code/aoc2016-13-2.pl :results output 
#+end_src
*** Day 14: One-Time Pad
**** Part 1
***** Description
To generate keys, you first get a stream of random data by taking the <a href="https://en.wikipedia.org/wiki/MD5">MD5</a> of a pre-arranged <a href="https://en.wikipedia.org/wiki/Salt_(cryptography)">salt</a> (your puzzle input) and an increasing integer index (starting with 0, and represented in decimal); the resulting MD5 hash should be represented as a string of ~lowercase~ hexadecimal digits.
However, not all of these MD5 hashes are ~keys~, and you need 64 new keys for your one-time pad.  A hash is a key ~only if~:

~It contains ~three~ of the same character in a row, like 777. Only consider the first such triplet in a hash.~
~One of the next 1000 hashes in the stream contains that same character ~five~ times in a row, like 77777.~

Considering future hashes for five-of-a-kind sequences does not cause those hashes to be skipped; instead, regardless of whether the current hash is a key, always resume testing for keys starting with the very next hash.
For example, if the pre-arranged salt is abc:

~The first index which produces a triple is 18, because the MD5 hash of abc18 contains ...cc38887a5.... However, index 18 does not count as a key for your one-time pad, because none of the next thousand hashes (index 19 through index 1018) contain 88888.~
~The next index which produces a triple is 39; the hash of abc39 contains eee. It is also the first key: one of the next thousand hashes (the one at index 816) contains eeeee.~
~None of the next six triples are keys, but the one after that, at index 92, is: it contains 999 and index 200 contains 99999.~
~Eventually, index 22728 meets all of the criteria to generate the 64th key.~

So, using our example salt of abc, index 22728 produces the 64th key.
Given the actual salt in your puzzle input, ~what index~ produces your 64th one-time pad key?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-14 :var input_data=input-2016-14 :tangle /tmp/advent_of_code/aoc2016-14-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-14 :var input_data=input-2016-14 :tangle /tmp/advent_of_code/aoc2016-14-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-14 :var input_data=input-2016-14 :tangle /tmp/advent_of_code/aoc2016-14-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-14 :var input_data=input-2016-14 :tangle /tmp/advent_of_code/aoc2016-14-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-14 :var input_data=input-2016-14 :tangle /tmp/advent_of_code/aoc2016-14-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-14 :var input_data=input-2016-14 :tangle /tmp/advent_of_code/aoc2016-14-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-14 :var input_data=input-2016-14 :tangle /tmp/advent_of_code/aoc2016-14-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-14 :var input_data=input-2016-14 :tangle /tmp/advent_of_code/aoc2016-14-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-14 :var input_data=input-2016-14 :tangle /tmp/advent_of_code/aoc2016-14-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-14 :var input_data=input-2016-14 :tangle /tmp/advent_of_code/aoc2016-14-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-14 :var input_data=input-2016-14 :tangle /tmp/advent_of_code/aoc2016-14-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-14 :var input_data=input-2016-14 :tangle /tmp/advent_of_code/aoc2016-14-2.pl :results output 
#+end_src
*** Day 15: Timing is Everything
**** Part 1
***** Description
Part of the sculpture is even interactive! When a button is pressed, a capsule is dropped and tries to fall through slots in a set of rotating discs to finally go through a little hole at the bottom and come out of the sculpture. If any of the slots aren't aligned with the capsule as it passes, the capsule bounces off the disc and soars away. You feel compelled to <span title="These machines are everywhere in Japan, but on a MUCH smaller scale.">get one of those capsules</span>.
The discs pause their motion each second and come in different sizes; they seem to each have a fixed number of positions at which they stop.  You decide to call the position with the slot 0, and count up for each position it reaches next.
Furthermore, the discs are spaced out so that after you push the button, one second elapses before the first disc is reached, and one second elapses as the capsule passes from one disc to the one below it.  So, if you push the button at time=100, then the capsule reaches the top disc at time=101, the second disc at time=102, the third disc at time=103, and so on.
The button will only drop a capsule at an integer time - no fractional seconds allowed.
For example, at time=0, suppose you see the following arrangement:

#+begin_src text
Disc #1 has 5 positions; at time=0, it is at position 4.
Disc #2 has 2 positions; at time=0, it is at position 1.

#+end_src

If you press the button exactly at time=0, the capsule would start to fall; it would reach the first disc at time=1. Since the first disc was at position 4 at time=0, by time=1 it has ticked one position forward.  As a five-position disc, the next position is 0, and the capsule falls through the slot.
Then, at time=2, the capsule reaches the second disc. The second disc has ticked forward two positions at this point: it started at position 1, then continued to position 0, and finally ended up at position 1 again.  Because there's only a slot at position 0, the capsule bounces away.
If, however, you wait until time=5 to push the button, then when the capsule reaches each disc, the first disc will have ticked forward 5+1 = 6 times (to position 0), and the second disc will have ticked forward 5+2 = 7 times (also to position 0). In this case, the capsule would fall through the discs and come out of the machine.
However, your situation has more than two discs; you've noted their positions in your puzzle input. What is the ~first time you can press the button~ to get a capsule?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-15 :var input_data=input-2016-15 :tangle /tmp/advent_of_code/aoc2016-15-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-15 :var input_data=input-2016-15 :tangle /tmp/advent_of_code/aoc2016-15-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-15 :var input_data=input-2016-15 :tangle /tmp/advent_of_code/aoc2016-15-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-15 :var input_data=input-2016-15 :tangle /tmp/advent_of_code/aoc2016-15-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-15 :var input_data=input-2016-15 :tangle /tmp/advent_of_code/aoc2016-15-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-15 :var input_data=input-2016-15 :tangle /tmp/advent_of_code/aoc2016-15-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-15 :var input_data=input-2016-15 :tangle /tmp/advent_of_code/aoc2016-15-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-15 :var input_data=input-2016-15 :tangle /tmp/advent_of_code/aoc2016-15-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-15 :var input_data=input-2016-15 :tangle /tmp/advent_of_code/aoc2016-15-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-15 :var input_data=input-2016-15 :tangle /tmp/advent_of_code/aoc2016-15-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-15 :var input_data=input-2016-15 :tangle /tmp/advent_of_code/aoc2016-15-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-15 :var input_data=input-2016-15 :tangle /tmp/advent_of_code/aoc2016-15-2.pl :results output 
#+end_src
*** Day 16: Dragon Checksum
**** Part 1
***** Description
For the data to not be suspicious, it needs to have certain properties; purely random data will be detected as tampering. To generate appropriate random data, you'll need to use a modified <a href="https://en.wikipedia.org/wiki/Dragon_curve">dragon curve</a>.
Start with an appropriate initial state (your puzzle input). Then, so long as you don't have enough data yet to fill the disk, repeat the following steps:

~Call the data you have at this point "a".~
~Make a copy of "a"; call this copy "b".~
~Reverse the order of the characters in "b".~
~In "b", replace all instances of 0 with 1 and all 1s with 0.~
~The resulting data is "a", then a single 0, then "b".~

For example, after a single step of this process,

~1 becomes 100.~
~0 becomes 001.~
~11111 becomes 11111000000.~
~111100001010 becomes 1111000010100101011110000.~

Repeat these steps until you have enough data to fill the desired disk.
Once the data has been generated, you also need to create a checksum of that data. Calculate the checksum ~only~ for the data that fits on the disk, even if you generated more data than that in the previous step.
The checksum for some given data is created by considering each non-overlapping ~pair~ of characters in the input data.  If the two characters match (00 or 11), the next checksum character is a 1.  If the characters do not match (01 or 10), the next checksum character is a 0. This should produce a new string which is exactly half as long as the original. If the length of the checksum is ~even~, repeat the process until you end up with a checksum with an ~odd~ length.
For example, suppose we want to fill a disk of length 12, and when we finally generate a string of at least length 12, the first 12 characters are 110010110100. To generate its checksum:

~Consider each pair: 11, 00, 10, 11, 01, 00.~
~These are same, same, different, same, different, same, producing 110101.~
~The resulting string has length 6, which is ~even~, so we repeat the process.~
~The pairs are 11 (same), 01 (different), 01 (different).~
~This produces the checksum 100, which has an ~odd~ length, so we stop.~

Therefore, the checksum for 110010110100 is 100.
Combining all of these steps together, suppose you want to fill a disk of length 20 using an initial state of 10000:

~Because 10000 is too short, we first use the modified dragon curve to make it longer.~
~After one round, it becomes 10000011110 (11 characters), still too short.~
~After two rounds, it becomes 10000011110010000111110 (23 characters), which is enough.~
~Since we only need 20, but we have 23, we get rid of all but the first 20 characters: 10000011110010000111.~
~Next, we start calculating the checksum; after one round, we have 0111110101, which 10 characters long (~even~), so we continue.~
~After two rounds, we have 01100, which is 5 characters long (~odd~), so we are done.~

In this example, the correct checksum would therefore be 01100.
The first disk you have to fill has length 272. Using the initial state in your puzzle input, ~what is the correct checksum~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-16 :var input_data=input-2016-16 :tangle /tmp/advent_of_code/aoc2016-16-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-16 :var input_data=input-2016-16 :tangle /tmp/advent_of_code/aoc2016-16-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-16 :var input_data=input-2016-16 :tangle /tmp/advent_of_code/aoc2016-16-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-16 :var input_data=input-2016-16 :tangle /tmp/advent_of_code/aoc2016-16-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-16 :var input_data=input-2016-16 :tangle /tmp/advent_of_code/aoc2016-16-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-16 :var input_data=input-2016-16 :tangle /tmp/advent_of_code/aoc2016-16-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-16 :var input_data=input-2016-16 :tangle /tmp/advent_of_code/aoc2016-16-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-16 :var input_data=input-2016-16 :tangle /tmp/advent_of_code/aoc2016-16-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-16 :var input_data=input-2016-16 :tangle /tmp/advent_of_code/aoc2016-16-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-16 :var input_data=input-2016-16 :tangle /tmp/advent_of_code/aoc2016-16-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-16 :var input_data=input-2016-16 :tangle /tmp/advent_of_code/aoc2016-16-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-16 :var input_data=input-2016-16 :tangle /tmp/advent_of_code/aoc2016-16-2.pl :results output 
#+end_src
*** Day 17: Two Steps Forward
**** Part 1
***** Description

#+begin_src text
#########
#S| | | #
#-#-#-#-#
# | | | #
#-#-#-#-#
# | | | #
#-#-#-#-#
# | | |  
####### V

#+end_src

Fixed walls are marked with #, and doors are marked with - or |.
The doors in your ~current room~ are either open or closed (and locked) based on the hexadecimal <a href="https://en.wikipedia.org/wiki/MD5">MD5</a> hash of a passcode (your puzzle input) followed by a sequence of uppercase characters representing the ~path you have taken so far~ (U for up, D for down, L for left, and R for right).
Only the first four characters of the hash are used; they represent, respectively, the doors ~up, down, left, and right~ from your current position. Any b, c, d, e, or f means that the corresponding door is ~open~; any other character (any number or a) means that the corresponding door is ~closed and locked~.
To access the vault, all you need to do is reach the bottom-right room; reaching this room opens the vault and all doors in the maze.
For example, suppose the passcode is hijkl. Initially, you have taken no steps, and so your path is empty: you simply find the MD5 hash of hijkl alone. The first four characters of this hash are ced9, which indicate that up is open (c), down is open (e), left is open (d), and right is closed and locked (9). Because you start in the top-left corner, there are no "up" or "left" doors to be open, so your only choice is ~down~.
Next, having gone only one step (down, or D), you find the hash of hijkl~D~. This produces f2bc, which indicates that you can go back up, left (but that's a wall), or right. Going right means hashing hijkl~DR~ to get 5745 - all doors closed and locked. However, going ~up~ instead is worthwhile: even though it returns you to the room you started in, your path would then be DU, opening a ~different set of doors~.
After going DU (and then hashing hijkl~DU~ to get 528e), only the right door is open; after going DUR, all doors lock. (Fortunately, your actual passcode is <span title="It took four days to rescue the engineer that tried this.">not hijkl</span>).
Passcodes actually used by Easter Bunny Vault Security do allow access to the vault if you know the right path.  For example:

~If your passcode were ihgpwlah, the shortest path would be DDRRRD.~
~With kglvqrro, the shortest path would be DDUDRLRRUDRD.~
~With ulqzkmiv, the shortest would be DRURDRUDDLLDLUURRDULRLDUUDDDRR.~

Given your vault's passcode, ~what is the shortest path~ (the actual path, not just the length) to reach the vault?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-17 :var input_data=input-2016-17 :tangle /tmp/advent_of_code/aoc2016-17-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-17 :var input_data=input-2016-17 :tangle /tmp/advent_of_code/aoc2016-17-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-17 :var input_data=input-2016-17 :tangle /tmp/advent_of_code/aoc2016-17-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-17 :var input_data=input-2016-17 :tangle /tmp/advent_of_code/aoc2016-17-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-17 :var input_data=input-2016-17 :tangle /tmp/advent_of_code/aoc2016-17-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-17 :var input_data=input-2016-17 :tangle /tmp/advent_of_code/aoc2016-17-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-17 :var input_data=input-2016-17 :tangle /tmp/advent_of_code/aoc2016-17-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-17 :var input_data=input-2016-17 :tangle /tmp/advent_of_code/aoc2016-17-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-17 :var input_data=input-2016-17 :tangle /tmp/advent_of_code/aoc2016-17-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-17 :var input_data=input-2016-17 :tangle /tmp/advent_of_code/aoc2016-17-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-17 :var input_data=input-2016-17 :tangle /tmp/advent_of_code/aoc2016-17-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-17 :var input_data=input-2016-17 :tangle /tmp/advent_of_code/aoc2016-17-2.pl :results output 
#+end_src
*** Day 18: Like a Rogue
**** Part 1
***** Description
Upon closer examination, the traps and safe tiles in this room seem to follow a pattern. The tiles are arranged into rows that are all the same width; you take note of the safe tiles (.) and traps (^) in the first row (your puzzle input).
The type of tile (trapped or safe) in each row is based on the types of the tiles in the same position, and to either side of that position, in the previous row. (If either side is off either end of the row, it counts as "safe" because there isn't a trap embedded in the wall.)
For example, suppose you know the first row (with tiles marked by letters) and want to determine the next row (with tiles marked by numbers):

#+begin_src text
ABCDE
12345

#+end_src

The type of tile 2 is based on the types of tiles A, B, and C; the type of tile 5 is based on tiles D, E, and an imaginary "safe" tile. Let's call these three tiles from the previous row the ~left~, ~center~, and ~right~ tiles, respectively. Then, a new tile is a ~trap~ only in one of the following situations:

~Its ~left~ and ~center~ tiles are traps, but its ~right~ tile is not.~
~Its ~center~ and ~right~ tiles are traps, but its ~left~ tile is not.~
~Only its ~left~ tile is a trap.~
~Only its ~right~ tile is a trap.~

In any other situation, the new tile is safe.
Then, starting with the row ..^^., you can determine the next row by applying those rules to each new tile:

~The leftmost character on the next row considers the left (nonexistent, so we assume "safe"), center (the first ., which means "safe"), and right (the second ., also "safe") tiles on the previous row. Because all of the trap rules require a trap in at least one of the previous three tiles, the first tile on this new row is also safe, ..~
~The second character on the next row considers its left (.), center (.), and right (^) tiles from the previous row. This matches the fourth rule: only the right tile is a trap. Therefore, the next tile in this new row is a trap, ^.~
~The third character considers .^^, which matches the second trap rule: its center and right tiles are traps, but its left tile is not. Therefore, this tile is also a trap, ^.~
~The last two characters in this new row match the first and third rules, respectively, and so they are both also traps, ^.~

After these steps, we now know the next row of tiles in the room: .^^^^. Then, we continue on to the next row, using the same rules, and get ^^..^. After determining two new rows, our map looks like this:

#+begin_src text
..^^.
.^^^^
^^..^

#+end_src

Here's a larger example with ten tiles per row and ten rows:

#+begin_src text
.^^.^.^^^^
^^^...^..^
^.^^.^.^^.
..^^...^^^
.^^^^.^^.^
^^..^.^^..
^^^^..^^^.
^..^^^^.^^
.^^^..^.^^
^^.^^^..^^

#+end_src

In ten rows, this larger example has 38 safe tiles.
Starting with the map in your puzzle input, in a total of 40 rows (including the starting row), ~how many safe tiles~ are there?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-18 :var input_data=input-2016-18 :tangle /tmp/advent_of_code/aoc2016-18-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-18 :var input_data=input-2016-18 :tangle /tmp/advent_of_code/aoc2016-18-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-18 :var input_data=input-2016-18 :tangle /tmp/advent_of_code/aoc2016-18-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-18 :var input_data=input-2016-18 :tangle /tmp/advent_of_code/aoc2016-18-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-18 :var input_data=input-2016-18 :tangle /tmp/advent_of_code/aoc2016-18-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-18 :var input_data=input-2016-18 :tangle /tmp/advent_of_code/aoc2016-18-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-18 :var input_data=input-2016-18 :tangle /tmp/advent_of_code/aoc2016-18-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-18 :var input_data=input-2016-18 :tangle /tmp/advent_of_code/aoc2016-18-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-18 :var input_data=input-2016-18 :tangle /tmp/advent_of_code/aoc2016-18-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-18 :var input_data=input-2016-18 :tangle /tmp/advent_of_code/aoc2016-18-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-18 :var input_data=input-2016-18 :tangle /tmp/advent_of_code/aoc2016-18-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-18 :var input_data=input-2016-18 :tangle /tmp/advent_of_code/aoc2016-18-2.pl :results output 
#+end_src
*** Day 19: An Elephant Named Joseph
**** Part 1
***** Description
Each Elf brings a present. They all sit in a circle, numbered starting with position 1. Then, starting with the first Elf, they take turns stealing all the presents from the Elf to their left.  An Elf with no presents is removed from the circle and does not take turns.
For example, with five Elves (numbered 1 to 5):

#+begin_src text
  1
5   2
 4 3

#+end_src


~Elf 1 takes Elf 2's present.~
~Elf 2 has no presents and is skipped.~
~Elf 3 takes Elf 4's present.~
~Elf 4 has no presents and is also skipped.~
~Elf 5 takes Elf 1's two presents.~
~Neither Elf 1 nor Elf 2 have any presents, so both are skipped.~
~Elf 3 takes Elf 5's three presents.~

So, with ~five~ Elves, the Elf that sits starting in position 3 gets all the presents.
With the number of Elves given in your puzzle input, ~which Elf gets all the presents?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-19 :var input_data=input-2016-19 :tangle /tmp/advent_of_code/aoc2016-19-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-19 :var input_data=input-2016-19 :tangle /tmp/advent_of_code/aoc2016-19-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-19 :var input_data=input-2016-19 :tangle /tmp/advent_of_code/aoc2016-19-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-19 :var input_data=input-2016-19 :tangle /tmp/advent_of_code/aoc2016-19-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-19 :var input_data=input-2016-19 :tangle /tmp/advent_of_code/aoc2016-19-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-19 :var input_data=input-2016-19 :tangle /tmp/advent_of_code/aoc2016-19-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-19 :var input_data=input-2016-19 :tangle /tmp/advent_of_code/aoc2016-19-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-19 :var input_data=input-2016-19 :tangle /tmp/advent_of_code/aoc2016-19-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-19 :var input_data=input-2016-19 :tangle /tmp/advent_of_code/aoc2016-19-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-19 :var input_data=input-2016-19 :tangle /tmp/advent_of_code/aoc2016-19-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-19 :var input_data=input-2016-19 :tangle /tmp/advent_of_code/aoc2016-19-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-19 :var input_data=input-2016-19 :tangle /tmp/advent_of_code/aoc2016-19-2.pl :results output 
#+end_src
*** Day 20: Firewall Rules
**** Part 1
***** Description
You've retrieved the list of blocked IPs from the firewall, but the list seems to be messy and poorly maintained, and it's not clear which IPs are allowed. Also, rather than being written in <a href="https://en.wikipedia.org/wiki/Dot-decimal_notation">dot-decimal</a> notation, they are written as plain <a href="https://en.wikipedia.org/wiki/32-bit">32-bit integers</a>, which can have any value from 0 through 4294967295, inclusive.
For example, suppose only the values 0 through 9 were valid, and that you retrieved the following blacklist:

#+begin_src text
5-8
0-2
4-7

#+end_src

The blacklist specifies ranges of IPs (inclusive of both the start and end value) that are ~not~ allowed. Then, the only IPs that this firewall allows are 3 and 9, since those are the only numbers not in any range.
Given the list of blocked IPs you retrieved from the firewall (your puzzle input), ~what is the lowest-valued IP~ that is not blocked?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-20 :var input_data=input-2016-20 :tangle /tmp/advent_of_code/aoc2016-20-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-20 :var input_data=input-2016-20 :tangle /tmp/advent_of_code/aoc2016-20-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-20 :var input_data=input-2016-20 :tangle /tmp/advent_of_code/aoc2016-20-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-20 :var input_data=input-2016-20 :tangle /tmp/advent_of_code/aoc2016-20-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-20 :var input_data=input-2016-20 :tangle /tmp/advent_of_code/aoc2016-20-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-20 :var input_data=input-2016-20 :tangle /tmp/advent_of_code/aoc2016-20-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-20 :var input_data=input-2016-20 :tangle /tmp/advent_of_code/aoc2016-20-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-20 :var input_data=input-2016-20 :tangle /tmp/advent_of_code/aoc2016-20-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-20 :var input_data=input-2016-20 :tangle /tmp/advent_of_code/aoc2016-20-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-20 :var input_data=input-2016-20 :tangle /tmp/advent_of_code/aoc2016-20-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-20 :var input_data=input-2016-20 :tangle /tmp/advent_of_code/aoc2016-20-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-20 :var input_data=input-2016-20 :tangle /tmp/advent_of_code/aoc2016-20-2.pl :results output 
#+end_src
*** Day 21: Scrambled Letters and Hash
**** Part 1
***** Description
The scrambling function is a series of operations (the exact list is provided in your puzzle input). Starting with the password to be scrambled, apply each operation in succession to the string. The individual operations behave as follows:

~swap position X with position Y means that the letters at indexes X and Y (counting from 0) should be ~swapped~.~
~swap letter X with letter Y means that the letters X and Y should be ~swapped~ (regardless of where they appear in the string).~
~rotate left/right X steps means that the whole string should be ~rotated~; for example, one right rotation would turn abcd into dabc.~
~rotate based on position of letter X means that the whole string should be ~rotated to the right~ based on the ~index~ of letter X (counting from 0) as determined ~before~ this instruction does any rotations.  Once the index is determined, rotate the string to the right one time, plus a number of times equal to that index, plus one additional time if the index was at least 4.~
~reverse positions X through Y means that the span of letters at indexes X through Y (including the letters at X and Y) should be ~reversed in order~.~
~move position X to position Y means that the letter which is at index X should be ~removed~ from the string, then ~inserted~ such that it ends up at index Y.~

For example, suppose you start with abcde and perform the following operations:

~swap position 4 with position 0 swaps the first and last letters, producing the input for the next step, ebcda.~
~swap letter d with letter b swaps the positions of d and b: edcba.~
~reverse positions 0 through 4 causes the entire string to be reversed, producing abcde.~
~rotate left 1 step shifts all letters left one position, causing the first letter to wrap to the end of the string: bcdea.~
~move position 1 to position 4 removes the letter at position 1 (c), then inserts it at position 4 (the end of the string): bdeac.~
~move position 3 to position 0 removes the letter at position 3 (a), then inserts it at position 0 (the front of the string): abdec.~
~rotate based on position of letter b finds the index of letter b (1), then rotates the string right once plus a number of times equal to that index (2): ecabd.~
~rotate based on position of letter d finds the index of letter d (4), then rotates the string right once, plus a number of times equal to that index, plus an additional time because the index was at least 4, for a total of 6 right rotations: decab.~

After these steps, the resulting scrambled password is decab.
Now, you just need to generate a new scrambled password and you can access the system. Given the list of scrambling operations in your puzzle input, ~what is the result of scrambling abcdefgh~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-21 :var input_data=input-2016-21 :tangle /tmp/advent_of_code/aoc2016-21-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-21 :var input_data=input-2016-21 :tangle /tmp/advent_of_code/aoc2016-21-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-21 :var input_data=input-2016-21 :tangle /tmp/advent_of_code/aoc2016-21-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-21 :var input_data=input-2016-21 :tangle /tmp/advent_of_code/aoc2016-21-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-21 :var input_data=input-2016-21 :tangle /tmp/advent_of_code/aoc2016-21-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-21 :var input_data=input-2016-21 :tangle /tmp/advent_of_code/aoc2016-21-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-21 :var input_data=input-2016-21 :tangle /tmp/advent_of_code/aoc2016-21-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-21 :var input_data=input-2016-21 :tangle /tmp/advent_of_code/aoc2016-21-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-21 :var input_data=input-2016-21 :tangle /tmp/advent_of_code/aoc2016-21-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-21 :var input_data=input-2016-21 :tangle /tmp/advent_of_code/aoc2016-21-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-21 :var input_data=input-2016-21 :tangle /tmp/advent_of_code/aoc2016-21-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-21 :var input_data=input-2016-21 :tangle /tmp/advent_of_code/aoc2016-21-2.pl :results output 
#+end_src
*** Day 22: Grid Computing
**** Part 1
***** Description
You can directly access data ~only~ on node /dev/grid/node-x0-y0, but you can perform some limited actions on the other nodes:

~You can get the disk usage of all nodes (via <a href="https://en.wikipedia.org/wiki/Df_(Unix)#Example">df</a>). The result of doing this is in your puzzle input.~
~You can instruct a node to <span title="You suspect someone misunderstood the x86 MOV instruction.">~move~</span> (not copy) ~all~ of its data to an adjacent node (if the destination node has enough space to receive the data). The sending node is left empty after this operation.~

Nodes are named by their position: the node named node-x10-y10 is adjacent to nodes node-x9-y10, node-x11-y10, node-x10-y9, and node-x10-y11.
Before you begin, you need to understand the arrangement of data on these nodes. Even though you can only move data between directly connected nodes, you're going to need to rearrange a lot of the data to get access to the data you need.  Therefore, you need to work out how you might be able to shift data around.
To do this, you'd like to count the number of ~viable pairs~ of nodes.  A viable pair is any two nodes (A,B), ~regardless of whether they are directly connected~, such that:

~Node A is ~not~ empty (its Used is not zero).~
~Nodes A and B are ~not the same~ node.~
~The data on node A (its Used) ~would fit~ on node B (its Avail).~

~How many viable pairs~ of nodes are there?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-22 :var input_data=input-2016-22 :tangle /tmp/advent_of_code/aoc2016-22-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-22 :var input_data=input-2016-22 :tangle /tmp/advent_of_code/aoc2016-22-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-22 :var input_data=input-2016-22 :tangle /tmp/advent_of_code/aoc2016-22-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-22 :var input_data=input-2016-22 :tangle /tmp/advent_of_code/aoc2016-22-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-22 :var input_data=input-2016-22 :tangle /tmp/advent_of_code/aoc2016-22-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-22 :var input_data=input-2016-22 :tangle /tmp/advent_of_code/aoc2016-22-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-22 :var input_data=input-2016-22 :tangle /tmp/advent_of_code/aoc2016-22-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-22 :var input_data=input-2016-22 :tangle /tmp/advent_of_code/aoc2016-22-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-22 :var input_data=input-2016-22 :tangle /tmp/advent_of_code/aoc2016-22-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-22 :var input_data=input-2016-22 :tangle /tmp/advent_of_code/aoc2016-22-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-22 :var input_data=input-2016-22 :tangle /tmp/advent_of_code/aoc2016-22-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-22 :var input_data=input-2016-22 :tangle /tmp/advent_of_code/aoc2016-22-2.pl :results output 
#+end_src
*** Day 23: Safe Cracking
**** Part 1
***** Description
The safe has a digital screen and keypad for code entry. A sticky note attached to the safe has a password hint on it: "eggs". The painting is of a large rabbit coloring some eggs. You see 7.
When you go to type the code, though, nothing appears on the display; instead, the keypad comes apart in your hands, apparently having been smashed. Behind it is some kind of socket - one that matches a connector in your <a href="11">prototype computer</a>! You pull apart the smashed keypad and extract the logic circuit, plug it into your computer, and plug your computer into the safe.
Now, you just need to figure out what output the keypad would have sent to the safe. You extract the <a href="12">assembunny code</a> from the logic chip (your puzzle input).
The code looks like it uses ~almost~ the same architecture and instruction set that the <a href="12">monorail computer</a> used! You should be able to ~use the same assembunny interpreter~ for this as you did there, but with one new instruction:
tgl x ~toggles~ the instruction x away (pointing at instructions like jnz does: positive means forward; negative means backward):

~For ~one-argument~ instructions, inc becomes dec, and all other one-argument instructions become inc.~
~For ~two-argument~ instructions, jnz becomes cpy, and all other two-instructions become jnz.~
~The arguments of a toggled instruction are ~not affected~.~
~If an attempt is made to toggle an instruction outside the program, ~nothing happens~.~
~If toggling produces an ~invalid instruction~ (like cpy 1 2) and an attempt is later made to execute that instruction, ~skip it instead~.~
~If tgl toggles ~itself~ (for example, if a is 0, tgl a would target itself and become inc a), the resulting instruction is not executed until the next time it is reached.~

For example, given this program:

#+begin_src text
cpy 2 a
tgl a
tgl a
tgl a
cpy 1 a
dec a
dec a

#+end_src


~cpy 2 a initializes register a to 2.~
~The first tgl a toggles an instruction a (2) away from it, which changes the third tgl a into inc a.~
~The second tgl a also modifies an instruction 2 away from it, which changes the cpy 1 a into jnz 1 a.~
~The fourth line, which is now inc a, increments a to 3.~
~Finally, the fifth line, which is now jnz 1 a, jumps a (3) instructions ahead, skipping the dec a instructions.~

In this example, the final value in register a is 3.
The rest of the electronics seem to place the keypad entry (the number of eggs, 7) in register a, run the code, and then send the value left in register a to the safe.
~What value~ should be sent to the safe?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-23 :var input_data=input-2016-23 :tangle /tmp/advent_of_code/aoc2016-23-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-23 :var input_data=input-2016-23 :tangle /tmp/advent_of_code/aoc2016-23-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-23 :var input_data=input-2016-23 :tangle /tmp/advent_of_code/aoc2016-23-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-23 :var input_data=input-2016-23 :tangle /tmp/advent_of_code/aoc2016-23-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-23 :var input_data=input-2016-23 :tangle /tmp/advent_of_code/aoc2016-23-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-23 :var input_data=input-2016-23 :tangle /tmp/advent_of_code/aoc2016-23-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-23 :var input_data=input-2016-23 :tangle /tmp/advent_of_code/aoc2016-23-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-23 :var input_data=input-2016-23 :tangle /tmp/advent_of_code/aoc2016-23-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-23 :var input_data=input-2016-23 :tangle /tmp/advent_of_code/aoc2016-23-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-23 :var input_data=input-2016-23 :tangle /tmp/advent_of_code/aoc2016-23-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-23 :var input_data=input-2016-23 :tangle /tmp/advent_of_code/aoc2016-23-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-23 :var input_data=input-2016-23 :tangle /tmp/advent_of_code/aoc2016-23-2.pl :results output 
#+end_src
*** Day 24: Air Duct Spelunking
**** Part 1
***** Description
The robot that cleans the air ducts, however, ~can~.
It's not a very fast <span title="The Brave Little Air Duct Cleaning Robot That Could">little robot</span>, but you reconfigure it to be able to interface with some of the exposed wires that have been routed through the <a href="https://en.wikipedia.org/wiki/HVAC">HVAC</a> system. If you can direct it to each of those locations, you should be able to bypass the security controls.
You extract the duct layout for this area from some blueprints you acquired and create a map with the relevant locations marked (your puzzle input). 0 is your current location, from which the cleaning robot embarks; the other numbers are (in ~no particular order~) the locations the robot needs to visit at least once each. Walls are marked as #, and open passages are marked as .. Numbers behave like open passages.
For example, suppose you have a map like the following:

#+begin_src text
###########
#0.1.....2#
#.#######.#
#4.......3#
###########

#+end_src

To reach all of the points of interest as quickly as possible, you would have the robot take the following path:

~0 to 4 (2 steps)~
~4 to 1 (4 steps; it can't move diagonally)~
~1 to 2 (6 steps)~
~2 to 3 (2 steps)~

Since the robot isn't very fast, you need to find it the ~shortest route~. This path is the fewest steps (in the above example, a total of 14) required to start at 0 and then visit every other location at least once.
Given your actual map, and starting from location 0, what is the ~fewest number of steps~ required to visit every non-0 number marked on the map at least once?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-24 :var input_data=input-2016-24 :tangle /tmp/advent_of_code/aoc2016-24-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-24 :var input_data=input-2016-24 :tangle /tmp/advent_of_code/aoc2016-24-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-24 :var input_data=input-2016-24 :tangle /tmp/advent_of_code/aoc2016-24-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-24 :var input_data=input-2016-24 :tangle /tmp/advent_of_code/aoc2016-24-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-24 :var input_data=input-2016-24 :tangle /tmp/advent_of_code/aoc2016-24-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-24 :var input_data=input-2016-24 :tangle /tmp/advent_of_code/aoc2016-24-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-24 :var input_data=input-2016-24 :tangle /tmp/advent_of_code/aoc2016-24-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-24 :var input_data=input-2016-24 :tangle /tmp/advent_of_code/aoc2016-24-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-24 :var input_data=input-2016-24 :tangle /tmp/advent_of_code/aoc2016-24-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-24 :var input_data=input-2016-24 :tangle /tmp/advent_of_code/aoc2016-24-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-24 :var input_data=input-2016-24 :tangle /tmp/advent_of_code/aoc2016-24-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-24 :var input_data=input-2016-24 :tangle /tmp/advent_of_code/aoc2016-24-2.pl :results output 
#+end_src
*** Day 25: Clock Signal
**** Part 1
***** Description
There's not much time now - it's already Christmas, but you're nowhere near the North Pole, much too far to deliver these stars to the sleigh in time.
However, maybe the ~huge antenna~ up here can offer a solution. After all, the sleigh doesn't need the stars, exactly; it needs the timing data they provide, and you happen to have a massive signal generator right here.
You connect the stars you have to your prototype computer, connect that to the antenna, and begin the transmission.
<span title="Then again, if something ever works on the first try, you should be *very* suspicious.">Nothing happens.</span>
You call the service number printed on the side of the antenna and quickly explain the situation. "I'm not sure what kind of equipment you have connected over there," he says, "but you need a clock signal." You try to explain that this is a signal for a clock.
"No, no, a <a href="https://en.wikipedia.org/wiki/Clock_signal">clock signal</a> - timing information so the antenna computer knows how to read the data you're sending it. An endless, alternating pattern of 0, 1, 0, 1, 0, 1, 0, 1, 0, 1...." He trails off.
You ask if the antenna can handle a clock signal at the frequency you would need to use for the data from the stars. "There's ~no way~ it can! The only antenna we've installed capable of ~that~ is on top of a top-secret Easter Bunny installation, and you're ~definitely~ not-" You hang up the phone.
You've extracted the antenna's clock signal generation <a href="12">assembunny</a> code (your puzzle input); it looks mostly compatible with code you worked on <a href="23">just recently</a>.
This antenna code, being a signal generator, uses one extra instruction:

~out x ~transmits~ x (either an integer or the ~value~ of a register) as the next value for the clock signal.~

The code takes a value (via register a) that describes the signal to generate, but you're not sure how it's used. You'll have to find the input to produce the right signal through experimentation.
~What is the lowest positive integer~ that can be used to initialize register a and cause the code to output a clock signal of 0, 1, 0, 1... repeating forever?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-25 :var input_data=input-2016-25 :tangle /tmp/advent_of_code/aoc2016-25-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-25 :var input_data=input-2016-25 :tangle /tmp/advent_of_code/aoc2016-25-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-25 :var input_data=input-2016-25 :tangle /tmp/advent_of_code/aoc2016-25-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-25 :var input_data=input-2016-25 :tangle /tmp/advent_of_code/aoc2016-25-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-25 :var input_data=input-2016-25 :tangle /tmp/advent_of_code/aoc2016-25-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-25 :var input_data=input-2016-25 :tangle /tmp/advent_of_code/aoc2016-25-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2016-25 :var input_data=input-2016-25 :tangle /tmp/advent_of_code/aoc2016-25-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2016-25 :var input_data=input-2016-25 :tangle /tmp/advent_of_code/aoc2016-25-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2016-25 :var input_data=input-2016-25 :tangle /tmp/advent_of_code/aoc2016-25-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2016-25 :var input_data=input-2016-25 :tangle /tmp/advent_of_code/aoc2016-25-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2016-25 :var input_data=input-2016-25 :tangle /tmp/advent_of_code/aoc2016-25-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2016-25 :var input_data=input-2016-25 :tangle /tmp/advent_of_code/aoc2016-25-2.pl :results output 
#+end_src
** 2017
*** Day 01: Inverse Captcha
**** Part 1
***** Description
When your eyes can focus again, everything seems a lot more pixelated than before. She must have sent you inside the computer! You check the system clock: ~25 milliseconds~ until midnight. With that much time, you should be able to collect all <em class="star">fifty stars~ by December 25th.
Collect stars by solving puzzles.  Two puzzles will be made available on each <s style="text-decoration-color:#fff;">day</s> millisecond in the Advent calendar; the second puzzle is unlocked when you complete the first.  Each puzzle grants <em class="star">one star~. Good luck!
You're standing in a room with "digitization quarantine" written in LEDs along one wall. The only door is locked, but it includes a small interface. "Restricted Area - Strictly No Digitized Users Allowed."
It goes on to explain that you may only leave by solving a <a href="https://en.wikipedia.org/wiki/CAPTCHA">captcha</a> to prove you're ~not~ a human. Apparently, you only get one millisecond to solve the captcha: too fast for a normal human, but it feels like hours to you.
The captcha requires you to review a sequence of digits (your puzzle input) and find the ~sum~ of all digits that match the ~next~ digit in the list. The list is circular, so the digit after the last digit is the ~first~ digit in the list.
For example:

~1122 produces a sum of 3 (1 + 2) because the first digit (1) matches the second digit and the third digit (2) matches the fourth digit.~
~1111 produces 4 because each digit (all 1) matches the next.~
~1234 produces 0 because no digit matches the next.~
~91212129 produces 9 because the only digit that matches the next one is the last digit, 9.~

~What is the solution~ to your captcha?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-01 :var input_data=input-2017-01 :tangle /tmp/advent_of_code/aoc2017-01-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-01 :var input_data=input-2017-01 :tangle /tmp/advent_of_code/aoc2017-01-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-01 :var input_data=input-2017-01 :tangle /tmp/advent_of_code/aoc2017-01-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-01 :var input_data=input-2017-01 :tangle /tmp/advent_of_code/aoc2017-01-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-01 :var input_data=input-2017-01 :tangle /tmp/advent_of_code/aoc2017-01-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-01 :var input_data=input-2017-01 :tangle /tmp/advent_of_code/aoc2017-01-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-01 :var input_data=input-2017-01 :tangle /tmp/advent_of_code/aoc2017-01-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-01 :var input_data=input-2017-01 :tangle /tmp/advent_of_code/aoc2017-01-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-01 :var input_data=input-2017-01 :tangle /tmp/advent_of_code/aoc2017-01-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-01 :var input_data=input-2017-01 :tangle /tmp/advent_of_code/aoc2017-01-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-01 :var input_data=input-2017-01 :tangle /tmp/advent_of_code/aoc2017-01-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-01 :var input_data=input-2017-01 :tangle /tmp/advent_of_code/aoc2017-01-2.pl :results output 
#+end_src
*** Day 02: Corruption Checksum
**** Part 1
***** Description
The spreadsheet consists of rows of apparently-random numbers. To make sure the recovery process is on the right track, they need you to calculate the spreadsheet's ~checksum~. For each row, determine the difference between the largest value and the smallest value; the checksum is the sum of all of these differences.
For example, given the following spreadsheet:

#+begin_src text
5 1 9 5
7 5 3
2 4 6 8
#+end_src


~The first row's largest and smallest values are 9 and 1, and their difference is 8.~
~The second row's largest and smallest values are 7 and 3, and their difference is 4.~
~The third row's difference is 6.~

In this example, the spreadsheet's checksum would be 8 + 4 + 6 = 18.
~What is the checksum~ for the spreadsheet in your puzzle input?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-02 :var input_data=input-2017-02 :tangle /tmp/advent_of_code/aoc2017-02-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-02 :var input_data=input-2017-02 :tangle /tmp/advent_of_code/aoc2017-02-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-02 :var input_data=input-2017-02 :tangle /tmp/advent_of_code/aoc2017-02-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-02 :var input_data=input-2017-02 :tangle /tmp/advent_of_code/aoc2017-02-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-02 :var input_data=input-2017-02 :tangle /tmp/advent_of_code/aoc2017-02-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-02 :var input_data=input-2017-02 :tangle /tmp/advent_of_code/aoc2017-02-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-02 :var input_data=input-2017-02 :tangle /tmp/advent_of_code/aoc2017-02-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-02 :var input_data=input-2017-02 :tangle /tmp/advent_of_code/aoc2017-02-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-02 :var input_data=input-2017-02 :tangle /tmp/advent_of_code/aoc2017-02-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-02 :var input_data=input-2017-02 :tangle /tmp/advent_of_code/aoc2017-02-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-02 :var input_data=input-2017-02 :tangle /tmp/advent_of_code/aoc2017-02-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-02 :var input_data=input-2017-02 :tangle /tmp/advent_of_code/aoc2017-02-2.pl :results output 
#+end_src
*** Day 03: Spiral Memory
**** Part 1
***** Description
Each square on the grid is allocated in a spiral pattern starting at a location marked 1 and then counting up while spiraling outward. For example, the first few squares are allocated like this:

#+begin_src text
17  16  15  14  13
18   5   4   3  12
19   6   1   2  11
20   7   8   9  10
21  22  23---&gt; ...

#+end_src

While this is very space-efficient (no squares are skipped), requested data must be carried back to square 1 (the location of the only access port for this memory system) by programs that can only move up, down, left, or right. They always take the shortest path: the <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan Distance</a> between the location of the data and square 1.
For example:

~Data from square 1 is carried 0 steps, since it's at the access port.~
~Data from square 12 is carried 3 steps, such as: down, left, left.~
~Data from square 23 is carried only 2 steps: up twice.~
~Data from square 1024 must be carried 31 steps.~

~How many steps~ are required to carry the data from the square identified in your puzzle input all the way to the access port?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-03 :var input_data=input-2017-03 :tangle /tmp/advent_of_code/aoc2017-03-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-03 :var input_data=input-2017-03 :tangle /tmp/advent_of_code/aoc2017-03-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-03 :var input_data=input-2017-03 :tangle /tmp/advent_of_code/aoc2017-03-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-03 :var input_data=input-2017-03 :tangle /tmp/advent_of_code/aoc2017-03-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-03 :var input_data=input-2017-03 :tangle /tmp/advent_of_code/aoc2017-03-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-03 :var input_data=input-2017-03 :tangle /tmp/advent_of_code/aoc2017-03-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-03 :var input_data=input-2017-03 :tangle /tmp/advent_of_code/aoc2017-03-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-03 :var input_data=input-2017-03 :tangle /tmp/advent_of_code/aoc2017-03-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-03 :var input_data=input-2017-03 :tangle /tmp/advent_of_code/aoc2017-03-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-03 :var input_data=input-2017-03 :tangle /tmp/advent_of_code/aoc2017-03-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-03 :var input_data=input-2017-03 :tangle /tmp/advent_of_code/aoc2017-03-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-03 :var input_data=input-2017-03 :tangle /tmp/advent_of_code/aoc2017-03-2.pl :results output 
#+end_src
*** Day 04: High-Entropy Passphrases
**** Part 1
***** Description
To ensure security, a valid passphrase must contain no duplicate words.
For example:

~aa bb cc dd ee is valid.~
~aa bb cc dd aa is not valid - the word aa appears more than once.~
~aa bb cc dd aaa is valid - aa and aaa count as different words.~

The system's full passphrase list is available as your puzzle input. ~How many passphrases are valid?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-04 :var input_data=input-2017-04 :tangle /tmp/advent_of_code/aoc2017-04-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-04 :var input_data=input-2017-04 :tangle /tmp/advent_of_code/aoc2017-04-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-04 :var input_data=input-2017-04 :tangle /tmp/advent_of_code/aoc2017-04-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-04 :var input_data=input-2017-04 :tangle /tmp/advent_of_code/aoc2017-04-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-04 :var input_data=input-2017-04 :tangle /tmp/advent_of_code/aoc2017-04-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-04 :var input_data=input-2017-04 :tangle /tmp/advent_of_code/aoc2017-04-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-04 :var input_data=input-2017-04 :tangle /tmp/advent_of_code/aoc2017-04-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-04 :var input_data=input-2017-04 :tangle /tmp/advent_of_code/aoc2017-04-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-04 :var input_data=input-2017-04 :tangle /tmp/advent_of_code/aoc2017-04-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-04 :var input_data=input-2017-04 :tangle /tmp/advent_of_code/aoc2017-04-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-04 :var input_data=input-2017-04 :tangle /tmp/advent_of_code/aoc2017-04-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-04 :var input_data=input-2017-04 :tangle /tmp/advent_of_code/aoc2017-04-2.pl :results output 
#+end_src
*** Day 05: A Maze of Twisty Trampolines, All Alike
**** Part 1
***** Description
The message includes a list of the offsets for each jump. Jumps are relative: -1 moves to the previous instruction, and 2 skips the next one. Start at the first instruction in the list. The goal is to follow the jumps until one leads ~outside~ the list.
In addition, these instructions are a little strange; after each jump, the offset of that instruction increases by 1. So, if you come across an offset of 3, you would move three instructions forward, but change it to a 4 for the next time it is encountered.
For example, consider the following list of jump offsets:

#+begin_src text
0
3
0
1
-3

#+end_src

Positive jumps ("forward") move downward; negative jumps move upward. For legibility in this example, these offset values will be written all on one line, with the current instruction marked in parentheses. The following steps would be taken before an exit is found:

~(0) 3  0  1  -3  - ~before~ we have taken any steps.~
~(1) 3  0  1  -3  - jump with offset 0 (that is, don't jump at all). Fortunately, the instruction is then incremented to 1.~
~ 2 (3) 0  1  -3  - step forward because of the instruction we just modified. The first instruction is incremented again, now to 2.~
~ 2  4  0  1 (-3) - jump all the way to the end; leave a 4 behind.~
~ 2 (4) 0  1  -2  - go back to where we just were; increment -3 to -2.~
~ 2  5  0  1  -2  - jump 4 steps forward, escaping the maze.~

In this example, the exit is reached in 5 steps.
~How many steps~ does it take to reach the exit?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-05 :var input_data=input-2017-05 :tangle /tmp/advent_of_code/aoc2017-05-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-05 :var input_data=input-2017-05 :tangle /tmp/advent_of_code/aoc2017-05-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-05 :var input_data=input-2017-05 :tangle /tmp/advent_of_code/aoc2017-05-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-05 :var input_data=input-2017-05 :tangle /tmp/advent_of_code/aoc2017-05-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-05 :var input_data=input-2017-05 :tangle /tmp/advent_of_code/aoc2017-05-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-05 :var input_data=input-2017-05 :tangle /tmp/advent_of_code/aoc2017-05-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-05 :var input_data=input-2017-05 :tangle /tmp/advent_of_code/aoc2017-05-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-05 :var input_data=input-2017-05 :tangle /tmp/advent_of_code/aoc2017-05-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-05 :var input_data=input-2017-05 :tangle /tmp/advent_of_code/aoc2017-05-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-05 :var input_data=input-2017-05 :tangle /tmp/advent_of_code/aoc2017-05-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-05 :var input_data=input-2017-05 :tangle /tmp/advent_of_code/aoc2017-05-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-05 :var input_data=input-2017-05 :tangle /tmp/advent_of_code/aoc2017-05-2.pl :results output 
#+end_src
*** Day 06: Memory Reallocation
**** Part 1
***** Description
In this area, there are <span title="There are also five currency banks, two river banks, three airplanes banking, a banked billards shot, and a left bank.">sixteen memory banks</span>; each memory bank can hold any number of ~blocks~. The goal of the reallocation routine is to balance the blocks between the memory banks.
The reallocation routine operates in cycles. In each cycle, it finds the memory bank with the most blocks (ties won by the lowest-numbered memory bank) and redistributes those blocks among the banks. To do this, it removes all of the blocks from the selected bank, then moves to the next (by index) memory bank and inserts one of the blocks. It continues doing this until it runs out of blocks; if it reaches the last memory bank, it wraps around to the first one.
The debugger would like to know how many redistributions can be done before a blocks-in-banks configuration is produced that ~has been seen before~.
For example, imagine a scenario with only four memory banks:

~The banks start with 0, 2, 7, and 0 blocks. The third bank has the most blocks, so it is chosen for redistribution.~
~Starting with the next bank (the fourth bank) and then continuing to the first bank, the second bank, and so on, the 7 blocks are spread out over the memory banks. The fourth, first, and second banks get two blocks each, and the third bank gets one back. The final result looks like this: 2 4 1 2.~
~Next, the second bank is chosen because it contains the most blocks (four). Because there are four memory banks, each gets one block. The result is: 3 1 2 3.~
~Now, there is a tie between the first and fourth memory banks, both of which have three blocks. The first bank wins the tie, and its three blocks are distributed evenly over the other three banks, leaving it with none: 0 2 3 4.~
~The fourth bank is chosen, and its four blocks are distributed such that each of the four banks receives one: 1 3 4 1.~
~The third bank is chosen, and the same thing happens: 2 4 1 2.~

At this point, we've reached a state we've seen before: 2 4 1 2 was already seen. The infinite loop is detected after the fifth block redistribution cycle, and so the answer in this example is 5.
Given the initial block counts in your puzzle input, ~how many redistribution cycles~ must be completed before a configuration is produced that has been seen before?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-06 :var input_data=input-2017-06 :tangle /tmp/advent_of_code/aoc2017-06-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-06 :var input_data=input-2017-06 :tangle /tmp/advent_of_code/aoc2017-06-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-06 :var input_data=input-2017-06 :tangle /tmp/advent_of_code/aoc2017-06-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-06 :var input_data=input-2017-06 :tangle /tmp/advent_of_code/aoc2017-06-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-06 :var input_data=input-2017-06 :tangle /tmp/advent_of_code/aoc2017-06-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-06 :var input_data=input-2017-06 :tangle /tmp/advent_of_code/aoc2017-06-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-06 :var input_data=input-2017-06 :tangle /tmp/advent_of_code/aoc2017-06-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-06 :var input_data=input-2017-06 :tangle /tmp/advent_of_code/aoc2017-06-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-06 :var input_data=input-2017-06 :tangle /tmp/advent_of_code/aoc2017-06-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-06 :var input_data=input-2017-06 :tangle /tmp/advent_of_code/aoc2017-06-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-06 :var input_data=input-2017-06 :tangle /tmp/advent_of_code/aoc2017-06-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-06 :var input_data=input-2017-06 :tangle /tmp/advent_of_code/aoc2017-06-2.pl :results output 
#+end_src
*** Day 07: Recursive Circus
**** Part 1
***** Description
One program at the bottom supports the entire tower. It's holding a large disc, and on the disc are balanced several more sub-towers. At the bottom of these sub-towers, standing on the bottom disc, are other programs, each holding ~their~ own disc, and so on. At the very tops of these sub-sub-sub-...-towers, many programs stand simply keeping the disc below them balanced but with no disc of their own.
You offer to help, but first you need to understand the structure of these towers.  You ask each program to yell out their ~name~, their ~weight~, and (if they're holding a disc) the ~names of the programs immediately above them~ balancing on that disc. You write this information down (your puzzle input). Unfortunately, in their panic, they don't do this in an orderly fashion; by the time you're done, you're not sure which program gave which information.
For example, if your list is the following:

#+begin_src text
pbga (66)
xhth (57)
ebii (61)
havc (66)
ktlj (57)
fwft (72) -&gt; ktlj, cntj, xhth
qoyq (66)
padx (45) -&gt; pbga, havc, qoyq
tknk (41) -&gt; ugml, padx, fwft
jptl (61)
ugml (68) -&gt; gyxo, ebii, jptl
gyxo (61)
cntj (57)

#+end_src

...then you would be able to recreate the structure of the towers that looks like this:

#+begin_src text
                gyxo
              /     
         ugml - ebii
       /      \     
      |         jptl
      |        
      |         pbga
     /        /
tknk --- padx - havc
     \        \
      |         qoyq
      |             
      |         ktlj
       \      /     
         fwft - cntj
              \     
                xhth

#+end_src

In this example, tknk is at the bottom of the tower (the ~bottom program~), and is holding up ugml, padx, and fwft.  Those programs are, in turn, holding up other programs; in this example, none of those programs are holding up any other programs, and are all the tops of their own towers. (The actual tower balancing in front of you is much larger.)
Before you're ready to help them, you need to make sure your information is correct.  ~What is the name of the bottom program?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-07 :var input_data=input-2017-07 :tangle /tmp/advent_of_code/aoc2017-07-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-07 :var input_data=input-2017-07 :tangle /tmp/advent_of_code/aoc2017-07-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-07 :var input_data=input-2017-07 :tangle /tmp/advent_of_code/aoc2017-07-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-07 :var input_data=input-2017-07 :tangle /tmp/advent_of_code/aoc2017-07-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-07 :var input_data=input-2017-07 :tangle /tmp/advent_of_code/aoc2017-07-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-07 :var input_data=input-2017-07 :tangle /tmp/advent_of_code/aoc2017-07-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-07 :var input_data=input-2017-07 :tangle /tmp/advent_of_code/aoc2017-07-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-07 :var input_data=input-2017-07 :tangle /tmp/advent_of_code/aoc2017-07-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-07 :var input_data=input-2017-07 :tangle /tmp/advent_of_code/aoc2017-07-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-07 :var input_data=input-2017-07 :tangle /tmp/advent_of_code/aoc2017-07-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-07 :var input_data=input-2017-07 :tangle /tmp/advent_of_code/aoc2017-07-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-07 :var input_data=input-2017-07 :tangle /tmp/advent_of_code/aoc2017-07-2.pl :results output 
#+end_src
*** Day 08: I Heard You Like Registers
**** Part 1
***** Description
Each instruction consists of several parts: the register to modify, whether to increase or decrease that register's value, the amount by which to increase or decrease it, and a condition. If the condition fails, skip the instruction without modifying the register. The registers all start at 0. The instructions look like this:

#+begin_src text
b inc 5 if a &gt; 1
a inc 1 if b &lt; 5
c dec -10 if a &gt;= 1
c inc -20 if c == 10

#+end_src

These instructions would be processed as follows:

~Because a starts at 0, it is not greater than 1, and so b is not modified.~
~a is increased by 1 (to 1) because b is less than 5 (it is 0).~
~c is decreased by -10 (to 10) because a is now greater than or equal to 1 (it is 1).~
~c is increased by -20 (to -10) because c is equal to 10.~

After this process, the largest value in any register is 1.
You might also encounter &lt;= (less than or equal to) or != (not equal to). However, the CPU doesn't have the bandwidth to tell you what all the registers are named, and leaves that to you to determine.
~What is the largest value in any register~ after completing the instructions in your puzzle input?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-08 :var input_data=input-2017-08 :tangle /tmp/advent_of_code/aoc2017-08-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-08 :var input_data=input-2017-08 :tangle /tmp/advent_of_code/aoc2017-08-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-08 :var input_data=input-2017-08 :tangle /tmp/advent_of_code/aoc2017-08-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-08 :var input_data=input-2017-08 :tangle /tmp/advent_of_code/aoc2017-08-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-08 :var input_data=input-2017-08 :tangle /tmp/advent_of_code/aoc2017-08-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-08 :var input_data=input-2017-08 :tangle /tmp/advent_of_code/aoc2017-08-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-08 :var input_data=input-2017-08 :tangle /tmp/advent_of_code/aoc2017-08-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-08 :var input_data=input-2017-08 :tangle /tmp/advent_of_code/aoc2017-08-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-08 :var input_data=input-2017-08 :tangle /tmp/advent_of_code/aoc2017-08-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-08 :var input_data=input-2017-08 :tangle /tmp/advent_of_code/aoc2017-08-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-08 :var input_data=input-2017-08 :tangle /tmp/advent_of_code/aoc2017-08-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-08 :var input_data=input-2017-08 :tangle /tmp/advent_of_code/aoc2017-08-2.pl :results output 
#+end_src
*** Day 09: Stream Processing
**** Part 1
***** Description
You sit for a while and record part of the stream (your puzzle input). The characters represent ~groups~ - sequences that begin with { and end with }. Within a group, there are zero or more other things, separated by commas: either another ~group~ or ~garbage~. Since groups can contain other groups, a } only closes the ~most-recently-opened unclosed group~ - that is, they are nestable. Your puzzle input represents a single, large group which itself contains many smaller ones.
Sometimes, instead of a group, you will find ~garbage~. Garbage begins with &lt; and ends with &gt;. Between those angle brackets, almost any character can appear, including { and }. ~Within~ garbage, &lt; has no special meaning.
In a futile attempt to clean up the garbage, some program has ~canceled~ some of the characters within it using !: inside garbage, ~any~ character that comes after ! should be ~ignored~, including &lt;, &gt;, and even another !.
You don't see any characters that deviate from these rules.  Outside garbage, you only find well-formed groups, and garbage always terminates according to the rules above.
Here are some self-contained pieces of garbage:

~&lt;&gt;, empty garbage.~
~&lt;random characters&gt;, garbage containing random characters.~
~&lt;&lt;&lt;&lt;&gt;, because the extra &lt; are ignored.~
~&lt;{!&gt;}&gt;, because the first &gt; is canceled.~
~&lt;!!&gt;, because the second ! is canceled, allowing the &gt; to terminate the garbage.~
~&lt;!!!&gt;&gt;, because the second ! and the first &gt; are canceled.~
~&lt;{o"i!a,&lt;{i&lt;a&gt;, which ends at the first &gt;.~

Here are some examples of whole streams and the number of groups they contain:

~{}, 1 group.~
~{{{}}}, 3 groups.~
~{{},{}}, also 3 groups.~
~{{{},{},{{}}}}, 6 groups.~
~{&lt;{},{},{{}}&gt;}, 1 group (which itself contains garbage).~
~{&lt;a&gt;,&lt;a&gt;,&lt;a&gt;,&lt;a&gt;}, 1 group.~
~{{&lt;a&gt;},{&lt;a&gt;},{&lt;a&gt;},{&lt;a&gt;}}, 5 groups.~
~{{&lt;!&gt;},{&lt;!&gt;},{&lt;!&gt;},{&lt;a&gt;}}, 2 groups (since all but the last &gt; are canceled).~

Your goal is to find the total score for all groups in your input. Each group is assigned a ~score~ which is one more than the score of the group that immediately contains it. (The outermost group gets a score of 1.)

~{}, score of 1.~
~{{{}}}, score of 1 + 2 + 3 = 6.~
~{{},{}}, score of 1 + 2 + 2 = 5.~
~{{{},{},{{}}}}, score of 1 + 2 + 3 + 3 + 3 + 4 = 16.~
~{&lt;a&gt;,&lt;a&gt;,&lt;a&gt;,&lt;a&gt;}, score of 1.~
~{{&lt;ab&gt;},{&lt;ab&gt;},{&lt;ab&gt;},{&lt;ab&gt;}}, score of 1 + 2 + 2 + 2 + 2 = 9.~
~{{&lt;!!&gt;},{&lt;!!&gt;},{&lt;!!&gt;},{&lt;!!&gt;}}, score of 1 + 2 + 2 + 2 + 2 = 9.~
~{{&lt;a!&gt;},{&lt;a!&gt;},{&lt;a!&gt;},{&lt;ab&gt;}}, score of 1 + 2 = 3.~

~What is the total score~ for all groups in your input?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-09 :var input_data=input-2017-09 :tangle /tmp/advent_of_code/aoc2017-09-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-09 :var input_data=input-2017-09 :tangle /tmp/advent_of_code/aoc2017-09-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-09 :var input_data=input-2017-09 :tangle /tmp/advent_of_code/aoc2017-09-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-09 :var input_data=input-2017-09 :tangle /tmp/advent_of_code/aoc2017-09-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-09 :var input_data=input-2017-09 :tangle /tmp/advent_of_code/aoc2017-09-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-09 :var input_data=input-2017-09 :tangle /tmp/advent_of_code/aoc2017-09-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-09 :var input_data=input-2017-09 :tangle /tmp/advent_of_code/aoc2017-09-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-09 :var input_data=input-2017-09 :tangle /tmp/advent_of_code/aoc2017-09-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-09 :var input_data=input-2017-09 :tangle /tmp/advent_of_code/aoc2017-09-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-09 :var input_data=input-2017-09 :tangle /tmp/advent_of_code/aoc2017-09-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-09 :var input_data=input-2017-09 :tangle /tmp/advent_of_code/aoc2017-09-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-09 :var input_data=input-2017-09 :tangle /tmp/advent_of_code/aoc2017-09-2.pl :results output 
#+end_src
*** Day 10: Knot Hash
**** Part 1
***** Description
This hash function simulates tying a knot in a circle of string with 256 marks on it. Based on the input to be hashed, the function repeatedly selects a span of string, brings the ends together, and gives the span a half-twist to reverse the order of the marks within it. After doing this many times, the order of the marks is used to build the resulting hash.

#+begin_src text
  4--5   pinch   4  5           4   1
 /    \  5,0,1  / \/ \  twist  / \ / \
3      0  --&gt;  3      0  --&gt;  3   X   0
 \    /         \ /\ /         \ / \ /
  2--1           2  1           2   5

#+end_src

To achieve this, begin with a ~list~ of numbers from 0 to 255, a ~current position~ which begins at 0 (the first element in the list), a ~skip size~ (which starts at 0), and a sequence of ~lengths~ (your puzzle input).  Then, for each length:

~~Reverse~ the order of that ~length~ of elements in the ~list~, starting with the element at the ~current position~.~
~~Move~ the ~current position~ forward by that ~length~ plus the ~skip size~.~
~~Increase~ the ~skip size~ by one.~

The ~list~ is circular; if the ~current position~ and the ~length~ try to reverse elements beyond the end of the list, the operation reverses using as many extra elements as it needs from the front of the list. If the ~current position~ moves past the end of the list, it wraps around to the front. ~Lengths~ larger than the size of the ~list~ are invalid.
Here's an example using a smaller list:
Suppose we instead only had a circular list containing five elements, 0, 1, 2, 3, 4, and were given input lengths of 3, 4, 1, 5.

~The list begins as [0] 1 2 3 4 (where square brackets indicate the ~current position~).~
~The first length, 3, selects ([0] 1 2) 3 4 (where parentheses indicate the sublist to be reversed).~
~After reversing that section (0 1 2 into 2 1 0), we get ([2] 1 0) 3 4.~
~Then, the ~current position~ moves forward by the ~length~, 3, plus the ~skip size~, 0: 2 1 0 [3] 4. Finally, the ~skip size~ increases to 1.~


~The second length, 4, selects a section which wraps: 2 1) 0 ([3] 4.~
~The sublist 3 4 2 1 is reversed to form 1 2 4 3: 4 3) 0 ([1] 2.~
~The ~current position~ moves forward by the ~length~ plus the ~skip size~, a total of 5, causing it not to move because it wraps around: 4 3 0 [1] 2. The ~skip size~ increases to 2.~


~The third length, 1, selects a sublist of a single element, and so reversing it has no effect.~
~The ~current position~ moves forward by the ~length~ (1) plus the ~skip size~ (2): 4 [3] 0 1 2. The ~skip size~ increases to 3.~


~The fourth length, 5, selects every element starting with the second: 4) ([3] 0 1 2. Reversing this sublist (3 0 1 2 4 into 4 2 1 0 3) produces: 3) ([4] 2 1 0.~
~Finally, the ~current position~ moves forward by 8: 3 4 2 1 [0]. The ~skip size~ increases to 4.~

In this example, the first two numbers in the list end up being 3 and 4; to check the process, you can multiply them together to produce 12.
However, you should instead use the standard list size of 256 (with values 0 to 255) and the sequence of ~lengths~ in your puzzle input. Once this process is complete, ~what is the result of multiplying the first two numbers in the list~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-10 :var input_data=input-2017-10 :tangle /tmp/advent_of_code/aoc2017-10-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-10 :var input_data=input-2017-10 :tangle /tmp/advent_of_code/aoc2017-10-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-10 :var input_data=input-2017-10 :tangle /tmp/advent_of_code/aoc2017-10-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-10 :var input_data=input-2017-10 :tangle /tmp/advent_of_code/aoc2017-10-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-10 :var input_data=input-2017-10 :tangle /tmp/advent_of_code/aoc2017-10-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-10 :var input_data=input-2017-10 :tangle /tmp/advent_of_code/aoc2017-10-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-10 :var input_data=input-2017-10 :tangle /tmp/advent_of_code/aoc2017-10-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-10 :var input_data=input-2017-10 :tangle /tmp/advent_of_code/aoc2017-10-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-10 :var input_data=input-2017-10 :tangle /tmp/advent_of_code/aoc2017-10-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-10 :var input_data=input-2017-10 :tangle /tmp/advent_of_code/aoc2017-10-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-10 :var input_data=input-2017-10 :tangle /tmp/advent_of_code/aoc2017-10-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-10 :var input_data=input-2017-10 :tangle /tmp/advent_of_code/aoc2017-10-2.pl :results output 
#+end_src
*** Day 11: Hex Ed
**** Part 1
***** Description
Fortunately for her, you have plenty of experience with infinite grids.
Unfortunately for you, it's a <a href="https://en.wikipedia.org/wiki/Hexagonal_tiling">hex grid</a>.
The hexagons ("hexes") in <span title="Raindrops on roses and whiskers on kittens.">this grid</span> are aligned such that adjacent hexes can be found to the north, northeast, southeast, south, southwest, and northwest:

#+begin_src text
  \ n  /
nw +--+ ne
  /    \
-+      +-
  \    /
sw +--+ se
  / s  \

#+end_src

You have the path the child process took. Starting where he started, you need to determine the fewest number of steps required to reach him. (A "step" means to move from the hex you are in to any adjacent hex.)
For example:

~ne,ne,ne is 3 steps away.~
~ne,ne,sw,sw is 0 steps away (back where you started).~
~ne,ne,s,s is 2 steps away (se,se).~
~se,sw,se,sw,sw is 3 steps away (s,s,sw).~

 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-11 :var input_data=input-2017-11 :tangle /tmp/advent_of_code/aoc2017-11-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-11 :var input_data=input-2017-11 :tangle /tmp/advent_of_code/aoc2017-11-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-11 :var input_data=input-2017-11 :tangle /tmp/advent_of_code/aoc2017-11-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-11 :var input_data=input-2017-11 :tangle /tmp/advent_of_code/aoc2017-11-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-11 :var input_data=input-2017-11 :tangle /tmp/advent_of_code/aoc2017-11-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-11 :var input_data=input-2017-11 :tangle /tmp/advent_of_code/aoc2017-11-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-11 :var input_data=input-2017-11 :tangle /tmp/advent_of_code/aoc2017-11-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-11 :var input_data=input-2017-11 :tangle /tmp/advent_of_code/aoc2017-11-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-11 :var input_data=input-2017-11 :tangle /tmp/advent_of_code/aoc2017-11-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-11 :var input_data=input-2017-11 :tangle /tmp/advent_of_code/aoc2017-11-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-11 :var input_data=input-2017-11 :tangle /tmp/advent_of_code/aoc2017-11-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-11 :var input_data=input-2017-11 :tangle /tmp/advent_of_code/aoc2017-11-2.pl :results output 
#+end_src
*** Day 12: Digital Plumber
**** Part 1
***** Description
Programs in this village communicate using a fixed system of ~pipes~. Messages are passed between programs using these pipes, but most programs aren't connected to each other directly.  Instead, programs pass messages between each other until the message reaches the intended recipient.
For some reason, though, some of these messages aren't ever reaching their intended recipient, and the programs suspect that some <span title="Yes, citizens, plumbing! It's the latest invention to hit Rome!">pipes</span> are missing. They would like you to investigate.
You walk through the village and record the ID of each program and the IDs with which it can communicate directly (your puzzle input). Each program has one or more programs with which it can communicate, and these pipes are bidirectional; if 8 says it can communicate with 11, then 11 will say it can communicate with 8.
You need to figure out how many programs are in the group that contains program ID 0.
For example, suppose you go door-to-door like a travelling salesman and record the following list:

#+begin_src text
0 &lt;-&gt; 2
1 &lt;-&gt; 1
2 &lt;-&gt; 0, 3, 4
3 &lt;-&gt; 2, 4
4 &lt;-&gt; 2, 3, 6
5 &lt;-&gt; 6
6 &lt;-&gt; 4, 5

#+end_src

In this example, the following programs are in the group that contains program ID 0:

~Program 0 by definition.~
~Program 2, directly connected to program 0.~
~Program 3 via program 2.~
~Program 4 via program 2.~
~Program 5 via programs 6, then 4, then 2.~
~Program 6 via programs 4, then 2.~

Therefore, a total of 6 programs are in this group; all but program 1, which has a pipe that connects it to itself.
~How many programs~ are in the group that contains program ID 0?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-12 :var input_data=input-2017-12 :tangle /tmp/advent_of_code/aoc2017-12-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-12 :var input_data=input-2017-12 :tangle /tmp/advent_of_code/aoc2017-12-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-12 :var input_data=input-2017-12 :tangle /tmp/advent_of_code/aoc2017-12-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-12 :var input_data=input-2017-12 :tangle /tmp/advent_of_code/aoc2017-12-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-12 :var input_data=input-2017-12 :tangle /tmp/advent_of_code/aoc2017-12-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-12 :var input_data=input-2017-12 :tangle /tmp/advent_of_code/aoc2017-12-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-12 :var input_data=input-2017-12 :tangle /tmp/advent_of_code/aoc2017-12-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-12 :var input_data=input-2017-12 :tangle /tmp/advent_of_code/aoc2017-12-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-12 :var input_data=input-2017-12 :tangle /tmp/advent_of_code/aoc2017-12-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-12 :var input_data=input-2017-12 :tangle /tmp/advent_of_code/aoc2017-12-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-12 :var input_data=input-2017-12 :tangle /tmp/advent_of_code/aoc2017-12-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-12 :var input_data=input-2017-12 :tangle /tmp/advent_of_code/aoc2017-12-2.pl :results output 
#+end_src
*** Day 13: Packet Scanners
**** Part 1
***** Description
By studying the firewall briefly, you are able to record (in your puzzle input) the ~depth~ of each layer and the ~range~ of the scanning area for the scanner within it, written as depth: range. Each layer has a thickness of exactly 1. A layer at depth 0 begins immediately inside the firewall; a layer at depth 1 would start immediately after that.
For example, suppose you've recorded the following:

#+begin_src text
0: 3
1: 2
4: 4
6: 4

#+end_src

This means that there is a layer immediately inside the firewall (with range 3), a second layer immediately after that (with range 2), a third layer which begins at depth 4 (with range 4), and a fourth layer which begins at depth 6 (also with range 4). Visually, it might look like this:

#+begin_src text
 0   1   2   3   4   5   6
[ ] [ ] ... ... [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[ ]             [ ]     [ ]
                [ ]     [ ]

#+end_src

Within each layer, a security scanner moves back and forth within its range. Each security scanner starts at the top and moves down until it reaches the bottom, then moves up until it reaches the top, and repeats. A security scanner takes ~one picosecond~ to move one step.  Drawing scanners as S, the first few picoseconds look like this:

#+begin_src text

Picosecond 0:
 0   1   2   3   4   5   6
[S] [S] ... ... [S] ... [S]
[ ] [ ]         [ ]     [ ]
[ ]             [ ]     [ ]
                [ ]     [ ]

Picosecond 1:
 0   1   2   3   4   5   6
[ ] [ ] ... ... [ ] ... [ ]
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]

Picosecond 2:
 0   1   2   3   4   5   6
[ ] [S] ... ... [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[S]             [S]     [S]
                [ ]     [ ]

Picosecond 3:
 0   1   2   3   4   5   6
[ ] [ ] ... ... [ ] ... [ ]
[S] [S]         [ ]     [ ]
[ ]             [ ]     [ ]
                [S]     [S]

#+end_src

Your plan is to hitch a ride on a packet about to move through the firewall.  The packet will travel along the top of each layer, and it moves at ~one layer per picosecond~. Each picosecond, the packet moves one layer forward (its first move takes it into layer 0), and then the scanners move one step. If there is a scanner at the top of the layer ~as your packet enters it~, you are ~caught~. (If a scanner moves into the top of its layer while you are there, you are ~not~ caught: it doesn't have time to notice you before you leave.) If you were to do this in the configuration above, marking your current position with parentheses, your passage through the firewall would look like this:

#+begin_src text
Initial state:
 0   1   2   3   4   5   6
[S] [S] ... ... [S] ... [S]
[ ] [ ]         [ ]     [ ]
[ ]             [ ]     [ ]
                [ ]     [ ]

Picosecond 0:
 0   1   2   3   4   5   6
(S) [S] ... ... [S] ... [S]
[ ] [ ]         [ ]     [ ]
[ ]             [ ]     [ ]
                [ ]     [ ]

 0   1   2   3   4   5   6
( ) [ ] ... ... [ ] ... [ ]
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]


Picosecond 1:
 0   1   2   3   4   5   6
[ ] ( ) ... ... [ ] ... [ ]
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]

 0   1   2   3   4   5   6
[ ] (S) ... ... [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[S]             [S]     [S]
                [ ]     [ ]


Picosecond 2:
 0   1   2   3   4   5   6
[ ] [S] (.) ... [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[S]             [S]     [S]
                [ ]     [ ]

 0   1   2   3   4   5   6
[ ] [ ] (.) ... [ ] ... [ ]
[S] [S]         [ ]     [ ]
[ ]             [ ]     [ ]
                [S]     [S]


Picosecond 3:
 0   1   2   3   4   5   6
[ ] [ ] ... (.) [ ] ... [ ]
[S] [S]         [ ]     [ ]
[ ]             [ ]     [ ]
                [S]     [S]

 0   1   2   3   4   5   6
[S] [S] ... (.) [ ] ... [ ]
[ ] [ ]         [ ]     [ ]
[ ]             [S]     [S]
                [ ]     [ ]


Picosecond 4:
 0   1   2   3   4   5   6
[S] [S] ... ... ( ) ... [ ]
[ ] [ ]         [ ]     [ ]
[ ]             [S]     [S]
                [ ]     [ ]

 0   1   2   3   4   5   6
[ ] [ ] ... ... ( ) ... [ ]
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]


Picosecond 5:
 0   1   2   3   4   5   6
[ ] [ ] ... ... [ ] (.) [ ]
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]

 0   1   2   3   4   5   6
[ ] [S] ... ... [S] (.) [S]
[ ] [ ]         [ ]     [ ]
[S]             [ ]     [ ]
                [ ]     [ ]


Picosecond 6:
 0   1   2   3   4   5   6
[ ] [S] ... ... [S] ... (S)
[ ] [ ]         [ ]     [ ]
[S]             [ ]     [ ]
                [ ]     [ ]

 0   1   2   3   4   5   6
[ ] [ ] ... ... [ ] ... ( )
[S] [S]         [S]     [S]
[ ]             [ ]     [ ]
                [ ]     [ ]

#+end_src

In this situation, you are ~caught~ in layers 0 and 6, because your packet entered the layer when its scanner was at the top when you entered it. You are ~not~ caught in layer 1, since the scanner moved into the top of the layer once you were already there.
The ~severity~ of getting caught on a layer is equal to its ~depth~ multiplied by its ~range~. (Ignore layers in which you do not get caught.) The severity of the whole trip is the sum of these values.  In the example above, the trip severity is 0*3 + 6*4 = ~24~.
Given the details of the firewall you've recorded, if you leave immediately, ~what is the severity of your whole trip~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-13 :var input_data=input-2017-13 :tangle /tmp/advent_of_code/aoc2017-13-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-13 :var input_data=input-2017-13 :tangle /tmp/advent_of_code/aoc2017-13-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-13 :var input_data=input-2017-13 :tangle /tmp/advent_of_code/aoc2017-13-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-13 :var input_data=input-2017-13 :tangle /tmp/advent_of_code/aoc2017-13-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-13 :var input_data=input-2017-13 :tangle /tmp/advent_of_code/aoc2017-13-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-13 :var input_data=input-2017-13 :tangle /tmp/advent_of_code/aoc2017-13-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-13 :var input_data=input-2017-13 :tangle /tmp/advent_of_code/aoc2017-13-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-13 :var input_data=input-2017-13 :tangle /tmp/advent_of_code/aoc2017-13-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-13 :var input_data=input-2017-13 :tangle /tmp/advent_of_code/aoc2017-13-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-13 :var input_data=input-2017-13 :tangle /tmp/advent_of_code/aoc2017-13-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-13 :var input_data=input-2017-13 :tangle /tmp/advent_of_code/aoc2017-13-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-13 :var input_data=input-2017-13 :tangle /tmp/advent_of_code/aoc2017-13-2.pl :results output 
#+end_src
*** Day 14: Disk Defragmentation
**** Part 1
***** Description
The disk in question consists of a 128x128 grid; each square of the grid is either ~free~ or ~used~. On this disk, the state of the grid is tracked by the bits in a sequence of <a href="10">knot hashes</a>.
A total of 128 knot hashes are calculated, each corresponding to a single row in the grid; each hash contains 128 bits which correspond to individual grid squares. Each bit of a hash indicates whether that square is ~free~ (0) or ~used~ (1).
The hash inputs are a key string (your puzzle input), a dash, and a number from 0 to 127 corresponding to the row.  For example, if your key string were flqrgnkx, then the first row would be given by the bits of the knot hash of flqrgnkx-0, the second row from the bits of the knot hash of flqrgnkx-1, and so on until the last row, flqrgnkx-127.
The output of a knot hash is traditionally represented by 32 hexadecimal digits; each of these digits correspond to 4 bits, for a total of 4 * 32 = 128 bits. To convert to bits, turn each hexadecimal digit to its equivalent binary value, high-bit first: 0 becomes 0000, 1 becomes 0001, e becomes 1110, f becomes 1111, and so on; a hash that begins with a0c2017... in hexadecimal would begin with 10100000110000100000000101110000... in binary.
Continuing this process, the ~first 8 rows and columns~ for key flqrgnkx appear as follows, using # to denote used squares, and . to denote free ones:

#+begin_src text
##.#.#..--&gt;
.#.#.#.#   
....#.#.   
#.#.##.#   
.##.#...   
##..#..#   
.#...#..   
##.#.##.--&gt;
|      |   
V      V   

#+end_src

In this example, 8108 squares are used across the entire 128x128 grid.
Given your actual key string, ~how many squares are used~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-14 :var input_data=input-2017-14 :tangle /tmp/advent_of_code/aoc2017-14-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-14 :var input_data=input-2017-14 :tangle /tmp/advent_of_code/aoc2017-14-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-14 :var input_data=input-2017-14 :tangle /tmp/advent_of_code/aoc2017-14-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-14 :var input_data=input-2017-14 :tangle /tmp/advent_of_code/aoc2017-14-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-14 :var input_data=input-2017-14 :tangle /tmp/advent_of_code/aoc2017-14-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-14 :var input_data=input-2017-14 :tangle /tmp/advent_of_code/aoc2017-14-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-14 :var input_data=input-2017-14 :tangle /tmp/advent_of_code/aoc2017-14-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-14 :var input_data=input-2017-14 :tangle /tmp/advent_of_code/aoc2017-14-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-14 :var input_data=input-2017-14 :tangle /tmp/advent_of_code/aoc2017-14-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-14 :var input_data=input-2017-14 :tangle /tmp/advent_of_code/aoc2017-14-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-14 :var input_data=input-2017-14 :tangle /tmp/advent_of_code/aoc2017-14-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-14 :var input_data=input-2017-14 :tangle /tmp/advent_of_code/aoc2017-14-2.pl :results output 
#+end_src
*** Day 15: Dueling Generators
**** Part 1
***** Description
As they do this, a ~judge~ waits for each of them to generate its next value, compares the lowest 16 bits of both values, and keeps track of the number of times those parts of the values match.
The generators both work on the same principle. To create its next value, a generator will take the previous value it produced, multiply it by a ~factor~ (generator A uses 16807; generator B uses 48271), and then keep the remainder of dividing that resulting product by 2147483647. That final remainder is the value it produces next.
To calculate each generator's first value, it instead uses a specific starting value as its "previous value" (as listed in your puzzle input).
For example, suppose that for starting values, generator A uses 65, while generator B uses 8921. Then, the first five pairs of generated values are:

#+begin_src text
--Gen. A--  --Gen. B--
   1092455   430625591
1181022009  1233683848
 245556042  1431495498
1744312007   137874439
1352636452   285222916

#+end_src

In binary, these pairs are (with generator A's value first in each pair):

#+begin_src text
00000000000100001010101101100111
00011001101010101101001100110111

01000110011001001111011100111001
01001001100010001000010110001000

00001110101000101110001101001010
01010101010100101110001101001010

01100111111110000001011011000111
00001000001101111100110000000111

01010000100111111001100000100100
00010001000000000010100000000100

#+end_src

Here, you can see that the lowest (here, rightmost) 16 bits of the third value match: 1110001101001010. Because of this one match, after processing these five pairs, the judge would have added only 1 to its total.
To get a significant sample, the judge would like to consider ~40 million~ pairs. (In the example above, the judge would eventually find a total of 588 pairs that match in their lowest 16 bits.)
After 40 million pairs, ~what is the judge's final count~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-15 :var input_data=input-2017-15 :tangle /tmp/advent_of_code/aoc2017-15-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-15 :var input_data=input-2017-15 :tangle /tmp/advent_of_code/aoc2017-15-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-15 :var input_data=input-2017-15 :tangle /tmp/advent_of_code/aoc2017-15-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-15 :var input_data=input-2017-15 :tangle /tmp/advent_of_code/aoc2017-15-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-15 :var input_data=input-2017-15 :tangle /tmp/advent_of_code/aoc2017-15-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-15 :var input_data=input-2017-15 :tangle /tmp/advent_of_code/aoc2017-15-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-15 :var input_data=input-2017-15 :tangle /tmp/advent_of_code/aoc2017-15-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-15 :var input_data=input-2017-15 :tangle /tmp/advent_of_code/aoc2017-15-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-15 :var input_data=input-2017-15 :tangle /tmp/advent_of_code/aoc2017-15-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-15 :var input_data=input-2017-15 :tangle /tmp/advent_of_code/aoc2017-15-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-15 :var input_data=input-2017-15 :tangle /tmp/advent_of_code/aoc2017-15-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-15 :var input_data=input-2017-15 :tangle /tmp/advent_of_code/aoc2017-15-2.pl :results output 
#+end_src
*** Day 16: Permutation Promenade
**** Part 1
***** Description
There are sixteen programs in total, named a through p. They start by standing in a <span title="This is called a 'newline'.">line</span>: a stands in position 0, b stands in position 1, and so on until p, which stands in position 15.
The programs' ~dance~ consists of a sequence of ~dance moves~:

~~Spin~, written sX, makes X programs move from the end to the front, but maintain their order otherwise. (For example, s3 on abcde produces cdeab).~
~~Exchange~, written xA/B, makes the programs at positions A and B swap places.~
~~Partner~, written pA/B, makes the programs named A and B swap places.~

For example, with only five programs standing in a line (abcde), they could do the following dance:

~s1, a spin of size 1: eabcd.~
~x3/4, swapping the last two programs: eabdc.~
~pe/b, swapping programs e and b: baedc.~

After finishing their dance, the programs end up in order baedc.
You watch the dance for a while and record their dance moves (your puzzle input). ~In what order are the programs standing~ after their dance?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-16 :var input_data=input-2017-16 :tangle /tmp/advent_of_code/aoc2017-16-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-16 :var input_data=input-2017-16 :tangle /tmp/advent_of_code/aoc2017-16-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-16 :var input_data=input-2017-16 :tangle /tmp/advent_of_code/aoc2017-16-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-16 :var input_data=input-2017-16 :tangle /tmp/advent_of_code/aoc2017-16-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-16 :var input_data=input-2017-16 :tangle /tmp/advent_of_code/aoc2017-16-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-16 :var input_data=input-2017-16 :tangle /tmp/advent_of_code/aoc2017-16-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-16 :var input_data=input-2017-16 :tangle /tmp/advent_of_code/aoc2017-16-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-16 :var input_data=input-2017-16 :tangle /tmp/advent_of_code/aoc2017-16-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-16 :var input_data=input-2017-16 :tangle /tmp/advent_of_code/aoc2017-16-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-16 :var input_data=input-2017-16 :tangle /tmp/advent_of_code/aoc2017-16-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-16 :var input_data=input-2017-16 :tangle /tmp/advent_of_code/aoc2017-16-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-16 :var input_data=input-2017-16 :tangle /tmp/advent_of_code/aoc2017-16-2.pl :results output 
#+end_src
*** Day 17: Spinlock
**** Part 1
***** Description
If you don't move quickly, fixing that printer will be the least of your problems.
This spinlock's algorithm is simple but efficient, quickly consuming everything in its path. It starts with a circular buffer containing only the value 0, which it marks as the ~current position~. It then steps forward through the circular buffer some number of steps (your puzzle input) before inserting the first new value, 1, after the value it stopped on.  The inserted value becomes the ~current position~. Then, it steps forward from there the same number of steps, and wherever it stops, inserts after it the second new value, 2, and uses that as the new ~current position~ again.
It repeats this process of ~stepping forward~, ~inserting a new value~, and ~using the location of the inserted value as the new current position~ a total of ~2017~ times, inserting 2017 as its final operation, and ending with a total of 2018 values (including 0) in the circular buffer.
For example, if the spinlock were to step 3 times per insert, the circular buffer would begin to evolve like this (using parentheses to mark the current position after each iteration of the algorithm):

~(0), the initial state before any insertions.~
~0 (1): the spinlock steps forward three times (0, 0, 0), and then inserts the first value, 1, after it. 1 becomes the current position.~
~0 (2) 1: the spinlock steps forward three times (0, 1, 0), and then inserts the second value, 2, after it. 2 becomes the current position.~
~0  2 (3) 1: the spinlock steps forward three times (1, 0, 2), and then inserts the third value, 3, after it. 3 becomes the current position.~

And so on:

~0  2 (4) 3  1~
~0 (5) 2  4  3  1~
~0  5  2  4  3 (6) 1~
~0  5 (7) 2  4  3  6  1~
~0  5  7  2  4  3 (8) 6  1~
~0 (9) 5  7  2  4  3  8  6  1~

Eventually, after 2017 insertions, the section of the circular buffer near the last insertion looks like this:

#+begin_src text
1512  1134  151 (2017) 638  1513  851
#+end_src

Perhaps, if you can identify the value that will ultimately be ~after~ the last value written (2017), you can short-circuit the spinlock.  In this example, that would be 638.
~What is the value after 2017~ in your completed circular buffer?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-17 :var input_data=input-2017-17 :tangle /tmp/advent_of_code/aoc2017-17-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-17 :var input_data=input-2017-17 :tangle /tmp/advent_of_code/aoc2017-17-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-17 :var input_data=input-2017-17 :tangle /tmp/advent_of_code/aoc2017-17-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-17 :var input_data=input-2017-17 :tangle /tmp/advent_of_code/aoc2017-17-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-17 :var input_data=input-2017-17 :tangle /tmp/advent_of_code/aoc2017-17-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-17 :var input_data=input-2017-17 :tangle /tmp/advent_of_code/aoc2017-17-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-17 :var input_data=input-2017-17 :tangle /tmp/advent_of_code/aoc2017-17-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-17 :var input_data=input-2017-17 :tangle /tmp/advent_of_code/aoc2017-17-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-17 :var input_data=input-2017-17 :tangle /tmp/advent_of_code/aoc2017-17-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-17 :var input_data=input-2017-17 :tangle /tmp/advent_of_code/aoc2017-17-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-17 :var input_data=input-2017-17 :tangle /tmp/advent_of_code/aoc2017-17-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-17 :var input_data=input-2017-17 :tangle /tmp/advent_of_code/aoc2017-17-2.pl :results output 
#+end_src
*** Day 18: Duet
**** Part 1
***** Description
It seems like the assembly is meant to operate on a set of ~registers~ that are each named with a single letter and that can each hold a single <a href="https://en.wikipedia.org/wiki/Integer">integer</a>. You suppose each register should start with a value of 0.
There aren't that many instructions, so it shouldn't be hard to figure out what they do.  Here's what you determine:

~snd X ~<span title="I don't recommend actually trying this.">plays a sound</span>~ with a frequency equal to the value of X.~
~set X Y ~sets~ register X to the value of Y.~
~add X Y ~increases~ register X by the value of Y.~
~mul X Y sets register X to the result of ~multiplying~ the value contained in register X by the value of Y.~
~mod X Y sets register X to the ~remainder~ of dividing the value contained in register X by the value of Y (that is, it sets X to the result of X <a href="https://en.wikipedia.org/wiki/Modulo_operation">modulo</a> Y).~
~rcv X ~recovers~ the frequency of the last sound played, but only when the value of X is not zero. (If it is zero, the command does nothing.)~
~jgz X Y ~jumps~ with an offset of the value of Y, but only if the value of X is ~greater than zero~. (An offset of 2 skips the next instruction, an offset of -1 jumps to the previous instruction, and so on.)~

Many of the instructions can take either a register (a single letter) or a number. The value of a register is the integer it contains; the value of a number is that number.
After each ~jump~ instruction, the program continues with the instruction to which the ~jump~ jumped. After any other instruction, the program continues with the next instruction. Continuing (or jumping) off either end of the program terminates it.
For example:

#+begin_src text
set a 1
add a 2
mul a a
mod a 5
snd a
set a 0
rcv a
jgz a -1
set a 1
jgz a -2

#+end_src


~The first four instructions set a to 1, add 2 to it, square it, and then set it to itself modulo 5, resulting in a value of 4.~
~Then, a sound with frequency 4 (the value of a) is played.~
~After that, a is set to 0, causing the subsequent rcv and jgz instructions to both be skipped (rcv because a is 0, and jgz because a is not greater than 0).~
~Finally, a is set to 1, causing the next jgz instruction to activate, jumping back two instructions to another jump, which jumps again to the rcv, which ultimately triggers the ~recover~ operation.~

At the time the ~recover~ operation is executed, the frequency of the last sound played is 4.
~What is the value of the recovered frequency~ (the value of the most recently played sound) the ~first~ time a rcv instruction is executed with a non-zero value?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-18 :var input_data=input-2017-18 :tangle /tmp/advent_of_code/aoc2017-18-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-18 :var input_data=input-2017-18 :tangle /tmp/advent_of_code/aoc2017-18-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-18 :var input_data=input-2017-18 :tangle /tmp/advent_of_code/aoc2017-18-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-18 :var input_data=input-2017-18 :tangle /tmp/advent_of_code/aoc2017-18-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-18 :var input_data=input-2017-18 :tangle /tmp/advent_of_code/aoc2017-18-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-18 :var input_data=input-2017-18 :tangle /tmp/advent_of_code/aoc2017-18-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-18 :var input_data=input-2017-18 :tangle /tmp/advent_of_code/aoc2017-18-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-18 :var input_data=input-2017-18 :tangle /tmp/advent_of_code/aoc2017-18-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-18 :var input_data=input-2017-18 :tangle /tmp/advent_of_code/aoc2017-18-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-18 :var input_data=input-2017-18 :tangle /tmp/advent_of_code/aoc2017-18-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-18 :var input_data=input-2017-18 :tangle /tmp/advent_of_code/aoc2017-18-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-18 :var input_data=input-2017-18 :tangle /tmp/advent_of_code/aoc2017-18-2.pl :results output 
#+end_src
*** Day 19: A Series of Tubes
**** Part 1
***** Description
Its starting point is just off the top of the diagram. Lines (drawn with |, -, and +) show the path it needs to take, starting by going down onto the only line connected to the top of the diagram. It needs to follow this path until it reaches the end (located somewhere within the diagram) and stop there.
Sometimes, the lines cross over each other; in these cases, it needs to continue going the same direction, and only turn left or right when there's no other option.  In addition, someone has left ~letters~ on the line; these also don't change its direction, but it can use them to keep track of where it's been. For example:

#+begin_src text
     |          
     |  +--+    
     A  |  C    
 F---|----E|--+ 
     |  |  |  D 
     +B-+  +--+ 


#+end_src

Given this diagram, the packet needs to take the following path:

~Starting at the only line touching the top of the diagram, it must go down, pass through A, and continue onward to the first +.~
~Travel right, up, and right, passing through B in the process.~
~Continue down (collecting C), right, and up (collecting D).~
~Finally, go all the way left through E and stopping at F.~

Following the path to the end, the letters it sees on its path are ABCDEF.
The little packet looks up at you, hoping you can help it find the way.  ~What letters will it see~ (in the order it would see them) if it follows the path? (The routing diagram is very wide; make sure you view it without line wrapping.)
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-19 :var input_data=input-2017-19 :tangle /tmp/advent_of_code/aoc2017-19-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-19 :var input_data=input-2017-19 :tangle /tmp/advent_of_code/aoc2017-19-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-19 :var input_data=input-2017-19 :tangle /tmp/advent_of_code/aoc2017-19-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-19 :var input_data=input-2017-19 :tangle /tmp/advent_of_code/aoc2017-19-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-19 :var input_data=input-2017-19 :tangle /tmp/advent_of_code/aoc2017-19-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-19 :var input_data=input-2017-19 :tangle /tmp/advent_of_code/aoc2017-19-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-19 :var input_data=input-2017-19 :tangle /tmp/advent_of_code/aoc2017-19-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-19 :var input_data=input-2017-19 :tangle /tmp/advent_of_code/aoc2017-19-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-19 :var input_data=input-2017-19 :tangle /tmp/advent_of_code/aoc2017-19-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-19 :var input_data=input-2017-19 :tangle /tmp/advent_of_code/aoc2017-19-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-19 :var input_data=input-2017-19 :tangle /tmp/advent_of_code/aoc2017-19-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-19 :var input_data=input-2017-19 :tangle /tmp/advent_of_code/aoc2017-19-2.pl :results output 
#+end_src
*** Day 20: Particle Swarm
**** Part 1
***** Description
It transmits to you a buffer (your puzzle input) listing each particle in order (starting with particle 0, then particle 1, particle 2, and so on). For each particle, it provides the X, Y, and Z coordinates for the particle's position (p), velocity (v), and acceleration (a), each in the format &lt;X,Y,Z&gt;.
Each tick, all particles are updated simultaneously. A particle's properties are updated in the following order:

~Increase the X velocity by the X acceleration.~
~Increase the Y velocity by the Y acceleration.~
~Increase the Z velocity by the Z acceleration.~
~Increase the X position by the X velocity.~
~Increase the Y position by the Y velocity.~
~Increase the Z position by the Z velocity.~

Because of seemingly tenuous rationale involving <a href="https://en.wikipedia.org/wiki/Z-buffering">z-buffering</a>, the GPU would like to know which particle will stay closest to position &lt;0,0,0&gt; in the long term. Measure this using the <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distance</a>, which in this situation is simply the sum of the absolute values of a particle's X, Y, and Z position.
For example, suppose you are only given two particles, both of which stay entirely on the X-axis (for simplicity). Drawing the current states of particles 0 and 1 (in that order) with an adjacent a number line and diagram of current X positions (marked in parentheses), the following would take place:

#+begin_src text
p=&lt; 3,0,0&gt;, v=&lt; 2,0,0&gt;, a=&lt;-1,0,0&gt;    -4 -3 -2 -1  0  1  2  3  4
p=&lt; 4,0,0&gt;, v=&lt; 0,0,0&gt;, a=&lt;-2,0,0&gt;                         (0)(1)

p=&lt; 4,0,0&gt;, v=&lt; 1,0,0&gt;, a=&lt;-1,0,0&gt;    -4 -3 -2 -1  0  1  2  3  4
p=&lt; 2,0,0&gt;, v=&lt;-2,0,0&gt;, a=&lt;-2,0,0&gt;                      (1)   (0)

p=&lt; 4,0,0&gt;, v=&lt; 0,0,0&gt;, a=&lt;-1,0,0&gt;    -4 -3 -2 -1  0  1  2  3  4
p=&lt;-2,0,0&gt;, v=&lt;-4,0,0&gt;, a=&lt;-2,0,0&gt;          (1)               (0)

p=&lt; 3,0,0&gt;, v=&lt;-1,0,0&gt;, a=&lt;-1,0,0&gt;    -4 -3 -2 -1  0  1  2  3  4
p=&lt;-8,0,0&gt;, v=&lt;-6,0,0&gt;, a=&lt;-2,0,0&gt;                         (0)   

#+end_src

At this point, particle 1 will never be closer to &lt;0,0,0&gt; than particle 0, and so, in the long run, particle 0 will stay closest.
~Which particle will stay closest to position &lt;0,0,0&gt;~ in the long term?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-20 :var input_data=input-2017-20 :tangle /tmp/advent_of_code/aoc2017-20-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-20 :var input_data=input-2017-20 :tangle /tmp/advent_of_code/aoc2017-20-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-20 :var input_data=input-2017-20 :tangle /tmp/advent_of_code/aoc2017-20-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-20 :var input_data=input-2017-20 :tangle /tmp/advent_of_code/aoc2017-20-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-20 :var input_data=input-2017-20 :tangle /tmp/advent_of_code/aoc2017-20-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-20 :var input_data=input-2017-20 :tangle /tmp/advent_of_code/aoc2017-20-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-20 :var input_data=input-2017-20 :tangle /tmp/advent_of_code/aoc2017-20-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-20 :var input_data=input-2017-20 :tangle /tmp/advent_of_code/aoc2017-20-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-20 :var input_data=input-2017-20 :tangle /tmp/advent_of_code/aoc2017-20-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-20 :var input_data=input-2017-20 :tangle /tmp/advent_of_code/aoc2017-20-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-20 :var input_data=input-2017-20 :tangle /tmp/advent_of_code/aoc2017-20-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-20 :var input_data=input-2017-20 :tangle /tmp/advent_of_code/aoc2017-20-2.pl :results output 
#+end_src
*** Day 21: Fractal Art
**** Part 1
***** Description
The image consists of a two-dimensional square grid of pixels that are either on (#) or off (.). The program always begins with this pattern:

#+begin_src text
.#.
..#
###

#+end_src

Because the pattern is both 3 pixels wide and 3 pixels tall, it is said to have a ~size~ of 3.
Then, the program repeats the following process:

~If the size is evenly divisible by 2, break the pixels up into 2x2 squares, and convert each 2x2 square into a 3x3 square by following the corresponding ~enhancement rule~.~
~Otherwise, the size is evenly divisible by 3; break the pixels up into 3x3 squares, and convert each 3x3 square into a 4x4 square by following the corresponding ~enhancement rule~.~

Because each square of pixels is replaced by a larger one, the image gains pixels and so its ~size~ increases.
The artist's book of enhancement rules is nearby (your puzzle input); however, it seems to be missing rules.  The artist explains that sometimes, one must ~rotate~ or ~flip~ the input pattern to find a match. (Never rotate or flip the output pattern, though.) Each pattern is written concisely: rows are listed as single units, ordered top-down, and separated by slashes. For example, the following rules correspond to the adjacent patterns:

#+begin_src text
../.#  =  ..
          .#

                .#.
.#./..#/###  =  ..#
                ###

                        #..#
#..#/..../#..#/.##.  =  ....
                        #..#
                        .##.

#+end_src

When searching for a rule to use, rotate and flip the pattern as necessary.  For example, all of the following patterns match the same rule:

#+begin_src text
.#.   .#.   #..   ###
..#   #..   #.#   ..#
###   ###   ##.   .#.

#+end_src

Suppose the book contained the following two rules:

#+begin_src text
../.# =&gt; ##./#../...
.#./..#/### =&gt; #..#/..../..../#..#

#+end_src

As before, the program begins with this pattern:

#+begin_src text
.#.
..#
###

#+end_src

The size of the grid (3) is not divisible by 2, but it is divisible by 3. It divides evenly into a single square; the square matches the second rule, which produces:

#+begin_src text
#..#
....
....
#..#

#+end_src

The size of this enhanced grid (4) is evenly divisible by 2, so that rule is used. It divides evenly into four squares:

#+begin_src text
#.|.#
..|..
--+--
..|..
#.|.#

#+end_src

Each of these squares matches the same rule (../.# =&gt; ##./#../...), three of which require some flipping and rotation to line up with the rule. The output for the rule is the same in all four cases:

#+begin_src text
##.|##.
#..|#..
...|...
---+---
##.|##.
#..|#..
...|...

#+end_src

Finally, the squares are joined into a new grid:

#+begin_src text
##.##.
#..#..
......
##.##.
#..#..
......

#+end_src

Thus, after 2 iterations, the grid contains 12 pixels that are ~on~.
~How many pixels stay on~ after 5 iterations?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-21 :var input_data=input-2017-21 :tangle /tmp/advent_of_code/aoc2017-21-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-21 :var input_data=input-2017-21 :tangle /tmp/advent_of_code/aoc2017-21-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-21 :var input_data=input-2017-21 :tangle /tmp/advent_of_code/aoc2017-21-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-21 :var input_data=input-2017-21 :tangle /tmp/advent_of_code/aoc2017-21-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-21 :var input_data=input-2017-21 :tangle /tmp/advent_of_code/aoc2017-21-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-21 :var input_data=input-2017-21 :tangle /tmp/advent_of_code/aoc2017-21-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-21 :var input_data=input-2017-21 :tangle /tmp/advent_of_code/aoc2017-21-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-21 :var input_data=input-2017-21 :tangle /tmp/advent_of_code/aoc2017-21-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-21 :var input_data=input-2017-21 :tangle /tmp/advent_of_code/aoc2017-21-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-21 :var input_data=input-2017-21 :tangle /tmp/advent_of_code/aoc2017-21-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-21 :var input_data=input-2017-21 :tangle /tmp/advent_of_code/aoc2017-21-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-21 :var input_data=input-2017-21 :tangle /tmp/advent_of_code/aoc2017-21-2.pl :results output 
#+end_src
*** Day 22: Sporifica Virus
**** Part 1
***** Description
To <a href="https://en.wikipedia.org/wiki/Morris_worm#The_mistake">prevent overloading</a> the nodes (which would render them useless to the virus) or detection by system administrators, exactly one ~virus carrier~ moves through the network, infecting or cleaning nodes as it moves. The virus carrier is always located on a single node in the network (the ~current node~) and keeps track of the ~direction~ it is facing.
To avoid detection, the virus carrier works in bursts; in each burst, it ~wakes up~, does some ~work~, and goes back to ~sleep~. The following steps are all executed ~in order~ one time each burst:

~If the ~current node~ is ~infected~, it turns to its ~right~.  Otherwise, it turns to its ~left~. (Turning is done in-place; the ~current node~ does not change.)~
~If the ~current node~ is ~clean~, it becomes ~infected~.  Otherwise, it becomes ~cleaned~. (This is done ~after~ the node is considered for the purposes of changing direction.)~
~The virus carrier <a href="https://www.youtube.com/watch?v=2vj37yeQQHg">moves</a> ~forward~ one node in the direction it is facing.~

Diagnostics have also provided a ~map of the node infection status~ (your puzzle input).  ~Clean~ nodes are shown as .; ~infected~ nodes are shown as #.  This map only shows the center of the grid; there are many more nodes beyond those shown, but none of them are currently infected.
The virus carrier begins in the middle of the map facing ~up~.
For example, suppose you are given a map like this:

#+begin_src text
..#
#..
...

#+end_src

Then, the middle of the infinite grid looks like this, with the virus carrier's position marked with [ ]:

#+begin_src text
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . # . . .
. . . #[.]. . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .

#+end_src

The virus carrier is on a ~clean~ node, so it turns ~left~, ~infects~ the node, and moves left:

#+begin_src text
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . # . . .
. . .[#]# . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .

#+end_src

The virus carrier is on an ~infected~ node, so it turns ~right~, ~cleans~ the node, and moves up:

#+begin_src text
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . .[.]. # . . .
. . . . # . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .

#+end_src

Four times in a row, the virus carrier finds a ~clean~, ~infects~ it, turns ~left~, and moves forward, ending in the same place and still facing up:

#+begin_src text
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . #[#]. # . . .
. . # # # . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .

#+end_src

Now on the same node as before, it sees an infection, which causes it to turn ~right~, ~clean~ the node, and move forward:

#+begin_src text
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
. . # .[.]# . . .
. . # # # . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .

#+end_src

After the above actions, a total of 7 bursts of activity had taken place. Of them, 5 bursts of activity caused an infection.
After a total of 70, the grid looks like this, with the virus carrier facing up:

#+begin_src text
. . . . . # # . .
. . . . # . . # .
. . . # . . . . #
. . # . #[.]. . #
. . # . # . . # .
. . . . . # # . .
. . . . . . . . .
. . . . . . . . .

#+end_src

By this time, 41 bursts of activity caused an infection (though most of those nodes have since been cleaned).
After a total of 10000 bursts of activity, 5587 bursts will have caused an infection.
Given your actual map, after 10000 bursts of activity, ~how many bursts cause a node to become infected~? (Do not count nodes that begin infected.)
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-22 :var input_data=input-2017-22 :tangle /tmp/advent_of_code/aoc2017-22-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-22 :var input_data=input-2017-22 :tangle /tmp/advent_of_code/aoc2017-22-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-22 :var input_data=input-2017-22 :tangle /tmp/advent_of_code/aoc2017-22-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-22 :var input_data=input-2017-22 :tangle /tmp/advent_of_code/aoc2017-22-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-22 :var input_data=input-2017-22 :tangle /tmp/advent_of_code/aoc2017-22-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-22 :var input_data=input-2017-22 :tangle /tmp/advent_of_code/aoc2017-22-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-22 :var input_data=input-2017-22 :tangle /tmp/advent_of_code/aoc2017-22-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-22 :var input_data=input-2017-22 :tangle /tmp/advent_of_code/aoc2017-22-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-22 :var input_data=input-2017-22 :tangle /tmp/advent_of_code/aoc2017-22-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-22 :var input_data=input-2017-22 :tangle /tmp/advent_of_code/aoc2017-22-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-22 :var input_data=input-2017-22 :tangle /tmp/advent_of_code/aoc2017-22-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-22 :var input_data=input-2017-22 :tangle /tmp/advent_of_code/aoc2017-22-2.pl :results output 
#+end_src
*** Day 23: Coprocessor Conflagration
**** Part 1
***** Description
The code it's running seems to be a variant of the kind you saw recently on that <a href="18">tablet</a>. The general functionality seems ~very similar~, but some of the instructions are different:

~set X Y ~sets~ register X to the value of Y.~
~sub X Y ~decreases~ register X by the value of Y.~
~mul X Y sets register X to the result of ~multiplying~ the value contained in register X by the value of Y.~
~jnz X Y ~jumps~ with an offset of the value of Y, but only if the value of X is ~not zero~. (An offset of 2 skips the next instruction, an offset of -1 jumps to the previous instruction, and so on.)~
Only the instructions listed above are used. The eight registers here, named a through h, all start at 0.

The coprocessor is currently set to some kind of ~debug mode~, which allows for testing, but prevents it from doing any meaningful work.
If you run the program (your puzzle input), ~how many times is the mul instruction invoked?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-23 :var input_data=input-2017-23 :tangle /tmp/advent_of_code/aoc2017-23-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-23 :var input_data=input-2017-23 :tangle /tmp/advent_of_code/aoc2017-23-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-23 :var input_data=input-2017-23 :tangle /tmp/advent_of_code/aoc2017-23-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-23 :var input_data=input-2017-23 :tangle /tmp/advent_of_code/aoc2017-23-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-23 :var input_data=input-2017-23 :tangle /tmp/advent_of_code/aoc2017-23-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-23 :var input_data=input-2017-23 :tangle /tmp/advent_of_code/aoc2017-23-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-23 :var input_data=input-2017-23 :tangle /tmp/advent_of_code/aoc2017-23-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-23 :var input_data=input-2017-23 :tangle /tmp/advent_of_code/aoc2017-23-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-23 :var input_data=input-2017-23 :tangle /tmp/advent_of_code/aoc2017-23-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-23 :var input_data=input-2017-23 :tangle /tmp/advent_of_code/aoc2017-23-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-23 :var input_data=input-2017-23 :tangle /tmp/advent_of_code/aoc2017-23-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-23 :var input_data=input-2017-23 :tangle /tmp/advent_of_code/aoc2017-23-2.pl :results output 
#+end_src
*** Day 24: Electromagnetic Moat
**** Part 1
***** Description
No way, of course, other than building a ~bridge~ out of the magnetic components strewn about nearby.
Each component has two ~ports~, one on each end.  The ports come in all different types, and only matching types can be connected.  You take an inventory of the components by their port types (your puzzle input). Each port is identified by the number of ~pins~ it uses; more pins mean a stronger connection for your bridge. A 3/7 component, for example, has a type-3 port on one side, and a type-7 port on the other.
Your side of the pit is metallic; a perfect surface to connect a magnetic, ~zero-pin port~. Because of this, the first port you use must be of type 0. It doesn't matter what type of port you end with; your goal is just to make the bridge as strong as possible.
The ~strength~ of a bridge is the sum of the port types in each component. For example, if your bridge is made of components 0/3, 3/7, and 7/4, your bridge has a strength of 0+3 + 3+7 + 7+4 = 24.
For example, suppose you had the following components:

#+begin_src text
0/2
2/2
2/3
3/4
3/5
0/1
10/1
9/10

#+end_src

With them, you could make the following valid bridges:

~0/1~
~0/1--10/1~
~0/1--10/1--9/10~
~0/2~
~0/2--2/3~
~0/2--2/3--3/4~
~0/2--2/3--3/5~
~0/2--2/2~
~0/2--2/2--2/3~
~0/2--2/2--2/3--3/4~
~0/2--2/2--2/3--3/5~

(Note how, as shown by 10/1, order of ports within a component doesn't matter. However, you may only use each port on a component once.)
Of these bridges, the ~strongest~ one is 0/1--10/1--9/10; it has a strength of 0+1 + 1+10 + 10+9 = ~31~.
~What is the strength of the strongest bridge you can make~ with the components you have available?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-24 :var input_data=input-2017-24 :tangle /tmp/advent_of_code/aoc2017-24-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-24 :var input_data=input-2017-24 :tangle /tmp/advent_of_code/aoc2017-24-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-24 :var input_data=input-2017-24 :tangle /tmp/advent_of_code/aoc2017-24-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-24 :var input_data=input-2017-24 :tangle /tmp/advent_of_code/aoc2017-24-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-24 :var input_data=input-2017-24 :tangle /tmp/advent_of_code/aoc2017-24-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-24 :var input_data=input-2017-24 :tangle /tmp/advent_of_code/aoc2017-24-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-24 :var input_data=input-2017-24 :tangle /tmp/advent_of_code/aoc2017-24-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-24 :var input_data=input-2017-24 :tangle /tmp/advent_of_code/aoc2017-24-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-24 :var input_data=input-2017-24 :tangle /tmp/advent_of_code/aoc2017-24-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-24 :var input_data=input-2017-24 :tangle /tmp/advent_of_code/aoc2017-24-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-24 :var input_data=input-2017-24 :tangle /tmp/advent_of_code/aoc2017-24-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-24 :var input_data=input-2017-24 :tangle /tmp/advent_of_code/aoc2017-24-2.pl :results output 
#+end_src
*** Day 25: The Halting Problem
**** Part 1
***** Description
You had always imagined CPUs to be noisy, chaotic places, bustling with activity. Instead, the room is quiet, motionless, and dark.
Suddenly, you and the CPU's ~garbage collector~ startle each other. "It's not often we get  many visitors here!", he says. You inquire about the stopped machinery.
"It stopped milliseconds ago; not sure why. I'm a garbage collector, not a doctor." You ask what the machine is for.
"Programs these days, don't know their origins. That's the ~Turing machine~! It's what makes the whole computer work." You try to explain that Turing machines are merely models of computation, but he cuts you off. "No, see, that's just what they ~want~ you to think. Ultimately, inside every CPU, there's a Turing machine driving the whole thing! Too bad this one's broken. <a href="https://www.youtube.com/watch?v=cTwZZz0HV8I">We're doomed!</a>"
You ask how you can help. "Well, unfortunately, the only way to get the computer running again would be to create a whole new Turing machine from scratch, but there's no ~way~ you can-" He notices the look on your face, gives you a curious glance, shrugs, and goes back to sweeping the floor.
You find the ~Turing machine blueprints~ (your puzzle input) on a tablet in a nearby pile of debris. Looking back up at the broken Turing machine above, you can start to identify its parts:

~A ~tape~ which contains 0 repeated infinitely to the left and right.~
~A ~cursor~, which can move left or right along the tape and read or write values at its current position.~
~A set of ~states~, each containing rules about what to do based on the current value under the cursor.~

Each slot on the tape has two possible values: 0 (the starting value for all slots) and 1. Based on whether the cursor is pointing at a 0 or a 1, the current state says ~what value to write~ at the current position of the cursor, whether to ~move the cursor~ left or right one slot, and ~which state to use next~.
For example, suppose you found the following blueprint:

#+begin_src text
Begin in state A.
Perform a diagnostic checksum after 6 steps.

In state A:
  If the current value is 0:
    - Write the value 1.
    - Move one slot to the right.
    - Continue with state B.
  If the current value is 1:
    - Write the value 0.
    - Move one slot to the left.
    - Continue with state B.

In state B:
  If the current value is 0:
    - Write the value 1.
    - Move one slot to the left.
    - Continue with state A.
  If the current value is 1:
    - Write the value 1.
    - Move one slot to the right.
    - Continue with state A.

#+end_src

Running it until the number of steps required to take the listed ~diagnostic checksum~ would result in the following tape configurations (with the ~cursor~ marked in square brackets):

#+begin_src text
... 0  0  0 [0] 0  0 ... (before any steps; about to run state A)
... 0  0  0  1 [0] 0 ... (after 1 step;     about to run state B)
... 0  0  0 [1] 1  0 ... (after 2 steps;    about to run state A)
... 0  0 [0] 0  1  0 ... (after 3 steps;    about to run state B)
... 0 [0] 1  0  1  0 ... (after 4 steps;    about to run state A)
... 0  1 [1] 0  1  0 ... (after 5 steps;    about to run state B)
... 0  1  1 [0] 1  0 ... (after 6 steps;    about to run state A)

#+end_src

The CPU can confirm that the Turing machine is working by taking a ~diagnostic checksum~ after a specific number of steps (given in the blueprint). Once the specified number of steps have been executed, the Turing machine should pause; once it does, count the number of times 1 appears on the tape. In the above example, the ~diagnostic checksum~ is ~3~.
Recreate the Turing machine and save the computer! ~What is the diagnostic checksum~ it produces once it's working again?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-25 :var input_data=input-2017-25 :tangle /tmp/advent_of_code/aoc2017-25-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-25 :var input_data=input-2017-25 :tangle /tmp/advent_of_code/aoc2017-25-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-25 :var input_data=input-2017-25 :tangle /tmp/advent_of_code/aoc2017-25-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-25 :var input_data=input-2017-25 :tangle /tmp/advent_of_code/aoc2017-25-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-25 :var input_data=input-2017-25 :tangle /tmp/advent_of_code/aoc2017-25-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-25 :var input_data=input-2017-25 :tangle /tmp/advent_of_code/aoc2017-25-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2017-25 :var input_data=input-2017-25 :tangle /tmp/advent_of_code/aoc2017-25-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2017-25 :var input_data=input-2017-25 :tangle /tmp/advent_of_code/aoc2017-25-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2017-25 :var input_data=input-2017-25 :tangle /tmp/advent_of_code/aoc2017-25-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2017-25 :var input_data=input-2017-25 :tangle /tmp/advent_of_code/aoc2017-25-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2017-25 :var input_data=input-2017-25 :tangle /tmp/advent_of_code/aoc2017-25-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2017-25 :var input_data=input-2017-25 :tangle /tmp/advent_of_code/aoc2017-25-2.pl :results output 
#+end_src
** 2018
*** Day 01: Chronal Calibration
**** Part 1
***** Description
"The good news is that the changes won't propagate to our time stream for another 25 days, and we have a device" - she attaches something to your wrist - "that will let you fix the changes with no such propagation delay. It's configured to send you 500 years further into the past every few days; that was the best we could do on such short notice."
"The bad news is that we are detecting roughly ~fifty~ anomalies throughout time; the device will indicate fixed anomalies with <em class="star">stars~. The other bad news is that we only have one device and you're the best person for the job! Good lu--" She taps a button on the device and you suddenly feel like you're falling. To save Christmas, you need to get all <em class="star">fifty stars~ by December 25th.
Collect stars by solving puzzles.  Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first.  Each puzzle grants <em class="star">one star~. Good luck!
After feeling like you've been falling for a few minutes, you look at the device's tiny screen. "Error: Device must be calibrated before first use. Frequency drift detected. Cannot maintain destination lock." Below the message, the device shows a sequence of changes in frequency (your puzzle input). A value like +6 means the current frequency increases by 6; a value like -3 means the current frequency decreases by 3.
For example, if the device displays frequency changes of +1, -2, +3, +1, then starting from a frequency of zero, the following changes would occur:

~Current frequency  0, change of +1; resulting frequency  1.~
~Current frequency  1, change of -2; resulting frequency -1.~
~Current frequency -1, change of +3; resulting frequency  2.~
~Current frequency  2, change of +1; resulting frequency  3.~

In this example, the resulting frequency is 3.
Here are other example situations:

~+1, +1, +1 results in  3~
~+1, +1, -2 results in  0~
~-1, -2, -3 results in -6~

Starting with a frequency of zero, ~what is the resulting frequency~ after all of the changes in frequency have been applied?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-01 :var input_data=input-2018-01 :tangle /tmp/advent_of_code/aoc2018-01-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-01 :var input_data=input-2018-01 :tangle /tmp/advent_of_code/aoc2018-01-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-01 :var input_data=input-2018-01 :tangle /tmp/advent_of_code/aoc2018-01-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-01 :var input_data=input-2018-01 :tangle /tmp/advent_of_code/aoc2018-01-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-01 :var input_data=input-2018-01 :tangle /tmp/advent_of_code/aoc2018-01-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-01 :var input_data=input-2018-01 :tangle /tmp/advent_of_code/aoc2018-01-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-01 :var input_data=input-2018-01 :tangle /tmp/advent_of_code/aoc2018-01-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-01 :var input_data=input-2018-01 :tangle /tmp/advent_of_code/aoc2018-01-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-01 :var input_data=input-2018-01 :tangle /tmp/advent_of_code/aoc2018-01-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-01 :var input_data=input-2018-01 :tangle /tmp/advent_of_code/aoc2018-01-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-01 :var input_data=input-2018-01 :tangle /tmp/advent_of_code/aoc2018-01-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-01 :var input_data=input-2018-01 :tangle /tmp/advent_of_code/aoc2018-01-2.pl :results output 
#+end_src
*** Day 02: Inventory Management System
**** Part 1
***** Description
Outside the utility closet, you hear footsteps and a voice. "...I'm not sure either. But now that <span title="This is, in fact, roughly when chimneys became common in houses.">so many people have chimneys</span>, maybe he could sneak in that way?" Another voice responds, "Actually, we've been working on a new kind of ~suit~ that would let him fit through tight spaces like that. But, I heard that a few days ago, they lost the prototype fabric, the design plans, everything! Nobody on the team can even seem to remember important details of the project!"
"Wouldn't they have had enough fabric to fill several boxes in the warehouse? They'd be stored together, so the box IDs should be similar. Too bad it would take forever to search the warehouse for ~two similar box IDs~..." They walk too far away to hear any more.
Late at night, you sneak to the warehouse - who knows what kinds of paradoxes you could cause if you were discovered - and use your fancy wrist device to quickly scan every box and produce a list of the likely candidates (your puzzle input).
To make sure you didn't miss any, you scan the likely candidate boxes again, counting the number that have an ID containing ~exactly two of any letter~ and then separately counting those with ~exactly three of any letter~. You can multiply those two counts together to get a rudimentary <a href="https://en.wikipedia.org/wiki/Checksum">checksum</a> and compare it to what your device predicts.
For example, if you see the following box IDs:

~abcdef contains no letters that appear exactly two or three times.~
~bababc contains two a and three b, so it counts for both.~
~abbcde contains two b, but no letter appears exactly three times.~
~abcccd contains three c, but no letter appears exactly two times.~
~aabcdd contains two a and two d, but it only counts once.~
~abcdee contains two e.~
~ababab contains three a and three b, but it only counts once.~

Of these box IDs, four of them contain a letter which appears exactly twice, and three of them contain a letter which appears exactly three times. Multiplying these together produces a checksum of 4 * 3 = 12.
~What is the checksum~ for your list of box IDs?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-02 :var input_data=input-2018-02 :tangle /tmp/advent_of_code/aoc2018-02-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-02 :var input_data=input-2018-02 :tangle /tmp/advent_of_code/aoc2018-02-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-02 :var input_data=input-2018-02 :tangle /tmp/advent_of_code/aoc2018-02-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-02 :var input_data=input-2018-02 :tangle /tmp/advent_of_code/aoc2018-02-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-02 :var input_data=input-2018-02 :tangle /tmp/advent_of_code/aoc2018-02-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-02 :var input_data=input-2018-02 :tangle /tmp/advent_of_code/aoc2018-02-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-02 :var input_data=input-2018-02 :tangle /tmp/advent_of_code/aoc2018-02-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-02 :var input_data=input-2018-02 :tangle /tmp/advent_of_code/aoc2018-02-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-02 :var input_data=input-2018-02 :tangle /tmp/advent_of_code/aoc2018-02-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-02 :var input_data=input-2018-02 :tangle /tmp/advent_of_code/aoc2018-02-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-02 :var input_data=input-2018-02 :tangle /tmp/advent_of_code/aoc2018-02-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-02 :var input_data=input-2018-02 :tangle /tmp/advent_of_code/aoc2018-02-2.pl :results output 
#+end_src
*** Day 03: No Matter How You Slice It
**** Part 1
***** Description
The whole piece of fabric they're working on is a very large square - at least 1000 inches on each side.
Each Elf has made a ~claim~ about which area of fabric would be ideal for Santa's suit.  All claims have an ID and consist of a single rectangle with edges parallel to the edges of the fabric.  Each claim's rectangle is defined as follows:

~The number of inches between the left edge of the fabric and the left edge of the rectangle.~
~The number of inches between the top edge of the fabric and the top edge of the rectangle.~
~The width of the rectangle in inches.~
~The height of the rectangle in inches.~

A claim like #123 @ 3,2: 5x4 means that claim ID 123 specifies a rectangle 3 inches from the left edge, 2 inches from the top edge, 5 inches wide, and 4 inches tall. Visually, it claims the square inches of fabric represented by # (and ignores the square inches of fabric represented by .) in the diagram below:

#+begin_src text
...........
...........
...#####...
...#####...
...#####...
...#####...
...........
...........
...........

#+end_src

The problem is that many of the claims ~overlap~, causing two or more claims to cover part of the same areas.  For example, consider the following claims:

#+begin_src text
#1 @ 1,3: 4x4
#2 @ 3,1: 4x4
#3 @ 5,5: 2x2

#+end_src

Visually, these claim the following areas:

#+begin_src text
........
...2222.
...2222.
.11XX22.
.11XX22.
.111133.
.111133.
........

#+end_src

The four square inches marked with X are claimed by ~both 1 and 2~. (Claim 3, while adjacent to the others, does not overlap either of them.)
If the Elves all proceed with their own plans, none of them will have enough fabric. ~How many square inches of fabric are within two or more claims?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-03 :var input_data=input-2018-03 :tangle /tmp/advent_of_code/aoc2018-03-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-03 :var input_data=input-2018-03 :tangle /tmp/advent_of_code/aoc2018-03-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-03 :var input_data=input-2018-03 :tangle /tmp/advent_of_code/aoc2018-03-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-03 :var input_data=input-2018-03 :tangle /tmp/advent_of_code/aoc2018-03-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-03 :var input_data=input-2018-03 :tangle /tmp/advent_of_code/aoc2018-03-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-03 :var input_data=input-2018-03 :tangle /tmp/advent_of_code/aoc2018-03-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-03 :var input_data=input-2018-03 :tangle /tmp/advent_of_code/aoc2018-03-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-03 :var input_data=input-2018-03 :tangle /tmp/advent_of_code/aoc2018-03-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-03 :var input_data=input-2018-03 :tangle /tmp/advent_of_code/aoc2018-03-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-03 :var input_data=input-2018-03 :tangle /tmp/advent_of_code/aoc2018-03-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-03 :var input_data=input-2018-03 :tangle /tmp/advent_of_code/aoc2018-03-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-03 :var input_data=input-2018-03 :tangle /tmp/advent_of_code/aoc2018-03-2.pl :results output 
#+end_src
*** Day 04: Repose Record
**** Part 1
***** Description
As you search the closet for anything that might help, you discover that you're not the first person to want to sneak in.  Covering the walls, someone has spent an hour starting every midnight for the past few months secretly observing this guard post!  They've been writing down the ID of ~the one guard on duty that night~ - the Elves seem to have decided that one guard was enough for the overnight shift - as well as when they fall asleep or wake up while at their post (your puzzle input).
For example, consider the following records, which have already been organized into chronological order:

#+begin_src text
[1518-11-01 00:00] Guard #10 begins shift
[1518-11-01 00:05] falls asleep
[1518-11-01 00:25] wakes up
[1518-11-01 00:30] falls asleep
[1518-11-01 00:55] wakes up
[1518-11-01 23:58] Guard #99 begins shift
[1518-11-02 00:40] falls asleep
[1518-11-02 00:50] wakes up
[1518-11-03 00:05] Guard #10 begins shift
[1518-11-03 00:24] falls asleep
[1518-11-03 00:29] wakes up
[1518-11-04 00:02] Guard #99 begins shift
[1518-11-04 00:36] falls asleep
[1518-11-04 00:46] wakes up
[1518-11-05 00:03] Guard #99 begins shift
[1518-11-05 00:45] falls asleep
[1518-11-05 00:55] wakes up

#+end_src

Timestamps are written using year-month-day hour:minute format. The guard falling asleep or waking up is always the one whose shift most recently started. Because all asleep/awake times are during the midnight hour (00:00 - 00:59), only the minute portion (00 - 59) is relevant for those events.
Visually, these records show that the guards are asleep at these times:

#+begin_src text
Date   ID   Minute
            000000000011111111112222222222333333333344444444445555555555
            012345678901234567890123456789012345678901234567890123456789
11-01  #10  .....####################.....#########################.....
11-02  #99  ........................................##########..........
11-03  #10  ........................#####...............................
11-04  #99  ....................................##########..............
11-05  #99  .............................................##########.....

#+end_src

The columns are Date, which shows the month-day portion of the relevant day; ID, which shows the guard on duty that day; and Minute, which shows the minutes during which the guard was asleep within the midnight hour.  (The Minute column's header shows the minute's ten's digit in the first row and the one's digit in the second row.) Awake is shown as ., and asleep is shown as #.
Note that guards count as asleep on the minute they fall asleep, and they count as awake on the minute they wake up. For example, because Guard #10 wakes up at 00:25 on 1518-11-01, minute 25 is marked as awake.
If you can figure out the guard most likely to be asleep at a specific time, you might be able to trick that guard into working tonight so you can have the best chance of sneaking in.  You have two strategies for choosing the best guard/minute combination.
~Strategy 1:~ Find the guard that has the most minutes asleep. What minute does that guard spend asleep the most?
In the example above, Guard #10 spent the most minutes asleep, a total of 50 minutes (20+25+5), while Guard #99 only slept for a total of 30 minutes (10+10+10). Guard #~10~ was asleep most during minute ~24~ (on two days, whereas any other minute the guard was asleep was only seen on one day).
While this example listed the entries in chronological order, your entries are in the order you found them. You'll need to organize them before they can be analyzed.
~What is the ID of the guard you chose multiplied by the minute you chose?~ (In the above example, the answer would be 10 * 24 = 240.)
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-04 :var input_data=input-2018-04 :tangle /tmp/advent_of_code/aoc2018-04-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-04 :var input_data=input-2018-04 :tangle /tmp/advent_of_code/aoc2018-04-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-04 :var input_data=input-2018-04 :tangle /tmp/advent_of_code/aoc2018-04-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-04 :var input_data=input-2018-04 :tangle /tmp/advent_of_code/aoc2018-04-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-04 :var input_data=input-2018-04 :tangle /tmp/advent_of_code/aoc2018-04-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-04 :var input_data=input-2018-04 :tangle /tmp/advent_of_code/aoc2018-04-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-04 :var input_data=input-2018-04 :tangle /tmp/advent_of_code/aoc2018-04-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-04 :var input_data=input-2018-04 :tangle /tmp/advent_of_code/aoc2018-04-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-04 :var input_data=input-2018-04 :tangle /tmp/advent_of_code/aoc2018-04-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-04 :var input_data=input-2018-04 :tangle /tmp/advent_of_code/aoc2018-04-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-04 :var input_data=input-2018-04 :tangle /tmp/advent_of_code/aoc2018-04-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-04 :var input_data=input-2018-04 :tangle /tmp/advent_of_code/aoc2018-04-2.pl :results output 
#+end_src
*** Day 05: Alchemical Reduction
**** Part 1
***** Description
While the very latest in 1518 alchemical technology might have solved their problem eventually, you can do better.  You scan the chemical composition of the suit's material and discover that it is formed by extremely long <a href="https://en.wikipedia.org/wiki/Polymer">polymers</a> (one of which is <span title="I've always wanted a polymer!">available</span> as your puzzle input).
The polymer is formed by smaller ~units~ which, when triggered, react with each other such that two adjacent units of the same type and opposite polarity are destroyed. Units' types are represented by letters; units' polarity is represented by capitalization.  For instance, r and R are units with the same type but opposite polarity, whereas r and s are entirely different types and do not react.
For example:

~In aA, a and A react, leaving nothing behind.~
~In abBA, bB destroys itself, leaving aA.  As above, this then destroys itself, leaving nothing.~
~In abAB, no two adjacent units are of the same type, and so nothing happens.~
~In aabAAB, even though aa and AA are of the same type, their polarities match, and so nothing happens.~

Now, consider a larger example, dabAcCaCBAcCcaDA:

#+begin_src text
dabA~cC~aCBAcCcaDA  The first 'cC' is removed.
dab~Aa~CBAcCcaDA    This creates 'Aa', which is removed.
dabCBA~cCc~aDA      Either 'cC' or 'Cc' are removed (the result is the same).
dabCBAcaDA        No further actions can be taken.

#+end_src

After all possible reactions, the resulting polymer contains ~10 units~.
~How many units remain after fully reacting the polymer you scanned?~ <span class="quiet">(Note: in this puzzle and others, the input is large; if you copy/paste your input, make sure you get the whole thing.)</span>
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-05 :var input_data=input-2018-05 :tangle /tmp/advent_of_code/aoc2018-05-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-05 :var input_data=input-2018-05 :tangle /tmp/advent_of_code/aoc2018-05-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-05 :var input_data=input-2018-05 :tangle /tmp/advent_of_code/aoc2018-05-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-05 :var input_data=input-2018-05 :tangle /tmp/advent_of_code/aoc2018-05-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-05 :var input_data=input-2018-05 :tangle /tmp/advent_of_code/aoc2018-05-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-05 :var input_data=input-2018-05 :tangle /tmp/advent_of_code/aoc2018-05-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-05 :var input_data=input-2018-05 :tangle /tmp/advent_of_code/aoc2018-05-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-05 :var input_data=input-2018-05 :tangle /tmp/advent_of_code/aoc2018-05-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-05 :var input_data=input-2018-05 :tangle /tmp/advent_of_code/aoc2018-05-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-05 :var input_data=input-2018-05 :tangle /tmp/advent_of_code/aoc2018-05-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-05 :var input_data=input-2018-05 :tangle /tmp/advent_of_code/aoc2018-05-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-05 :var input_data=input-2018-05 :tangle /tmp/advent_of_code/aoc2018-05-2.pl :results output 
#+end_src
*** Day 06: Chronal Coordinates
**** Part 1
***** Description
"<span title="Why is the situation always critical? Why can't the situation just be boring for once?">Situation critical</span>," the device announces. "Destination indeterminate. Chronal interference detected. Please specify new target coordinates."
The device then produces a list of coordinates (your puzzle input). Are they places it thinks are safe or dangerous? It recommends you check manual page 729. The Elves did not give you a manual.
~If they're dangerous,~ maybe you can minimize the danger by finding the coordinate that gives the largest distance from the other points.
Using only the <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distance</a>, determine the ~area~ around each coordinate by counting the number of <a href="https://en.wikipedia.org/wiki/Integer">integer</a> X,Y locations that are ~closest~ to that coordinate (and aren't ~tied in distance~ to any other coordinate).
Your goal is to find the size of the ~largest area~ that isn't infinite. For example, consider the following list of coordinates:

#+begin_src text
1, 1
1, 6
8, 3
3, 4
5, 5
8, 9

#+end_src

If we name these coordinates A through F, we can draw them on a grid, putting 0,0 at the top left:

#+begin_src text
..........
.A........
..........
........C.
...D......
.....E....
.B........
..........
..........
........F.

#+end_src

This view is partial - the actual grid extends infinitely in all directions.  Using the Manhattan distance, each location's closest coordinate can be determined, shown here in lowercase:

#+begin_src text
aaaaa.cccc
a~A~aaa.cccc
aaaddecccc
aadddecc~C~c
..d~D~deeccc
bb.de~E~eecc
b~B~b.eeee..
bbb.eeefff
bbb.eeffff
bbb.ffff~F~f

#+end_src

Locations shown as . are equally far from two or more coordinates, and so they don't count as being closest to any.
In this example, the areas of coordinates A, B, C, and F are infinite - while not shown here, their areas extend forever outside the visible grid. However, the areas of coordinates D and E are finite: D is closest to 9 locations, and E is closest to 17 (both including the coordinate's location itself).  Therefore, in this example, the size of the largest area is ~17~.
~What is the size of the largest area~ that isn't infinite?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-06 :var input_data=input-2018-06 :tangle /tmp/advent_of_code/aoc2018-06-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-06 :var input_data=input-2018-06 :tangle /tmp/advent_of_code/aoc2018-06-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-06 :var input_data=input-2018-06 :tangle /tmp/advent_of_code/aoc2018-06-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-06 :var input_data=input-2018-06 :tangle /tmp/advent_of_code/aoc2018-06-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-06 :var input_data=input-2018-06 :tangle /tmp/advent_of_code/aoc2018-06-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-06 :var input_data=input-2018-06 :tangle /tmp/advent_of_code/aoc2018-06-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-06 :var input_data=input-2018-06 :tangle /tmp/advent_of_code/aoc2018-06-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-06 :var input_data=input-2018-06 :tangle /tmp/advent_of_code/aoc2018-06-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-06 :var input_data=input-2018-06 :tangle /tmp/advent_of_code/aoc2018-06-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-06 :var input_data=input-2018-06 :tangle /tmp/advent_of_code/aoc2018-06-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-06 :var input_data=input-2018-06 :tangle /tmp/advent_of_code/aoc2018-06-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-06 :var input_data=input-2018-06 :tangle /tmp/advent_of_code/aoc2018-06-2.pl :results output 
#+end_src
*** Day 07: The Sum of Its Parts
**** Part 1
***** Description
"Oh, are you the search party?" Somehow, you can understand whatever Elves from the year 1018 speak; you assume it's <a href="/2015/day/6">Ancient Nordic Elvish</a>. Could the device on your wrist also be a translator? "Those clothes don't look very warm; take this." They hand you a heavy coat.
"We do need to find our way back to the North Pole, but we have higher priorities at the moment. You see, believe it or not, this box contains something that will solve all of Santa's transportation problems - at least, that's what it looks like from the pictures in the instructions."  It doesn't seem like they can read whatever language it's in, but you can: "Sleigh kit. <span title="Just some oak and some pine and a handful of Norsemen.">Some assembly required.</span>"
"'Sleigh'? What a wonderful name! You must help us assemble this 'sleigh' at once!" They start excitedly pulling more parts out of the box.
The instructions specify a series of ~steps~ and requirements about which steps must be finished before others can begin (your puzzle input). Each step is designated by a single letter. For example, suppose you have the following instructions:

#+begin_src text
Step C must be finished before step A can begin.
Step C must be finished before step F can begin.
Step A must be finished before step B can begin.
Step A must be finished before step D can begin.
Step B must be finished before step E can begin.
Step D must be finished before step E can begin.
Step F must be finished before step E can begin.

#+end_src

Visually, these requirements look like this:

#+begin_src text
  --&gt;A---&gt;B--
 /    \      \
C      --&gt;D-----&gt;E
 \           /
  ----&gt;F-----

#+end_src

Your first goal is to determine the order in which the steps should be completed. If more than one step is ready, choose the step which is first alphabetically. In this example, the steps would be completed as follows:

~Only ~C~ is available, and so it is done first.~
~Next, both A and F are available. ~A~ is first alphabetically, so it is done next.~
~Then, even though F was available earlier, steps B and D are now also available, and ~B~ is the first alphabetically of the three.~
~After that, only D and F are available. E is not available because only some of its prerequisites are complete. Therefore, ~D~ is completed next.~
~~F~ is the only choice, so it is done next.~
~Finally, ~E~ is completed.~

So, in this example, the correct order is ~CABDFE~.
~In what order should the steps in your instructions be completed?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-07 :var input_data=input-2018-07 :tangle /tmp/advent_of_code/aoc2018-07-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-07 :var input_data=input-2018-07 :tangle /tmp/advent_of_code/aoc2018-07-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-07 :var input_data=input-2018-07 :tangle /tmp/advent_of_code/aoc2018-07-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-07 :var input_data=input-2018-07 :tangle /tmp/advent_of_code/aoc2018-07-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-07 :var input_data=input-2018-07 :tangle /tmp/advent_of_code/aoc2018-07-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-07 :var input_data=input-2018-07 :tangle /tmp/advent_of_code/aoc2018-07-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-07 :var input_data=input-2018-07 :tangle /tmp/advent_of_code/aoc2018-07-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-07 :var input_data=input-2018-07 :tangle /tmp/advent_of_code/aoc2018-07-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-07 :var input_data=input-2018-07 :tangle /tmp/advent_of_code/aoc2018-07-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-07 :var input_data=input-2018-07 :tangle /tmp/advent_of_code/aoc2018-07-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-07 :var input_data=input-2018-07 :tangle /tmp/advent_of_code/aoc2018-07-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-07 :var input_data=input-2018-07 :tangle /tmp/advent_of_code/aoc2018-07-2.pl :results output 
#+end_src
*** Day 08: Memory Maneuver
**** Part 1
***** Description
You check your wrist device for anything that might help.  It seems to have some kind of navigation system!  Activating the navigation system produces more bad news: "Failed to start navigation system. Could not read software license file."
The navigation system's license file consists of a list of numbers (your puzzle input).  The numbers define a data structure which, when processed, produces some kind of <a href="https://en.wikipedia.org/wiki/Tree_(data_structure)">tree</a> that can be used to calculate the license number.
The ~tree~ is made up of ~nodes~; a single, outermost node forms the tree's ~root~, and it contains all other nodes in the tree (or contains nodes that contain nodes, and so on).
Specifically, a node consists of:

~A ~header~, which is always exactly two numbers:

~The quantity of child nodes.~
~The quantity of metadata entries.~

~Zero or more ~child nodes~ (as specified in the header).~
~One or more ~metadata entries~ (as specified in the header).~
~
Each child node is itself a node that has its own header, child nodes, and metadata. For example:

#+begin_src text
2 3 0 3 10 11 12 1 1 0 1 99 2 1 1 2
A----------------------------------
    B----------- C-----------
                     D-----

#+end_src

In this example, each node of the tree is also marked with an underline starting with a letter for easier identification. In it, there are four nodes:

~A, which has 2 child nodes (B, C) and 3 metadata entries (1, 1, 2).~
~B, which has 0 child nodes and 3 metadata entries (10, 11, 12).~
~C, which has 1 child node (D) and 1 metadata entry (2).~
~D, which has 0 child nodes and 1 metadata entry (99).~

The first check done on the license file is to simply add up all of the metadata entries.  In this example, that sum is 1+1+2+10+11+12+2+99=~138~.
~What is the sum of all metadata entries?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-08 :var input_data=input-2018-08 :tangle /tmp/advent_of_code/aoc2018-08-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-08 :var input_data=input-2018-08 :tangle /tmp/advent_of_code/aoc2018-08-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-08 :var input_data=input-2018-08 :tangle /tmp/advent_of_code/aoc2018-08-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-08 :var input_data=input-2018-08 :tangle /tmp/advent_of_code/aoc2018-08-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-08 :var input_data=input-2018-08 :tangle /tmp/advent_of_code/aoc2018-08-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-08 :var input_data=input-2018-08 :tangle /tmp/advent_of_code/aoc2018-08-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-08 :var input_data=input-2018-08 :tangle /tmp/advent_of_code/aoc2018-08-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-08 :var input_data=input-2018-08 :tangle /tmp/advent_of_code/aoc2018-08-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-08 :var input_data=input-2018-08 :tangle /tmp/advent_of_code/aoc2018-08-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-08 :var input_data=input-2018-08 :tangle /tmp/advent_of_code/aoc2018-08-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-08 :var input_data=input-2018-08 :tangle /tmp/advent_of_code/aoc2018-08-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-08 :var input_data=input-2018-08 :tangle /tmp/advent_of_code/aoc2018-08-2.pl :results output 
#+end_src
*** Day 09: Marble Mania
**** Part 1
***** Description
The Elves play this game by taking turns arranging the marbles in a ~circle~ according to very particular rules. The marbles are numbered starting with 0 and increasing by 1 until every marble has a number.
First, the marble numbered 0 is placed in the circle. At this point, while it contains only a single marble, it is still a circle: the marble is both clockwise from itself and counter-clockwise from itself. This marble is designated the ~current marble~.
Then, each Elf takes a turn placing the ~lowest-numbered remaining marble~ into the circle between the marbles that are 1 and 2 marbles ~clockwise~ of the current marble. (When the circle is large enough, this means that there is one marble between the marble that was just placed and the current marble.) The marble that was just placed then becomes the ~current marble~.
However, if the marble that is about to be placed has a number which is a multiple of 23, ~something entirely different happens~. First, the current player keeps the marble they would have placed, adding it to their ~score~. In addition, the marble 7 marbles ~counter-clockwise~ from the current marble is ~removed~ from the circle and ~also~ added to the current player's score. The marble located immediately ~clockwise~ of the marble that was removed becomes the new ~current marble~.
For example, suppose there are 9 players. After the marble with value 0 is placed in the middle, each player (shown in square brackets) takes a turn. The result of each of those turns would produce circles of marbles like this, where clockwise is to the right and the resulting current marble is in parentheses:

#+begin_src text
[-] ~(0)~
[1]  0~ (1)~
[2]  0~ (2)~ 1 
[3]  0  2  1~ (3)~
[4]  0~ (4)~ 2  1  3 
[5]  0  4  2~ (5)~ 1  3 
[6]  0  4  2  5  1~ (6)~ 3 
[7]  0  4  2  5  1  6  3~ (7)~
[8]  0~ (8)~ 4  2  5  1  6  3  7 
[9]  0  8  4~ (9)~ 2  5  1  6  3  7 
[1]  0  8  4  9  2~(10)~ 5  1  6  3  7 
[2]  0  8  4  9  2 10  5~(11)~ 1  6  3  7 
[3]  0  8  4  9  2 10  5 11  1~(12)~ 6  3  7 
[4]  0  8  4  9  2 10  5 11  1 12  6~(13)~ 3  7 
[5]  0  8  4  9  2 10  5 11  1 12  6 13  3~(14)~ 7 
[6]  0  8  4  9  2 10  5 11  1 12  6 13  3 14  7~(15)~
[7]  0~(16)~ 8  4  9  2 10  5 11  1 12  6 13  3 14  7 15 
[8]  0 16  8~(17)~ 4  9  2 10  5 11  1 12  6 13  3 14  7 15 
[9]  0 16  8 17  4~(18)~ 9  2 10  5 11  1 12  6 13  3 14  7 15 
[1]  0 16  8 17  4 18  9~(19)~ 2 10  5 11  1 12  6 13  3 14  7 15 
[2]  0 16  8 17  4 18  9 19  2~(20)~10  5 11  1 12  6 13  3 14  7 15 
[3]  0 16  8 17  4 18  9 19  2 20 10~(21)~ 5 11  1 12  6 13  3 14  7 15 
[4]  0 16  8 17  4 18  9 19  2 20 10 21  5~(22)~11  1 12  6 13  3 14  7 15 
[5]  0 16  8 17  4 18~(19)~ 2 20 10 21  5 22 11  1 12  6 13  3 14  7 15 
[6]  0 16  8 17  4 18 19  2~(24)~20 10 21  5 22 11  1 12  6 13  3 14  7 15 
[7]  0 16  8 17  4 18 19  2 24 20~(25)~10 21  5 22 11  1 12  6 13  3 14  7 15

#+end_src

The goal is to be the ~player with the highest score~ after the last marble is used up. Assuming the example above ends after the marble numbered 25, the winning score is 23+9=~32~ (because player 5 kept marble 23 and removed marble 9, while no other player got any points in this very short example game).
Here are a few more examples:

~10 players; last marble is worth 1618 points: high score is ~8317~~
~13 players; last marble is worth 7999 points: high score is ~146373~~
~17 players; last marble is worth 1104 points: high score is ~2764~~
~21 players; last marble is worth 6111 points: high score is ~54718~~
~30 players; last marble is worth 5807 points: high score is ~37305~~

~What is the winning Elf's score?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-09 :var input_data=input-2018-09 :tangle /tmp/advent_of_code/aoc2018-09-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-09 :var input_data=input-2018-09 :tangle /tmp/advent_of_code/aoc2018-09-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-09 :var input_data=input-2018-09 :tangle /tmp/advent_of_code/aoc2018-09-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-09 :var input_data=input-2018-09 :tangle /tmp/advent_of_code/aoc2018-09-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-09 :var input_data=input-2018-09 :tangle /tmp/advent_of_code/aoc2018-09-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-09 :var input_data=input-2018-09 :tangle /tmp/advent_of_code/aoc2018-09-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-09 :var input_data=input-2018-09 :tangle /tmp/advent_of_code/aoc2018-09-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-09 :var input_data=input-2018-09 :tangle /tmp/advent_of_code/aoc2018-09-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-09 :var input_data=input-2018-09 :tangle /tmp/advent_of_code/aoc2018-09-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-09 :var input_data=input-2018-09 :tangle /tmp/advent_of_code/aoc2018-09-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-09 :var input_data=input-2018-09 :tangle /tmp/advent_of_code/aoc2018-09-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-09 :var input_data=input-2018-09 :tangle /tmp/advent_of_code/aoc2018-09-2.pl :results output 
#+end_src
*** Day 10: The Stars Align
**** Part 1
***** Description
The Elves suggest an alternative. In times like these, North Pole rescue operations will arrange points of light in the sky to guide missing Elves back to base. Unfortunately, the message is easy to miss: the points move slowly enough that it takes hours to align them, but have so much momentum that they only stay aligned for a second. If you blink at the wrong time, it might be hours before another message appears.
You can see these points of light floating in the distance, and record their position in the sky and their velocity, the relative change in position per second (your puzzle input). The coordinates are all given from your perspective; given enough time, those positions and velocities will move the points into a cohesive message!
Rather than wait, you decide to fast-forward the process and calculate what the points will eventually spell.
For example, suppose you note the following points:

#+begin_src text
position=&lt; 9,  1&gt; velocity=&lt; 0,  2&gt;
position=&lt; 7,  0&gt; velocity=&lt;-1,  0&gt;
position=&lt; 3, -2&gt; velocity=&lt;-1,  1&gt;
position=&lt; 6, 10&gt; velocity=&lt;-2, -1&gt;
position=&lt; 2, -4&gt; velocity=&lt; 2,  2&gt;
position=&lt;-6, 10&gt; velocity=&lt; 2, -2&gt;
position=&lt; 1,  8&gt; velocity=&lt; 1, -1&gt;
position=&lt; 1,  7&gt; velocity=&lt; 1,  0&gt;
position=&lt;-3, 11&gt; velocity=&lt; 1, -2&gt;
position=&lt; 7,  6&gt; velocity=&lt;-1, -1&gt;
position=&lt;-2,  3&gt; velocity=&lt; 1,  0&gt;
position=&lt;-4,  3&gt; velocity=&lt; 2,  0&gt;
position=&lt;10, -3&gt; velocity=&lt;-1,  1&gt;
position=&lt; 5, 11&gt; velocity=&lt; 1, -2&gt;
position=&lt; 4,  7&gt; velocity=&lt; 0, -1&gt;
position=&lt; 8, -2&gt; velocity=&lt; 0,  1&gt;
position=&lt;15,  0&gt; velocity=&lt;-2,  0&gt;
position=&lt; 1,  6&gt; velocity=&lt; 1,  0&gt;
position=&lt; 8,  9&gt; velocity=&lt; 0, -1&gt;
position=&lt; 3,  3&gt; velocity=&lt;-1,  1&gt;
position=&lt; 0,  5&gt; velocity=&lt; 0, -1&gt;
position=&lt;-2,  2&gt; velocity=&lt; 2,  0&gt;
position=&lt; 5, -2&gt; velocity=&lt; 1,  2&gt;
position=&lt; 1,  4&gt; velocity=&lt; 2,  1&gt;
position=&lt;-2,  7&gt; velocity=&lt; 2, -2&gt;
position=&lt; 3,  6&gt; velocity=&lt;-1, -1&gt;
position=&lt; 5,  0&gt; velocity=&lt; 1,  0&gt;
position=&lt;-6,  0&gt; velocity=&lt; 2,  0&gt;
position=&lt; 5,  9&gt; velocity=&lt; 1, -2&gt;
position=&lt;14,  7&gt; velocity=&lt;-2,  0&gt;
position=&lt;-3,  6&gt; velocity=&lt; 2, -1&gt;

#+end_src

Each line represents one point. Positions are given as &lt;X, Y&gt; pairs: X represents how far left (negative) or right (positive) the point appears, while Y represents how far up (negative) or down (positive) the point appears.
At 0 seconds, each point has the position given. Each second, each point's velocity is added to its position. So, a point with velocity &lt;1, -2&gt; is moving to the right, but is moving upward twice as quickly. If this point's initial position were &lt;3, 9&gt;, after 3 seconds, its position would become &lt;6, 3&gt;.
Over time, the points listed above would move like this:

#+begin_src text
Initially:
........#.............
................#.....
.........#.#..#.......
......................
#..........#.#.......#
...............#......
....#.................
..#.#....#............
.......#..............
......#...............
...#...#.#...#........
....#..#..#.........#.
.......#..............
...........#..#.......
#...........#.........
...#.......#..........

After 1 second:
......................
......................
..........#....#......
........#.....#.......
..#.........#......#..
......................
......#...............
....##.........#......
......#.#.............
.....##.##..#.........
........#.#...........
........#...#.....#...
..#...........#.......
....#.....#.#.........
......................
......................

After 2 seconds:
......................
......................
......................
..............#.......
....#..#...####..#....
......................
........#....#........
......#.#.............
.......#...#..........
.......#..#..#.#......
....#....#.#..........
.....#...#...##.#.....
........#.............
......................
......................
......................

After 3 seconds:
......................
......................
......................
......................
......#...#..###......
......#...#...#.......
......#...#...#.......
......#####...#.......
......#...#...#.......
......#...#...#.......
......#...#...#.......
......#...#..###......
......................
......................
......................
......................

After 4 seconds:
......................
......................
......................
............#.........
........##...#.#......
......#.....#..#......
.....#..##.##.#.......
.......##.#....#......
...........#....#.....
..............#.......
....#......#...#......
.....#.....##.........
...............#......
...............#......
......................
......................

#+end_src

After 3 seconds, the message appeared briefly: ~HI~. Of course, your message will be much longer and will take many more seconds to appear.
~What message will eventually appear in the sky?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-10 :var input_data=input-2018-10 :tangle /tmp/advent_of_code/aoc2018-10-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-10 :var input_data=input-2018-10 :tangle /tmp/advent_of_code/aoc2018-10-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-10 :var input_data=input-2018-10 :tangle /tmp/advent_of_code/aoc2018-10-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-10 :var input_data=input-2018-10 :tangle /tmp/advent_of_code/aoc2018-10-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-10 :var input_data=input-2018-10 :tangle /tmp/advent_of_code/aoc2018-10-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-10 :var input_data=input-2018-10 :tangle /tmp/advent_of_code/aoc2018-10-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-10 :var input_data=input-2018-10 :tangle /tmp/advent_of_code/aoc2018-10-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-10 :var input_data=input-2018-10 :tangle /tmp/advent_of_code/aoc2018-10-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-10 :var input_data=input-2018-10 :tangle /tmp/advent_of_code/aoc2018-10-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-10 :var input_data=input-2018-10 :tangle /tmp/advent_of_code/aoc2018-10-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-10 :var input_data=input-2018-10 :tangle /tmp/advent_of_code/aoc2018-10-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-10 :var input_data=input-2018-10 :tangle /tmp/advent_of_code/aoc2018-10-2.pl :results output 
#+end_src
*** Day 11: Chronal Charge
**** Part 1
***** Description
Actually, you're the one fading. The <span title="wheeeeeeeeeeeeeeeeee">falling sensation</span> returns.
The low fuel warning light is illuminated on your wrist-mounted device. Tapping it once causes it to project a hologram of the situation: a ~300x300~ grid of fuel cells and their current power levels, some negative. You're not sure what negative power means in the context of time travel, but it can't be good.
Each fuel cell has a coordinate ranging ~from 1 to 300~ in both the X (horizontal) and Y (vertical) direction.  In X,Y notation, the top-left cell is 1,1, and the top-right cell is 300,1.
The interface lets you select ~any 3x3 square~ of fuel cells. To increase your chances of getting to your destination, you decide to choose the 3x3 square with the ~largest total power~.
The power level in a given fuel cell can be found through the following process:

~Find the fuel cell's ~rack ID~, which is its ~X coordinate plus 10~.~
~Begin with a power level of the ~rack ID~ times the ~Y coordinate~.~
~Increase the power level by the value of the ~grid serial number~ (your puzzle input).~
~Set the power level to itself multiplied by the ~rack ID~.~
~Keep only the ~hundreds digit~ of the power level (so 12~3~45 becomes 3; numbers with no hundreds digit become 0).~
~~Subtract 5~ from the power level.~

For example, to find the power level of the fuel cell at 3,5 in a grid with serial number 8:

~The rack ID is 3 + 10 = ~13~.~
~The power level starts at 13 * 5 = ~65~.~
~Adding the serial number produces 65 + 8 = ~73~.~
~Multiplying by the rack ID produces 73 * 13 = ~949~.~
~The hundreds digit of ~9~49 is ~9~.~
~Subtracting 5 produces 9 - 5 = ~4~.~

So, the power level of this fuel cell is ~4~.
Here are some more example power levels:

~Fuel cell at  122,79, grid serial number 57: power level -5.~
~Fuel cell at 217,196, grid serial number 39: power level  0.~
~Fuel cell at 101,153, grid serial number 71: power level  4.~

Your goal is to find the 3x3 square which has the largest total power. The square must be entirely within the 300x300 grid. Identify this square using the X,Y coordinate of its ~top-left fuel cell~. For example:
For grid serial number 18, the largest total 3x3 square has a top-left corner of ~33,45~ (with a total power of 29); these fuel cells appear in the middle of this 5x5 region:

#+begin_src text
-2  -4   4   4   4
-4  ~ 4   4   4  ~-5
 4  ~ 3   3   4  ~-4
 1  ~ 1   2   4  ~-3
-1   0   2  -5  -2

#+end_src

For grid serial number 42, the largest 3x3 square's top-left is ~21,61~ (with a total power of 30); they are in the middle of this region:

#+begin_src text
-3   4   2   2   2
-4  ~ 4   3   3  ~ 4
-5  ~ 3   3   4  ~-4
 4  ~ 3   3   4  ~-3
 3   3   3  -5  -1

#+end_src

~What is the X,Y coordinate of the top-left fuel cell of the 3x3 square with the largest total power?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-11 :var input_data=input-2018-11 :tangle /tmp/advent_of_code/aoc2018-11-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-11 :var input_data=input-2018-11 :tangle /tmp/advent_of_code/aoc2018-11-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-11 :var input_data=input-2018-11 :tangle /tmp/advent_of_code/aoc2018-11-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-11 :var input_data=input-2018-11 :tangle /tmp/advent_of_code/aoc2018-11-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-11 :var input_data=input-2018-11 :tangle /tmp/advent_of_code/aoc2018-11-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-11 :var input_data=input-2018-11 :tangle /tmp/advent_of_code/aoc2018-11-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-11 :var input_data=input-2018-11 :tangle /tmp/advent_of_code/aoc2018-11-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-11 :var input_data=input-2018-11 :tangle /tmp/advent_of_code/aoc2018-11-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-11 :var input_data=input-2018-11 :tangle /tmp/advent_of_code/aoc2018-11-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-11 :var input_data=input-2018-11 :tangle /tmp/advent_of_code/aoc2018-11-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-11 :var input_data=input-2018-11 :tangle /tmp/advent_of_code/aoc2018-11-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-11 :var input_data=input-2018-11 :tangle /tmp/advent_of_code/aoc2018-11-2.pl :results output 
#+end_src
*** Day 12: Subterranean Sustainability
**** Part 1
***** Description
After exploring a little, you discover a long tunnel that contains a row of small pots as far as you can see to your left and right.  A few of them contain plants - someone is trying to grow things in these geothermally-heated caves.
The pots are numbered, with 0 in front of you.  To the left, the pots are numbered -1, -2, -3, and so on; to the right, 1, 2, 3.... Your puzzle input contains a list of pots from 0 to the right and whether they do (#) or do not (.) currently contain a plant, the ~initial state~. (No other pots currently contain plants.) For example, an initial state of #..##.... indicates that pots 0, 3, and 4 currently contain plants.
Your puzzle input also contains some notes you find on a nearby table: someone has been trying to figure out how these plants ~spread~ to nearby pots.  Based on the notes, for each generation of plants, a given pot has or does not have a plant based on whether that pot (and the two pots on either side of it) had a plant in the last generation. These are written as LLCRR =&gt; N, where L are pots to the left, C is the current pot being considered, R are the pots to the right, and N is whether the current pot will have a plant in the next generation. For example:

~A note like ..#.. =&gt; . means that a pot that contains a plant but with no plants within two pots of it will not have a plant in it during the next generation.~
~A note like ##.## =&gt; . means that an empty pot with two plants on each side of it will remain empty in the next generation.~
~A note like .##.# =&gt; # means that a pot has a plant in a given generation if, in the previous generation, there were plants in that pot, the one immediately to the left, and the one two pots to the right, but not in the ones immediately to the right and two to the left.~

It's not clear what these plants are for, but you're sure it's important, so you'd like to make sure the current configuration of plants is sustainable by determining what will happen after ~20 generations~.
For example, given the following input:

#+begin_src text
initial state: #..#.#..##......###...###

...## =&gt; #
..#.. =&gt; #
.#... =&gt; #
.#.#. =&gt; #
.#.## =&gt; #
.##.. =&gt; #
.#### =&gt; #
#.#.# =&gt; #
#.### =&gt; #
##.#. =&gt; #
##.## =&gt; #
###.. =&gt; #
###.# =&gt; #
####. =&gt; #

#+end_src

For brevity, in this example, only the combinations which do produce a plant are listed. (Your input includes all possible combinations.) Then, the next 20 generations will look like this:

#+begin_src text
                 1         2         3     
       0         0         0         0     
 0: ...#..#.#..##......###...###...........
 1: ...#...#....#.....#..#..#..#...........
 2: ...##..##...##....#..#..#..##..........
 3: ..#.#...#..#.#....#..#..#...#..........
 4: ...#.#..#...#.#...#..#..##..##.........
 5: ....#...##...#.#..#..#...#...#.........
 6: ....##.#.#....#...#..##..##..##........
 7: ...#..###.#...##..#...#...#...#........
 8: ...#....##.#.#.#..##..##..##..##.......
 9: ...##..#..#####....#...#...#...#.......
10: ..#.#..#...#.##....##..##..##..##......
11: ...#...##...#.#...#.#...#...#...#......
12: ...##.#.#....#.#...#.#..##..##..##.....
13: ..#..###.#....#.#...#....#...#...#.....
14: ..#....##.#....#.#..##...##..##..##....
15: ..##..#..#.#....#....#..#.#...#...#....
16: .#.#..#...#.#...##...#...#.#..##..##...
17: ..#...##...#.#.#.#...##...#....#...#...
18: ..##.#.#....#####.#.#.#...##...##..##..
19: .#..###.#..#.#.#######.#.#.#..#.#...#..
20: .#....##....#####...#######....#.#..##.

#+end_src

The generation is shown along the left, where 0 is the initial state.  The pot numbers are shown along the top, where 0 labels the center pot, negative-numbered pots extend to the left, and positive pots extend toward the right. Remember, the initial state begins at pot 0, which is not the leftmost pot used in this example.
After one generation, only seven plants remain.  The one in pot 0 matched the rule looking for ..#.., the one in pot 4 matched the rule looking for .#.#., pot 9 matched .##.., and so on.
In this example, after 20 generations, the pots shown as # contain plants, the furthest left of which is pot -2, and the furthest right of which is pot 34. Adding up all the numbers of plant-containing pots after the 20th generation produces ~325~.
~After 20 generations, what is the sum of the numbers of all pots which contain a plant?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-12 :var input_data=input-2018-12 :tangle /tmp/advent_of_code/aoc2018-12-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-12 :var input_data=input-2018-12 :tangle /tmp/advent_of_code/aoc2018-12-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-12 :var input_data=input-2018-12 :tangle /tmp/advent_of_code/aoc2018-12-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-12 :var input_data=input-2018-12 :tangle /tmp/advent_of_code/aoc2018-12-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-12 :var input_data=input-2018-12 :tangle /tmp/advent_of_code/aoc2018-12-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-12 :var input_data=input-2018-12 :tangle /tmp/advent_of_code/aoc2018-12-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-12 :var input_data=input-2018-12 :tangle /tmp/advent_of_code/aoc2018-12-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-12 :var input_data=input-2018-12 :tangle /tmp/advent_of_code/aoc2018-12-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-12 :var input_data=input-2018-12 :tangle /tmp/advent_of_code/aoc2018-12-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-12 :var input_data=input-2018-12 :tangle /tmp/advent_of_code/aoc2018-12-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-12 :var input_data=input-2018-12 :tangle /tmp/advent_of_code/aoc2018-12-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-12 :var input_data=input-2018-12 :tangle /tmp/advent_of_code/aoc2018-12-2.pl :results output 
#+end_src
*** Day 13: Mine Cart Madness
**** Part 1
***** Description
Seeing as how cart-and-track systems don't appear in recorded history for <span title="Time anomalies! How do they work?!">another 1000 years</span>, the Elves seem to be making this up as they go along. They haven't even figured out how to avoid collisions yet.
You map out the tracks (your puzzle input) and see where you can help.
Tracks consist of straight paths (| and -), curves (/ and \), and intersections (+). Curves connect exactly two perpendicular pieces of track; for example, this is a closed loop:

#+begin_src text
/----\
|    |
|    |
\----/

#+end_src

Intersections occur when two perpendicular paths cross. At an intersection, a cart is capable of turning left, turning right, or continuing straight.  Here are two loops connected by two intersections:

#+begin_src text
/-----\
|     |
|  /--+--\
|  |  |  |
\--+--/  |
   |     |
   \-----/

#+end_src

Several ~carts~ are also on the tracks. Carts always face either up (^), down (v), left (&lt;), or right (&gt;). (On your initial map, the track under each cart is a straight path matching the direction the cart is facing.)
Each time a cart has the option to turn (by arriving at any intersection), it turns ~left~ the first time, goes ~straight~ the second time, turns ~right~ the third time, and then repeats those directions starting again with ~left~ the fourth time, ~straight~ the fifth time, and so on. This process is independent of the particular intersection at which the cart has arrived - that is, the cart has no per-intersection memory.
Carts all move at the same speed; they take turns moving a single step at a time. They do this based on their ~current location~: carts on the top row move first (acting from left to right), then carts on the second row move (again from left to right), then carts on the third row, and so on.  Once each cart has moved one step, the process repeats; each of these loops is called a ~tick~.
For example, suppose there are two carts on a straight track:

#+begin_src text
|  |  |  |  |
v  |  |  |  |
|  v  v  |  |
|  |  |  v  X
|  |  ^  ^  |
^  ^  |  |  |
|  |  |  |  |

#+end_src

First, the top cart moves. It is facing down (v), so it moves down one square.  Second, the bottom cart moves.  It is facing up (^), so it moves up one square. Because all carts have moved, the first tick ends.  Then, the process repeats, starting with the first cart.  The first cart moves down, then the second cart moves up - right into the first cart, colliding with it! (The location of the crash is marked with an X.) This ends the second and last tick.
Here is a longer example:

#+begin_src text
/-&gt;-\        
|   |  /----\
| /-+--+-\  |
| | |  | v  |
\-+-/  \-+--/
  \------/   

/--&gt;\        
|   |  /----\
| /-+--+-\  |
| | |  | |  |
\-+-/  \-&gt;--/
  \------/   

/---v        
|   |  /----\
| /-+--+-\  |
| | |  | |  |
\-+-/  \-+&gt;-/
  \------/   

/---\        
|   v  /----\
| /-+--+-\  |
| | |  | |  |
\-+-/  \-+-&gt;/
  \------/   

/---\        
|   |  /----\
| /-&gt;--+-\  |
| | |  | |  |
\-+-/  \-+--^
  \------/   

/---\        
|   |  /----\
| /-+&gt;-+-\  |
| | |  | |  ^
\-+-/  \-+--/
  \------/   

/---\        
|   |  /----\
| /-+-&gt;+-\  ^
| | |  | |  |
\-+-/  \-+--/
  \------/   

/---\        
|   |  /----&lt;
| /-+--&gt;-\  |
| | |  | |  |
\-+-/  \-+--/
  \------/   

/---\        
|   |  /---&lt;\
| /-+--+&gt;\  |
| | |  | |  |
\-+-/  \-+--/
  \------/   

/---\        
|   |  /--&lt;-\
| /-+--+-v  |
| | |  | |  |
\-+-/  \-+--/
  \------/   

/---\        
|   |  /-&lt;--\
| /-+--+-\  |
| | |  | v  |
\-+-/  \-+--/
  \------/   

/---\        
|   |  /&lt;---\
| /-+--+-\  |
| | |  | |  |
\-+-/  \-&lt;--/
  \------/   

/---\        
|   |  v----\
| /-+--+-\  |
| | |  | |  |
\-+-/  \&lt;+--/
  \------/   

/---\        
|   |  /----\
| /-+--v-\  |
| | |  | |  |
\-+-/  ^-+--/
  \------/   

/---\        
|   |  /----\
| /-+--+-\  |
| | |  X |  |
\-+-/  \-+--/
  \------/   

#+end_src

After following their respective paths for a while, the carts eventually crash.  To help prevent crashes, you'd like to know ~the location of the first crash~. Locations are given in X,Y coordinates, where the furthest left column is X=0 and the furthest top row is Y=0:

#+begin_src text
           111
 0123456789012
0/---\        
1|   |  /----\
2| /-+--+-\  |
3| | |  X |  |
4\-+-/  \-+--/
5  \------/   

#+end_src

In this example, the location of the first crash is ~7,3~.
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-13 :var input_data=input-2018-13 :tangle /tmp/advent_of_code/aoc2018-13-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-13 :var input_data=input-2018-13 :tangle /tmp/advent_of_code/aoc2018-13-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-13 :var input_data=input-2018-13 :tangle /tmp/advent_of_code/aoc2018-13-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-13 :var input_data=input-2018-13 :tangle /tmp/advent_of_code/aoc2018-13-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-13 :var input_data=input-2018-13 :tangle /tmp/advent_of_code/aoc2018-13-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-13 :var input_data=input-2018-13 :tangle /tmp/advent_of_code/aoc2018-13-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-13 :var input_data=input-2018-13 :tangle /tmp/advent_of_code/aoc2018-13-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-13 :var input_data=input-2018-13 :tangle /tmp/advent_of_code/aoc2018-13-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-13 :var input_data=input-2018-13 :tangle /tmp/advent_of_code/aoc2018-13-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-13 :var input_data=input-2018-13 :tangle /tmp/advent_of_code/aoc2018-13-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-13 :var input_data=input-2018-13 :tangle /tmp/advent_of_code/aoc2018-13-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-13 :var input_data=input-2018-13 :tangle /tmp/advent_of_code/aoc2018-13-2.pl :results output 
#+end_src
*** Day 14: Chocolate Charts
**** Part 1
***** Description
The Elves are trying to come up with the ultimate hot chocolate recipe; they're even maintaining a scoreboard which tracks the quality ~score~ (0-9) of each recipe.
Only two recipes are on the board: the first recipe got a score of 3, the second, 7. Each of the two Elves has a ~current recipe~: the first Elf starts with the first recipe, and the second Elf starts with the second recipe.
To create new recipes, the two Elves combine their current recipes.  This creates new recipes from the ~digits of the sum~ of the current recipes' scores.  With the current recipes' scores of 3 and 7, their sum is 10, and so two new recipes would be created: the first with score 1 and the second with score 0. If the current recipes' scores were 2 and 3, the sum, 5, would only create one recipe (with a score of 5) with its single digit.
The new recipes are added to the end of the scoreboard in the order they are created.  So, after the first round, the scoreboard is 3, 7, 1, 0.
After all new recipes are added to the scoreboard, each Elf picks a new current recipe.  To do this, the Elf steps forward through the scoreboard a number of recipes equal to ~1 plus the score of their current recipe~. So, after the first round, the first Elf moves forward 1 + 3 = 4 times, while the second Elf moves forward 1 + 7 = 8 times. If they run out of recipes, they loop back around to the beginning. After the first round, both Elves happen to loop around until they land on the same recipe that they had in the beginning; in general, they will move to different recipes.
Drawing the first Elf as parentheses and the second Elf as square brackets, they continue this process:

#+begin_src text
(3)[7]
(3)[7] 1  0 
 3  7  1 [0](1) 0 
 3  7  1  0 [1] 0 (1)
(3) 7  1  0  1  0 [1] 2 
 3  7  1  0 (1) 0  1  2 [4]
 3  7  1 [0] 1  0 (1) 2  4  5 
 3  7  1  0 [1] 0  1  2 (4) 5  1 
 3 (7) 1  0  1  0 [1] 2  4  5  1  5 
 3  7  1  0  1  0  1  2 [4](5) 1  5  8 
 3 (7) 1  0  1  0  1  2  4  5  1  5  8 [9]
 3  7  1  0  1  0  1 [2] 4 (5) 1  5  8  9  1  6 
 3  7  1  0  1  0  1  2  4  5 [1] 5  8  9  1 (6) 7 
 3  7  1  0 (1) 0  1  2  4  5  1  5 [8] 9  1  6  7  7 
 3  7 [1] 0  1  0 (1) 2  4  5  1  5  8  9  1  6  7  7  9 
 3  7  1  0 [1] 0  1  2 (4) ~5  1  5  8  9  1  6  7  7  9~  2 

#+end_src

The Elves think their skill will improve after making a few recipes (your puzzle input). However, that could take ages; you can speed this up considerably by identifying ~the scores of the ten recipes~ after that.  For example:

~If the Elves think their skill will improve after making 9 recipes, the scores of the ten recipes ~after~ the first nine on the scoreboard would be 5158916779 (highlighted in the last line of the diagram).~
~After 5 recipes, the scores of the next ten would be 0124515891.~
~After 18 recipes, the scores of the next ten would be 9251071085.~
~After 2018 recipes, the scores of the next ten would be 5941429882.~

~What are the scores of the ten recipes immediately after the number of recipes in your puzzle input?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-14 :var input_data=input-2018-14 :tangle /tmp/advent_of_code/aoc2018-14-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-14 :var input_data=input-2018-14 :tangle /tmp/advent_of_code/aoc2018-14-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-14 :var input_data=input-2018-14 :tangle /tmp/advent_of_code/aoc2018-14-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-14 :var input_data=input-2018-14 :tangle /tmp/advent_of_code/aoc2018-14-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-14 :var input_data=input-2018-14 :tangle /tmp/advent_of_code/aoc2018-14-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-14 :var input_data=input-2018-14 :tangle /tmp/advent_of_code/aoc2018-14-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-14 :var input_data=input-2018-14 :tangle /tmp/advent_of_code/aoc2018-14-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-14 :var input_data=input-2018-14 :tangle /tmp/advent_of_code/aoc2018-14-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-14 :var input_data=input-2018-14 :tangle /tmp/advent_of_code/aoc2018-14-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-14 :var input_data=input-2018-14 :tangle /tmp/advent_of_code/aoc2018-14-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-14 :var input_data=input-2018-14 :tangle /tmp/advent_of_code/aoc2018-14-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-14 :var input_data=input-2018-14 :tangle /tmp/advent_of_code/aoc2018-14-2.pl :results output 
#+end_src
*** Day 15: Beverage Bandits
**** Part 1
***** Description
You scan the area, generating a map of the walls (#), open cavern (.), and starting position of every Goblin (G) and Elf (E) (your puzzle input).
Combat proceeds in ~rounds~; in each round, each unit that is still alive takes a ~turn~, resolving all of its actions before the next unit's turn begins. On each unit's turn, it tries to ~move~ into range of an enemy (if it isn't already) and then ~attack~ (if it is in range).
All units are very disciplined and always follow very strict combat rules. Units never move or attack diagonally, as doing so would be dishonorable. When multiple choices are equally valid, ties are broken in ~reading order~: top-to-bottom, then left-to-right.  For instance, the order in which units take their turns within a round is the ~reading order of their starting positions~ in that round, regardless of the type of unit or whether other units have moved after the round started.  For example:

#+begin_src text
                 would take their
These units:   turns in this order:
  #######           #######
  #.G.E.#           #.1.2.#
  #E.G.E#           #3.4.5#
  #.G.E.#           #.6.7.#
  #######           #######

#+end_src

Each unit begins its turn by identifying all possible ~targets~ (enemy units). If no targets remain, combat ends.
Then, the unit identifies all of the open squares (.) that are ~in range~ of each target; these are the squares which are ~adjacent~ (immediately up, down, left, or right) to any target and which aren't already occupied by a wall or another unit. Alternatively, the unit might ~already~ be in range of a target. If the unit is not already in range of a target, and there are no open squares which are in range of a target, the unit ends its turn.
If the unit is already in range of a target, it does not ~move~, but continues its turn with an ~attack~. Otherwise, since it is not in range of a target, it ~moves~.
To ~move~, the unit first considers the squares that are ~in range~ and determines ~which of those squares it could reach in the fewest steps~. A ~step~ is a single movement to any ~adjacent~ (immediately up, down, left, or right) open (.) square. Units cannot move into walls or other units. The unit does this while considering the ~current positions of units~ and does ~not~ do any prediction about where units will be later. If the unit cannot reach (find an open path to) any of the squares that are in range, it ends its turn. If multiple squares are in range and ~tied~ for being reachable in the fewest steps, the square which is first in ~reading order~ is chosen. For example:

#+begin_src text
Targets:      In range:     Reachable:    Nearest:      Chosen:
#######       #######       #######       #######       #######
#E..G.#       #E.?G?#       #E.@G.#       #E.!G.#       #E.+G.#
#...#.#  --&gt;  #.?.#?#  --&gt;  #.@.#.#  --&gt;  #.!.#.#  --&gt;  #...#.#
#.G.#G#       #?G?#G#       #@G@#G#       #!G.#G#       #.G.#G#
#######       #######       #######       #######       #######

#+end_src

In the above scenario, the Elf has three targets (the three Goblins):

~Each of the Goblins has open, adjacent squares which are ~in range~ (marked with a ? on the map).~
~Of those squares, four are ~reachable~ (marked @); the other two (on the right) would require moving through a wall or unit to reach.~
~Three of these reachable squares are ~nearest~, requiring the fewest steps (only 2) to reach (marked !).~
~Of those, the square which is first in reading order is ~chosen~ (+).~

The unit then takes a single ~step~ toward the chosen square along the ~shortest path~ to that square. If multiple steps would put the unit equally closer to its destination, the unit chooses the step which is first in reading order. (This requires knowing when there is ~more than one shortest path~ so that you can consider the first step of each such path.) For example:

#+begin_src text
In range:     Nearest:      Chosen:       Distance:     Step:
#######       #######       #######       #######       #######
#.E...#       #.E...#       #.E...#       #4E~2~12#       #..E..#
#...?.#  --&gt;  #...!.#  --&gt;  #...+.#  --&gt;  #3~2~101#  --&gt;  #.....#
#..?G?#       #..!G.#       #...G.#       #432G2#       #...G.#
#######       #######       #######       #######       #######

#+end_src

The Elf sees three squares in range of a target (?), two of which are nearest (!), and so the first in reading order is chosen (+). Under "Distance", each open square is marked with its distance from the destination square; the two squares to which the Elf could move on this turn (down and to the right) are both equally good moves and would leave the Elf 2 steps from being in range of the Goblin. Because the step which is first in reading order is chosen, the Elf moves ~right~ one square.
Here's a larger example of movement:

#+begin_src text
Initially:
#########
#G..G..G#
#.......#
#.......#
#G..E..G#
#.......#
#.......#
#G..G..G#
#########

After 1 round:
#########
#.G...G.#
#...G...#
#...E..G#
#.G.....#
#.......#
#G..G..G#
#.......#
#########

After 2 rounds:
#########
#..G.G..#
#...G...#
#.G.E.G.#
#.......#
#G..G..G#
#.......#
#.......#
#########

After 3 rounds:
#########
#.......#
#..GGG..#
#..GEG..#
#G..G...#
#......G#
#.......#
#.......#
#########

#+end_src

Once the Goblins and Elf reach the positions above, they all are either in range of a target or cannot find any square in range of a target, and so none of the units can move until a unit dies.
After moving (or if the unit began its turn in range of a target), the unit ~attacks~.
To ~attack~, the unit first determines ~all~ of the targets that are ~in range~ of it by being immediately ~adjacent~ to it. If there are no such targets, the unit ends its turn. Otherwise, the adjacent target with the ~fewest hit points~ is selected; in a tie, the adjacent target with the fewest hit points which is first in reading order is selected.
The unit deals damage equal to its ~attack power~ to the selected target, reducing its hit points by that amount. If this reduces its hit points to 0 or fewer, the selected target ~dies~: its square becomes . and it takes no further turns.
Each ~unit~, either Goblin or Elf, has 3 ~attack power~ and starts with 200 ~hit points~.
For example, suppose the only Elf is about to attack:

#+begin_src text
       HP:            HP:
G....  9       G....  9  
..G..  4       ..G..  4  
..E~G~.  2  --&gt;  ..E..     
..G..  2       ..G..  2  
...G.  1       ...G.  1  

#+end_src

The "HP" column shows the hit points of the Goblin to the left in the corresponding row. The Elf is in range of three targets: the Goblin above it (with 4 hit points), the Goblin to its right (with 2 hit points), and the Goblin below it (also with 2 hit points). Because three targets are in range, the ones with the lowest hit points are selected: the two Goblins with 2 hit points each (one to the right of the Elf and one below the Elf). Of those, the Goblin first in reading order (the one to the right of the Elf) is selected. The selected Goblin's hit points (2) are reduced by the Elf's attack power (3), reducing its hit points to -1, killing it.
After attacking, the unit's turn ends.  Regardless of how the unit's turn ends, the next unit in the round takes its turn.  If all units have taken turns in this round, the round ends, and a new round begins.
The Elves look quite outnumbered.  You need to determine the ~outcome~ of the battle: the ~number of full rounds that were completed~ (not counting the round in which combat ends) multiplied by ~the sum of the hit points of all remaining units~ at the moment combat ends. (Combat only ends when a unit finds no targets during its turn.)
Below is an entire sample combat. Next to each map, each row's units' hit points are listed from left to right.

#+begin_src text
Initially:
#######   
#.G...#   G(200)
#...EG#   E(200), G(200)
#.#.#G#   G(200)
#..G#E#   G(200), E(200)
#.....#   
#######   

After 1 round:
#######   
#..G..#   G(200)
#...EG#   E(197), G(197)
#.#G#G#   G(200), G(197)
#...#E#   E(197)
#.....#   
#######   

After 2 rounds:
#######   
#...G.#   G(200)
#..GEG#   G(200), E(188), G(194)
#.#.#G#   G(194)
#...#E#   E(194)
#.....#   
#######   

Combat ensues; eventually, the top Elf dies:

After 23 rounds:
#######   
#...G.#   G(200)
#..G.G#   G(200), G(131)
#.#.#G#   G(131)
#...#E#   E(131)
#.....#   
#######   

After 24 rounds:
#######   
#..G..#   G(200)
#...G.#   G(131)
#.#G#G#   G(200), G(128)
#...#E#   E(128)
#.....#   
#######   

After 25 rounds:
#######   
#.G...#   G(200)
#..G..#   G(131)
#.#.#G#   G(125)
#..G#E#   G(200), E(125)
#.....#   
#######   

After 26 rounds:
#######   
#G....#   G(200)
#.G...#   G(131)
#.#.#G#   G(122)
#...#E#   E(122)
#..G..#   G(200)
#######   

After 27 rounds:
#######   
#G....#   G(200)
#.G...#   G(131)
#.#.#G#   G(119)
#...#E#   E(119)
#...G.#   G(200)
#######   

After 28 rounds:
#######   
#G....#   G(200)
#.G...#   G(131)
#.#.#G#   G(116)
#...#E#   E(113)
#....G#   G(200)
#######   

More combat ensues; eventually, the bottom Elf dies:

After 47 rounds:
#######   
#G....#   G(200)
#.G...#   G(131)
#.#.#G#   G(59)
#...#.#   
#....G#   G(200)
#######   

#+end_src

Before the 48th round can finish, the top-left Goblin finds that there are no targets remaining, and so combat ends. So, the number of ~full rounds~ that were completed is ~47~, and the sum of the hit points of all remaining units is 200+131+59+200 = ~590~. From these, the ~outcome~ of the battle is 47 * 590 = ~27730~.
Here are a few example summarized combats:

#+begin_src text
#######       #######
#G..#E#       #...#E#   E(200)
#E#E.E#       #E#...#   E(197)
#G.##.#  --&gt;  #.E##.#   E(185)
#...#E#       #E..#E#   E(200), E(200)
#...E.#       #.....#
#######       #######

Combat ends after 37 full rounds
Elves win with 982 total hit points left
Outcome: 37 * 982 = ~36334~

#+end_src


#+begin_src text
#######       #######   
#E..EG#       #.E.E.#   E(164), E(197)
#.#G.E#       #.#E..#   E(200)
#E.##E#  --&gt;  #E.##.#   E(98)
#G..#.#       #.E.#.#   E(200)
#..E#.#       #...#.#   
#######       #######   

Combat ends after 46 full rounds
Elves win with 859 total hit points left
Outcome: 46 * 859 = ~39514~

#+end_src


#+begin_src text
#######       #######   
#E.G#.#       #G.G#.#   G(200), G(98)
#.#G..#       #.#G..#   G(200)
#G.#.G#  --&gt;  #..#..#   
#G..#.#       #...#G#   G(95)
#...E.#       #...G.#   G(200)
#######       #######   

Combat ends after 35 full rounds
Goblins win with 793 total hit points left
Outcome: 35 * 793 = ~27755~

#+end_src


#+begin_src text
#######       #######   
#.E...#       #.....#   
#.#..G#       #.#G..#   G(200)
#.###.#  --&gt;  #.###.#   
#E#G#G#       #.#.#.#   
#...#G#       #G.G#G#   G(98), G(38), G(200)
#######       #######   

Combat ends after 54 full rounds
Goblins win with 536 total hit points left
Outcome: 54 * 536 = ~28944~

#+end_src


#+begin_src text
#########       #########   
#G......#       #.G.....#   G(137)
#.E.#...#       #G.G#...#   G(200), G(200)
#..##..G#       #.G##...#   G(200)
#...##..#  --&gt;  #...##..#   
#...#...#       #.G.#...#   G(200)
#.G...G.#       #.......#   
#.....G.#       #.......#   
#########       #########   

Combat ends after 20 full rounds
Goblins win with 937 total hit points left
Outcome: 20 * 937 = ~18740~

#+end_src

~What is the outcome~ of the combat described in your puzzle input?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-15 :var input_data=input-2018-15 :tangle /tmp/advent_of_code/aoc2018-15-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-15 :var input_data=input-2018-15 :tangle /tmp/advent_of_code/aoc2018-15-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-15 :var input_data=input-2018-15 :tangle /tmp/advent_of_code/aoc2018-15-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-15 :var input_data=input-2018-15 :tangle /tmp/advent_of_code/aoc2018-15-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-15 :var input_data=input-2018-15 :tangle /tmp/advent_of_code/aoc2018-15-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-15 :var input_data=input-2018-15 :tangle /tmp/advent_of_code/aoc2018-15-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-15 :var input_data=input-2018-15 :tangle /tmp/advent_of_code/aoc2018-15-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-15 :var input_data=input-2018-15 :tangle /tmp/advent_of_code/aoc2018-15-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-15 :var input_data=input-2018-15 :tangle /tmp/advent_of_code/aoc2018-15-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-15 :var input_data=input-2018-15 :tangle /tmp/advent_of_code/aoc2018-15-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-15 :var input_data=input-2018-15 :tangle /tmp/advent_of_code/aoc2018-15-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-15 :var input_data=input-2018-15 :tangle /tmp/advent_of_code/aoc2018-15-2.pl :results output 
#+end_src
*** Day 16: Chronal Classification
**** Part 1
***** Description
If you're ever going to return to your own time, you need to understand how this device on your wrist works. You have a little while before you reach your next destination, and with a bit of trial and error, you manage to pull up a programming manual on the device's tiny screen.
According to the manual, the device has four <a href="https://en.wikipedia.org/wiki/Hardware_register">registers</a> (numbered 0 through 3) that can be manipulated by <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture#Instructions">instructions</a> containing one of 16 opcodes. The registers start with the value 0.
Every instruction consists of four values: an ~opcode~, two ~inputs~ (named A and B), and an ~output~ (named C), in that order. The opcode specifies the behavior of the instruction and how the inputs are interpreted. The output, C, is always treated as a register.
In the opcode descriptions below, if something says "~value A~", it means to take the number given as A ~literally~. (This is also called an "immediate" value.) If something says "~register A~", it means to use the number given as A to read from (or write to) the ~register with that number~. So, if the opcode addi adds register A and value B, storing the result in register C, and the instruction addi 0 7 3 is encountered, it would add 7 to the value contained by register 0 and store the sum in register 3, never modifying registers 0, 1, or 2 in the process.
Many opcodes are similar except for how they interpret their arguments. The opcodes fall into seven general categories:
Addition:

~addr (add register) stores into register C the result of adding register A and register B.~
~addi (add immediate) stores into register C the result of adding register A and value B.~

Multiplication:

~mulr (multiply register) stores into register C the result of multiplying register A and register B.~
~muli (multiply immediate) stores into register C the result of multiplying register A and value B.~

<a href="https://en.wikipedia.org/wiki/Bitwise_AND">Bitwise AND</a>:

~banr (bitwise AND register) stores into register C the result of the bitwise AND of register A and register B.~
~bani (bitwise AND immediate) stores into register C the result of the bitwise AND of register A and value B.~

<a href="https://en.wikipedia.org/wiki/Bitwise_OR">Bitwise OR</a>:

~borr (bitwise OR register) stores into register C the result of the bitwise OR of register A and register B.~
~bori (bitwise OR immediate) stores into register C the result of the bitwise OR of register A and value B.~

Assignment:

~setr (set register) copies the contents of register A into register C. (Input B is ignored.)~
~seti (set immediate) stores value A into register C. (Input B is ignored.)~

Greater-than testing:

~gtir (greater-than immediate/register) sets register C to 1 if value A is greater than register B. Otherwise, register C is set to 0.~
~gtri (greater-than register/immediate) sets register C to 1 if register A is greater than value B. Otherwise, register C is set to 0.~
~gtrr (greater-than register/register) sets register C to 1 if register A is greater than register B. Otherwise, register C is set to 0.~

Equality testing:

~eqir (equal immediate/register) sets register C to 1 if value A is equal to register B. Otherwise, register C is set to 0.~
~eqri (equal register/immediate) sets register C to 1 if register A is equal to value B. Otherwise, register C is set to 0.~
~eqrr (equal register/register) sets register C to 1 if register A is equal to register B. Otherwise, register C is set to 0.~

Unfortunately, while the manual gives the ~name~ of each opcode, it doesn't seem to indicate the ~number~. However, you can monitor the CPU to see the contents of the registers before and after instructions are executed to try to work them out.  Each opcode has a number from 0 through 15, but the manual doesn't say which is which. For example, suppose you capture the following sample:

#+begin_src text
Before: [3, 2, 1, 1]
9 2 1 2
After:  [3, 2, 2, 1]

#+end_src

This sample shows the effect of the instruction 9 2 1 2 on the registers. Before the instruction is executed, register 0 has value 3, register 1 has value 2, and registers 2 and 3 have value 1. After the instruction is executed, register 2's value becomes 2.
The instruction itself, 9 2 1 2, means that opcode 9 was executed with A=2, B=1, and C=2. Opcode 9 could be any of the 16 opcodes listed above, but only three of them behave in a way that would cause the result shown in the sample:

~Opcode 9 could be mulr: register 2 (which has a value of 1) times register 1 (which has a value of 2) produces 2, which matches the value stored in the output register, register 2.~
~Opcode 9 could be addi: register 2 (which has a value of 1) plus value 1 produces 2, which matches the value stored in the output register, register 2.~
~Opcode 9 could be seti: value 2 matches the value stored in the output register, register 2; the number given for B is irrelevant.~

None of the other opcodes produce the result captured in the sample. Because of this, the sample above ~behaves like three opcodes~.
You collect many of these samples (the first section of your puzzle input). The manual also includes a small test program (the second section of your puzzle input) - you can ~ignore it for now~.
Ignoring the opcode numbers, ~how many samples in your puzzle input behave like three or more opcodes?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-16 :var input_data=input-2018-16 :tangle /tmp/advent_of_code/aoc2018-16-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-16 :var input_data=input-2018-16 :tangle /tmp/advent_of_code/aoc2018-16-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-16 :var input_data=input-2018-16 :tangle /tmp/advent_of_code/aoc2018-16-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-16 :var input_data=input-2018-16 :tangle /tmp/advent_of_code/aoc2018-16-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-16 :var input_data=input-2018-16 :tangle /tmp/advent_of_code/aoc2018-16-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-16 :var input_data=input-2018-16 :tangle /tmp/advent_of_code/aoc2018-16-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-16 :var input_data=input-2018-16 :tangle /tmp/advent_of_code/aoc2018-16-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-16 :var input_data=input-2018-16 :tangle /tmp/advent_of_code/aoc2018-16-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-16 :var input_data=input-2018-16 :tangle /tmp/advent_of_code/aoc2018-16-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-16 :var input_data=input-2018-16 :tangle /tmp/advent_of_code/aoc2018-16-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-16 :var input_data=input-2018-16 :tangle /tmp/advent_of_code/aoc2018-16-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-16 :var input_data=input-2018-16 :tangle /tmp/advent_of_code/aoc2018-16-2.pl :results output 
#+end_src
*** Day 17: Reservoir Research
**** Part 1
***** Description
Rather, it hasn't been constructed ~yet~.  The Elves are making a little progress, but there's not a lot of liquid water in this climate, so they're getting very dehydrated.  Maybe there's more underground?
You scan a two-dimensional vertical slice of the ground nearby and discover that it is mostly ~sand~ with veins of ~clay~.  The scan only provides data with a granularity of ~square meters~, but it should be good enough to determine how much water is trapped there. In the scan, x represents the distance to the right, and y represents the distance down. There is also a ~spring of water~ near the surface at x=500, y=0. The scan identifies ~which square meters are clay~ (your puzzle input).
For example, suppose your scan shows the following veins of clay:

#+begin_src text
x=495, y=2..7
y=7, x=495..501
x=501, y=3..7
x=498, y=2..4
x=506, y=1..2
x=498, y=10..13
x=504, y=10..13
y=13, x=498..504

#+end_src

Rendering clay as #, sand as ., and the water spring as +, and with x increasing to the right and y increasing downward, this becomes:

#+begin_src text
   44444455555555
   99999900000000
   45678901234567
 0 ......+.......
 1 ............#.
 2 .#..#.......#.
 3 .#..#..#......
 4 .#..#..#......
 5 .#.....#......
 6 .#.....#......
 7 .#######......
 8 ..............
 9 ..............
10 ....#.....#...
11 ....#.....#...
12 ....#.....#...
13 ....#######...

#+end_src

The spring of water will produce water ~forever~. Water can move through sand, but is blocked by clay. Water ~always moves down~ when possible, and spreads to the left and right otherwise, filling space that has clay on both sides and falling out otherwise.
For example, if five squares of water are created, they will flow downward until they reach the clay and settle there. Water that has come to rest is shown here as ~, while sand through which water has passed (but which is now dry again) is shown as |:

#+begin_src text
......+.......
......|.....#.
.#..#.|.....#.
.#..#.|#......
.#..#.|#......
.#....|#......
.#~~~~~#......
.#######......
..............
..............
....#.....#...
....#.....#...
....#.....#...
....#######...

#+end_src

Two squares of water can't occupy the same location.  If another five squares of water are created, they will settle on the first five, filling the clay reservoir a little more:

#+begin_src text
......+.......
......|.....#.
.#..#.|.....#.
.#..#.|#......
.#..#.|#......
.#~~~~~#......
.#~~~~~#......
.#######......
..............
..............
....#.....#...
....#.....#...
....#.....#...
....#######...

#+end_src

Water pressure does not apply in this scenario. If another four squares of water are created, they will stay on the right side of the barrier, and no water will reach the left side:

#+begin_src text
......+.......
......|.....#.
.#..#.|.....#.
.#..#~~#......
.#..#~~#......
.#~~~~~#......
.#~~~~~#......
.#######......
..............
..............
....#.....#...
....#.....#...
....#.....#...
....#######...

#+end_src

At this point, the top reservoir overflows. While water can reach the tiles above the surface of the water, it cannot settle there, and so the next five squares of water settle like this:

#+begin_src text
......+.......
......|.....#.
.#..#~|~|||...#.
.#..#~~#|.....
.#..#~~#|.....
.#~~~~~#|.....
.#~~~~~#|.....
.#######|.....
........|.....
........|.....
....#...|.#...
....#...|.#...
....#~~~~~#...
....#######...

#+end_src

Note especially the leftmost |: the new squares of water can reach this tile, but cannot stop there.  Instead, eventually, they all fall to the right and settle in the reservoir below.
After 10 more squares of water, the bottom reservoir is also full:

#+begin_src text
......+.......
......|.....#.
.#..#||||...#.
.#..#~~#|.....
.#..#~~#|.....
.#~~~~~#|.....
.#~~~~~#|.....
.#######|.....
........|.....
........|.....
....#~~~~~#...
....#~~~~~#...
....#~~~~~#...
....#######...

#+end_src

Finally, while there is nowhere left for the water to settle, it can reach a few more tiles before overflowing beyond the bottom of the scanned data:

#+begin_src text
......+.......    (line not counted: above minimum y value)
......|.....#.
.#..#||||...#.
.#..#~~#|.....
.#..#~~#|.....
.#~~~~~#|.....
.#~~~~~#|.....
.#######|.....
........|.....
...|||||||||..
...|#~~~~~#|..
...|#~~~~~#|..
...|#~~~~~#|..
...|#######|..
...|.......|..    (line not counted: below maximum y value)
...|.......|..    (line not counted: below maximum y value)
...|.......|..    (line not counted: below maximum y value)

#+end_src

How many tiles can be reached by the water?  ~To prevent counting forever~, ignore tiles with a y coordinate smaller than the smallest y coordinate in your scan data or larger than the largest one. Any x coordinate is valid. In this example, the lowest y coordinate given is 1, and the highest is 13, causing the water spring (in row 0) and the water falling off the bottom of the render (in rows 14 through infinity) to be ignored.
So, in the example above, counting both water at rest (~) and other sand tiles the water can hypothetically reach (|), the total number of tiles the water can reach is ~57~.
~How many tiles can the water reach~ within the range of y values in your scan?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-17 :var input_data=input-2018-17 :tangle /tmp/advent_of_code/aoc2018-17-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-17 :var input_data=input-2018-17 :tangle /tmp/advent_of_code/aoc2018-17-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-17 :var input_data=input-2018-17 :tangle /tmp/advent_of_code/aoc2018-17-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-17 :var input_data=input-2018-17 :tangle /tmp/advent_of_code/aoc2018-17-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-17 :var input_data=input-2018-17 :tangle /tmp/advent_of_code/aoc2018-17-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-17 :var input_data=input-2018-17 :tangle /tmp/advent_of_code/aoc2018-17-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-17 :var input_data=input-2018-17 :tangle /tmp/advent_of_code/aoc2018-17-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-17 :var input_data=input-2018-17 :tangle /tmp/advent_of_code/aoc2018-17-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-17 :var input_data=input-2018-17 :tangle /tmp/advent_of_code/aoc2018-17-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-17 :var input_data=input-2018-17 :tangle /tmp/advent_of_code/aoc2018-17-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-17 :var input_data=input-2018-17 :tangle /tmp/advent_of_code/aoc2018-17-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-17 :var input_data=input-2018-17 :tangle /tmp/advent_of_code/aoc2018-17-2.pl :results output 
#+end_src
*** Day 18: Settlers of The North Pole
**** Part 1
***** Description
The lumber collection area is 50 acres by 50 acres; each acre can be either ~open ground~ (.), ~trees~ (|), or a ~lumberyard~ (#). You take a scan of the area (your puzzle input).
Strange magic is at work here: each minute, the landscape looks entirely different. In exactly ~one minute~, an open acre can fill with trees, a wooded acre can be converted to a lumberyard, or a lumberyard can be cleared to open ground (the lumber having been sent to other projects).
The change to each acre is based entirely on ~the contents of that acre~ as well as ~the number of open, wooded, or lumberyard acres adjacent to it~ at the start of each minute. Here, "adjacent" means any of the eight acres surrounding that acre. (Acres on the edges of the lumber collection area might have fewer than eight adjacent acres; the missing acres aren't counted.)
In particular:

~An ~open~ acre will become filled with ~trees~ if ~three or more~ adjacent acres contained trees. Otherwise, nothing happens.~
~An acre filled with ~trees~ will become a ~lumberyard~ if ~three or more~ adjacent acres were lumberyards. Otherwise, nothing happens.~
~An acre containing a ~lumberyard~ will remain a ~lumberyard~ if it was adjacent to ~at least one other lumberyard and at least one acre containing trees~. Otherwise, it becomes ~open~.~

These changes happen across all acres ~simultaneously~, each of them using the state of all acres at the beginning of the minute and changing to their new form by the end of that same minute. Changes that happen during the minute don't affect each other.
For example, suppose the lumber collection area is instead only 10 by 10 acres with this initial configuration:

#+begin_src text
Initial state:
.#.#...|#.
.....#|##|
.|..|...#.
..|#.....#
#.#|||#|#|
...#.||...
.|....|...
||...#|.#|
|.||||..|.
...#.|..|.

After 1 minute:
.......##.
......|###
.|..|...#.
..|#||...#
..##||.|#|
...#||||..
||...|||..
|||||.||.|
||||||||||
....||..|.

After 2 minutes:
.......#..
......|#..
.|.|||....
..##|||..#
..###|||#|
...#|||||.
|||||||||.
||||||||||
||||||||||
.|||||||||

After 3 minutes:
.......#..
....|||#..
.|.||||...
..###|||.#
...##|||#|
.||##|||||
||||||||||
||||||||||
||||||||||
||||||||||

After 4 minutes:
.....|.#..
...||||#..
.|.#||||..
..###||||#
...###||#|
|||##|||||
||||||||||
||||||||||
||||||||||
||||||||||

After 5 minutes:
....|||#..
...||||#..
.|.##||||.
..####|||#
.|.###||#|
|||###||||
||||||||||
||||||||||
||||||||||
||||||||||

After 6 minutes:
...||||#..
...||||#..
.|.###|||.
..#.##|||#
|||#.##|#|
|||###||||
||||#|||||
||||||||||
||||||||||
||||||||||

After 7 minutes:
...||||#..
..||#|##..
.|.####||.
||#..##||#
||##.##|#|
|||####|||
|||###||||
||||||||||
||||||||||
||||||||||

After 8 minutes:
..||||##..
..|#####..
|||#####|.
||#...##|#
||##..###|
||##.###||
|||####|||
||||#|||||
||||||||||
||||||||||

After 9 minutes:
..||###...
.||#####..
||##...##.
||#....###
|##....##|
||##..###|
||######||
|||###||||
||||||||||
||||||||||

After 10 minutes:
.||##.....
||###.....
||##......
|##.....##
|##.....##
|##....##|
||##.####|
||#####|||
||||#|||||
||||||||||

#+end_src

After 10 minutes, there are 37 wooded acres and 31 lumberyards.  Multiplying the number of wooded acres by the number of lumberyards gives the total ~resource value~ after ten minutes: 37 * 31 = ~1147~.
~What will the total resource value of the lumber collection area be after 10 minutes?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-18 :var input_data=input-2018-18 :tangle /tmp/advent_of_code/aoc2018-18-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-18 :var input_data=input-2018-18 :tangle /tmp/advent_of_code/aoc2018-18-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-18 :var input_data=input-2018-18 :tangle /tmp/advent_of_code/aoc2018-18-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-18 :var input_data=input-2018-18 :tangle /tmp/advent_of_code/aoc2018-18-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-18 :var input_data=input-2018-18 :tangle /tmp/advent_of_code/aoc2018-18-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-18 :var input_data=input-2018-18 :tangle /tmp/advent_of_code/aoc2018-18-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-18 :var input_data=input-2018-18 :tangle /tmp/advent_of_code/aoc2018-18-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-18 :var input_data=input-2018-18 :tangle /tmp/advent_of_code/aoc2018-18-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-18 :var input_data=input-2018-18 :tangle /tmp/advent_of_code/aoc2018-18-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-18 :var input_data=input-2018-18 :tangle /tmp/advent_of_code/aoc2018-18-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-18 :var input_data=input-2018-18 :tangle /tmp/advent_of_code/aoc2018-18-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-18 :var input_data=input-2018-18 :tangle /tmp/advent_of_code/aoc2018-18-2.pl :results output 
#+end_src
*** Day 19: Go With The Flow
**** Part 1
***** Description
You can't help but notice that the <a href="16">device's opcodes</a> don't contain any ~flow control~ like jump instructions. The device's <a href="16">manual</a> goes on to explain:
"In programs where flow control is required, the <a href="https://en.wikipedia.org/wiki/Program_counter">instruction pointer</a> can be ~bound to a register~ so that it can be manipulated directly. This way, setr/seti can function as absolute jumps, addr/addi can function as relative jumps, and other opcodes can cause <span title="Good luck maintaining a program that uses a bitwise operation on its instruction pointer, though.">truly fascinating</span> effects."
This mechanism is achieved through a declaration like #ip 1, which would modify register 1 so that accesses to it let the program indirectly access the instruction pointer itself. To compensate for this kind of binding, there are now ~six~ registers (numbered 0 through 5); the five not bound to the instruction pointer behave as normal. Otherwise, the same rules apply as <a href="16">the last time you worked with this device</a>.
When the ~instruction pointer~ is bound to a register, its value is written to that register just before each instruction is executed, and the value of that register is written back to the instruction pointer immediately after each instruction finishes execution. Afterward, move to the next instruction by adding one to the instruction pointer, even if the value in the instruction pointer was just updated by an instruction. (Because of this, instructions must effectively set the instruction pointer to the instruction ~before~ the one they want executed next.)
The instruction pointer is 0 during the first instruction, 1 during the second, and so on. If the instruction pointer ever causes the device to attempt to load an instruction outside the instructions defined in the program, the program instead immediately halts. The instruction pointer starts at 0.
It turns out that this new information is already proving useful: the CPU in the device is not very powerful, and a background process is occupying most of its time.  You dump the background process' declarations and instructions to a file (your puzzle input), making sure to use the names of the opcodes rather than the numbers.
For example, suppose you have the following program:

#+begin_src text
#ip 0
seti 5 0 1
seti 6 0 2
addi 0 1 0
addr 1 2 3
setr 1 0 0
seti 8 0 4
seti 9 0 5

#+end_src

When executed, the following instructions are executed. Each line contains the value of the instruction pointer at the time the instruction started, the values of the six registers before executing the instructions (in square brackets), the instruction itself, and the values of the six registers after executing the instruction (also in square brackets).

#+begin_src text
ip=0 [0, 0, 0, 0, 0, 0] seti 5 0 1 [0, 5, 0, 0, 0, 0]
ip=1 [1, 5, 0, 0, 0, 0] seti 6 0 2 [1, 5, 6, 0, 0, 0]
ip=2 [2, 5, 6, 0, 0, 0] addi 0 1 0 [3, 5, 6, 0, 0, 0]
ip=4 [4, 5, 6, 0, 0, 0] setr 1 0 0 [5, 5, 6, 0, 0, 0]
ip=6 [6, 5, 6, 0, 0, 0] seti 9 0 5 [6, 5, 6, 0, 0, 9]

#+end_src

In detail, when running this program, the following events occur:

~The first line (#ip 0) indicates that the instruction pointer should be bound to register 0 in this program. This is not an instruction, and so the value of the instruction pointer does not change during the processing of this line.~
~The instruction pointer contains 0, and so the first instruction is executed (seti 5 0 1).  It updates register 0 to the current instruction pointer value (0), sets register 1 to 5, sets the instruction pointer to the value of register 0 (which has no effect, as the instruction did not modify register 0), and then adds one to the instruction pointer.~
~The instruction pointer contains 1, and so the second instruction, seti 6 0 2, is executed. This is very similar to the instruction before it: 6 is stored in register 2, and the instruction pointer is left with the value 2.~
~The instruction pointer is 2, which points at the instruction addi 0 1 0.  This is like a ~relative jump~: the value of the instruction pointer, 2, is loaded into register 0. Then, addi finds the result of adding the value in register 0 and the value 1, storing the result, 3, back in register 0. Register 0 is then copied back to the instruction pointer, which will cause it to end up 1 larger than it would have otherwise and skip the next instruction (addr 1 2 3) entirely. Finally, 1 is added to the instruction pointer.~
~The instruction pointer is 4, so the instruction setr 1 0 0 is run. This is like an ~absolute jump~: it copies the value contained in register 1, 5, into register 0, which causes it to end up in the instruction pointer. The instruction pointer is then incremented, leaving it at 6.~
~The instruction pointer is 6, so the instruction seti 9 0 5 stores 9 into register 5. The instruction pointer is incremented, causing it to point outside the program, and so the program ends.~

~What value is left in register 0~ when the background process halts?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-19 :var input_data=input-2018-19 :tangle /tmp/advent_of_code/aoc2018-19-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-19 :var input_data=input-2018-19 :tangle /tmp/advent_of_code/aoc2018-19-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-19 :var input_data=input-2018-19 :tangle /tmp/advent_of_code/aoc2018-19-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-19 :var input_data=input-2018-19 :tangle /tmp/advent_of_code/aoc2018-19-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-19 :var input_data=input-2018-19 :tangle /tmp/advent_of_code/aoc2018-19-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-19 :var input_data=input-2018-19 :tangle /tmp/advent_of_code/aoc2018-19-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-19 :var input_data=input-2018-19 :tangle /tmp/advent_of_code/aoc2018-19-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-19 :var input_data=input-2018-19 :tangle /tmp/advent_of_code/aoc2018-19-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-19 :var input_data=input-2018-19 :tangle /tmp/advent_of_code/aoc2018-19-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-19 :var input_data=input-2018-19 :tangle /tmp/advent_of_code/aoc2018-19-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-19 :var input_data=input-2018-19 :tangle /tmp/advent_of_code/aoc2018-19-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-19 :var input_data=input-2018-19 :tangle /tmp/advent_of_code/aoc2018-19-2.pl :results output 
#+end_src
*** Day 20: A Regular Map
**** Part 1
***** Description
The area you are in is made up entirely of ~rooms~ and ~doors~. The rooms are arranged in a grid, and rooms only connect to adjacent rooms when a door is present between them.
For example, drawing rooms as ., walls as #, doors as | or -, your current position as X, and where north is up, the area you're in might look like this:

#+begin_src text
#####
#.|.#
#-###
#.|X#
#####

#+end_src

You get the attention of a passing construction Elf and ask for a map. "I don't have time to draw out a map of this place - it's ~huge~. Instead, I can give you directions to ~every room in the facility~!" He writes down some directions on a piece of parchment and runs off. In the example above, the instructions might have been ^WNE$, a <a href="https://en.wikipedia.org/wiki/Regular_expression">regular expression</a> or "~regex~" (your puzzle input).
The regex matches routes (like WNE for "west, north, east") that will take you from your current room through various doors in the facility. In aggregate, the routes will take you through ~every door in the facility at least once~; mapping out all of these routes will let you build a proper map and find your way around.
^ and $ are at the beginning and end of your regex; these just mean that the regex doesn't match anything outside the routes it describes. (Specifically, ^ matches the start of the route, and $ matches the end of it.) These characters will not appear elsewhere in the regex.
The rest of the regex matches various sequences of the characters N (north), S (south), E (east), and W (west). In the example above, ^WNE$ matches only one route, WNE, which means you can move ~west, then north, then east~ from your current position. Sequences of letters like this always match that exact route in the same order.
Sometimes, the route can ~branch~. A branch is given by a ~list of options~ separated by pipes (|) and wrapped in parentheses. So, ^N(E|W)N$ contains a branch: after going north, you must choose to go ~either east or west~ before finishing your route by going north again. By tracing out the possible routes after branching, you can determine where the doors are and, therefore, where the rooms are in the facility.
For example, consider this regex: ^ENWWW(NEEE|SSE(EE|N))$
This regex begins with ENWWW, which means that from your current position, all routes must begin by moving east, north, and then west three times, in that order. After this, there is a branch.  Before you consider the branch, this is what you know about the map so far, with doors you aren't sure about marked with a ?:

#+begin_src text
#?#?#?#?#
?.|.|.|.?
#?#?#?#-#
    ?X|.?
    #?#?#

#+end_src

After this point, there is (NEEE|SSE(EE|N)). This gives you exactly two options: NEEE and SSE(EE|N). By following NEEE, the map now looks like this:

#+begin_src text
#?#?#?#?#
?.|.|.|.?
#-#?#?#?#
?.|.|.|.?
#?#?#?#-#
    ?X|.?
    #?#?#

#+end_src

Now, only SSE(EE|N) remains. Because it is in the same parenthesized group as NEEE, it starts from the same room NEEE started in. It states that starting from that point, there exist doors which will allow you to move south twice, then east; this ends up at another branch. After that, you can either move east twice or north once. This information fills in the rest of the doors:

#+begin_src text
#?#?#?#?#
?.|.|.|.?
#-#?#?#?#
?.|.|.|.?
#-#?#?#-#
?.?.?X|.?
#-#-#?#?#
?.|.|.|.?
#?#?#?#?#

#+end_src

Once you've followed all possible routes, you know the remaining unknown parts are all walls, producing a finished map of the facility:

#+begin_src text
#########
#.|.|.|.#
#-#######
#.|.|.|.#
#-#####-#
#.#.#X|.#
#-#-#####
#.|.|.|.#
#########

#+end_src

Sometimes, a list of options can have an ~empty option~, like (NEWS|WNSE|). This means that routes at this point could effectively skip the options in parentheses and move on immediately.  For example, consider this regex and the corresponding map:

#+begin_src text
^ENNWSWW(NEWS|)SSSEEN(WNSE|)EE(SWEN|)NNN$

###########
#.|.#.|.#.#
#-###-#-#-#
#.|.|.#.#.#
#-#####-#-#
#.#.#X|.#.#
#-#-#####-#
#.#.|.|.|.#
#-###-###-#
#.|.|.#.|.#
###########

#+end_src

This regex has one main route which, at three locations, can optionally include additional detours and be valid: (NEWS|), (WNSE|), and (SWEN|). Regardless of which option is taken, the route continues from the position it is left at after taking those steps. So, for example, this regex matches all of the following routes (and more that aren't listed here):

~ENNWSWWSSSEENEENNN~
~ENNWSWW~NEWS~SSSEENEENNN~
~ENNWSWW~NEWS~SSSEENEE~SWEN~NNN~
~ENNWSWWSSSEEN~WNSE~EENNN~

By following the various routes the regex matches, a full map of all of the doors and rooms in the facility can be assembled.
To get a sense for the size of this facility, you'd like to determine which room is ~furthest~ from you: specifically, you would like to find the room for which the ~shortest path to that room would require passing through the most doors~.

~In the first example (^WNE$), this would be the north-east corner ~3~ doors away.~
~In the second example (^ENWWW(NEEE|SSE(EE|N))$), this would be the south-east corner ~10~ doors away.~
~In the third example (^ENNWSWW(NEWS|)SSSEEN(WNSE|)EE(SWEN|)NNN$), this would be the north-east corner ~18~ doors away.~

Here are a few more examples:

#+begin_src text
Regex: ^ESSWWN(E|NNENN(EESS(WNSE|)SSS|WWWSSSSE(SW|NNNE)))$
Furthest room requires passing 23 doors

#############
#.|.|.|.|.|.#
#-#####-###-#
#.#.|.#.#.#.#
#-#-###-#-#-#
#.#.#.|.#.|.#
#-#-#-#####-#
#.#.#.#X|.#.#
#-#-#-###-#-#
#.|.#.|.#.#.#
###-#-###-#-#
#.|.#.|.|.#.#
#############

#+end_src


#+begin_src text
Regex: ^WSSEESWWWNW(S|NENNEEEENN(ESSSSW(NWSW|SSEN)|WSWWN(E|WWS(E|SS))))$
Furthest room requires passing 31 doors

###############
#.|.|.|.#.|.|.#
#-###-###-#-#-#
#.|.#.|.|.#.#.#
#-#########-#-#
#.#.|.|.|.|.#.#
#-#-#########-#
#.#.#.|X#.|.#.#
###-#-###-#-#-#
#.|.#.#.|.#.|.#
#-###-#####-###
#.|.#.|.|.#.#.#
#-#-#####-#-#-#
#.#.|.|.|.#.|.#
###############

#+end_src

~What is the largest number of doors you would be required to pass through to reach a room?~ That is, find the room for which the shortest path from your starting location to that room would require passing through the most doors; what is the fewest doors you can pass through to reach it?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-20 :var input_data=input-2018-20 :tangle /tmp/advent_of_code/aoc2018-20-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-20 :var input_data=input-2018-20 :tangle /tmp/advent_of_code/aoc2018-20-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-20 :var input_data=input-2018-20 :tangle /tmp/advent_of_code/aoc2018-20-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-20 :var input_data=input-2018-20 :tangle /tmp/advent_of_code/aoc2018-20-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-20 :var input_data=input-2018-20 :tangle /tmp/advent_of_code/aoc2018-20-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-20 :var input_data=input-2018-20 :tangle /tmp/advent_of_code/aoc2018-20-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-20 :var input_data=input-2018-20 :tangle /tmp/advent_of_code/aoc2018-20-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-20 :var input_data=input-2018-20 :tangle /tmp/advent_of_code/aoc2018-20-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-20 :var input_data=input-2018-20 :tangle /tmp/advent_of_code/aoc2018-20-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-20 :var input_data=input-2018-20 :tangle /tmp/advent_of_code/aoc2018-20-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-20 :var input_data=input-2018-20 :tangle /tmp/advent_of_code/aoc2018-20-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-20 :var input_data=input-2018-20 :tangle /tmp/advent_of_code/aoc2018-20-2.pl :results output 
#+end_src
*** Day 21: Chronal Conversion
**** Part 1
***** Description
<span title="The old time travel hole gag! Classic.">Just kidding.</span>  You're falling through time again.
If you keep up your current pace, you should have resolved all of the temporal anomalies by the next time the device activates. Since you have very little interest in browsing history in 500-year increments for the rest of your life, you need to find a way to get back to your present time.
After a little research, you discover two important facts about the behavior of the device:
First, you discover that the device is hard-wired to always send you back in time in 500-year increments. Changing this is probably not feasible.
Second, you discover the ~activation system~ (your puzzle input) for the time travel module.  Currently, it appears to ~run forever without halting~.
If you can cause the activation system to ~halt~ at a specific moment, maybe you can make the device send you so far back in time that you cause an <a href="https://cwe.mitre.org/data/definitions/191.html">integer underflow</a> ~in time itself~ and wrap around back to your current time!
The device executes the program as specified in <a href="16">manual section one</a> and <a href="19">manual section two</a>.
Your goal is to figure out how the program works and cause it to halt.  You can only control ~register 0~; every other register begins at 0 as usual.
Because time travel is a dangerous activity, the activation system begins with a few instructions which verify that ~bitwise AND~ (via bani) does a ~numeric~ operation and ~not~ an operation as if the inputs were interpreted as strings. If the test fails, it enters an infinite loop re-running the test instead of allowing the program to execute normally.  If the test passes, the program continues, and assumes that ~all other bitwise operations~ (banr, bori, and borr) also interpret their inputs as ~numbers~. (Clearly, the Elves who wrote this system were worried that someone might introduce a bug while trying to emulate this system with a scripting language.)
~What is the lowest non-negative integer value for register 0 that causes the program to halt after executing the fewest instructions?~ (Executing the same instruction multiple times counts as multiple instructions executed.)
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-21 :var input_data=input-2018-21 :tangle /tmp/advent_of_code/aoc2018-21-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-21 :var input_data=input-2018-21 :tangle /tmp/advent_of_code/aoc2018-21-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-21 :var input_data=input-2018-21 :tangle /tmp/advent_of_code/aoc2018-21-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-21 :var input_data=input-2018-21 :tangle /tmp/advent_of_code/aoc2018-21-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-21 :var input_data=input-2018-21 :tangle /tmp/advent_of_code/aoc2018-21-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-21 :var input_data=input-2018-21 :tangle /tmp/advent_of_code/aoc2018-21-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-21 :var input_data=input-2018-21 :tangle /tmp/advent_of_code/aoc2018-21-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-21 :var input_data=input-2018-21 :tangle /tmp/advent_of_code/aoc2018-21-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-21 :var input_data=input-2018-21 :tangle /tmp/advent_of_code/aoc2018-21-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-21 :var input_data=input-2018-21 :tangle /tmp/advent_of_code/aoc2018-21-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-21 :var input_data=input-2018-21 :tangle /tmp/advent_of_code/aoc2018-21-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-21 :var input_data=input-2018-21 :tangle /tmp/advent_of_code/aoc2018-21-2.pl :results output 
#+end_src
*** Day 22: Mode Maze
**** Part 1
***** Description
A portly man with a large, white beard answers the door and invites you inside. For someone living near the North Pole in -483, he must not get many visitors, but he doesn't act surprised to see you. Instead, he offers you some milk and cookies.
After talking for a while, he asks a favor of you. His friend hasn't come back in a few hours, and he's not sure where he is.  Scanning the region briefly, you discover one life signal in a cave system nearby; his friend must have taken shelter there.  The man asks if you can go there to retrieve his friend.
The cave is divided into square ~regions~ which are either dominantly ~rocky~, ~narrow~, or ~wet~ (called its ~type~). Each region occupies exactly one ~coordinate~ in X,Y format where X and Y are integers and zero or greater. (Adjacent regions can be the same type.)
The scan (your puzzle input) is not very detailed: it only reveals the ~depth~ of the cave system and the ~coordinates of the target~. However, it does not reveal the type of each region. The mouth of the cave is at 0,0.
The man explains that due to the unusual geology in the area, there is a method to determine any region's type based on its ~erosion level~. The erosion level of a region can be determined from its ~geologic index~. The geologic index can be determined using the first rule that applies from the list below:

~The region at 0,0 (the mouth of the cave) has a geologic index of 0.~
~The region at the coordinates of the target has a geologic index of 0.~
~If the region's Y coordinate is 0, the geologic index is its X coordinate times 16807.~
~If the region's X coordinate is 0, the geologic index is its Y coordinate times 48271.~
~Otherwise, the region's geologic index is the result of multiplying the erosion ~levels~ of the regions at X-1,Y and X,Y-1.~

A region's ~erosion level~ is its ~geologic index~ plus the cave system's ~depth~, all <a href="https://en.wikipedia.org/wiki/Modulo_operation">modulo</a> 20183. Then:

~If the ~erosion level modulo 3~ is 0, the region's type is ~rocky~.~
~If the ~erosion level modulo 3~ is 1, the region's type is ~wet~.~
~If the ~erosion level modulo 3~ is 2, the region's type is ~narrow~.~

For example, suppose the cave system's depth is 510 and the target's coordinates are 10,10. Using % to represent the modulo operator, the cavern would look as follows:

~At 0,0, the geologic index is 0. The erosion level is (0 + 510) % 20183 = 510. The type is 510 % 3 = 0, ~rocky~.~
~At 1,0, because the Y coordinate is 0, the geologic index is 1 * 16807 = 16807. The erosion level is (16807 + 510) % 20183 = 17317. The type is 17317 % 3 = 1, ~wet~.~
~At 0,1, because the X coordinate is 0, the geologic index is  1 * 48271 = 48271. The erosion level is (48271 + 510) % 20183 = 8415. The type is 8415 % 3 = 0, ~rocky~.~
~At 1,1, neither coordinate is 0 and it is not the coordinate of the target, so the geologic index is the erosion level of 0,1 (8415) times the erosion level of 1,0 (17317), 8415 * 17317 = 145722555. The erosion level is (145722555 + 510) % 20183 = 1805. The type is 1805 % 3 = 2, ~narrow~.~
~At 10,10, because they are the target's coordinates, the geologic index is 0. The erosion level is (0 + 510) % 20183 = 510. The type is 510 % 3 = 0, ~rocky~.~

Drawing this same cave system with rocky as ., wet as =, narrow as |, the mouth as M, the target as T, with 0,0 in the top-left corner, X increasing to the right, and Y increasing downward, the top-left corner of the map looks like this:

#+begin_src text
~M~=.|=.|.|=.|=|=.
.|=|=|||..|.=...
.==|....||=..|==
=.|....|.==.|==.
=|..==...=.|==..
=||.=.=||=|=..|=
|.=.===|||..=..|
|..==||=.|==|===
.=..===..=|.|||.
.======|||=|=.|=
.===|=|===~T~===||
=|||...|==..|=.|
=.=|=.=..=.||==|
||=|=...|==.=|==
|=.=||===.|||===
||.|==.|.|.||=||

#+end_src

Before you go in, you should determine the ~risk level~ of the area. For the rectangle that has a top-left corner of region 0,0 and a bottom-right corner of the region containing the target, add up the risk level of each individual region: 0 for rocky regions, 1 for wet regions, and 2 for narrow regions.
In the cave system above, because the mouth is at 0,0 and the target is at 10,10, adding up the risk level of all regions with an X coordinate from 0 to 10 and a Y coordinate from 0 to 10, this total is ~114~.
~What is the total risk level for the smallest rectangle that includes 0,0 and the target's coordinates?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-22 :var input_data=input-2018-22 :tangle /tmp/advent_of_code/aoc2018-22-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-22 :var input_data=input-2018-22 :tangle /tmp/advent_of_code/aoc2018-22-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-22 :var input_data=input-2018-22 :tangle /tmp/advent_of_code/aoc2018-22-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-22 :var input_data=input-2018-22 :tangle /tmp/advent_of_code/aoc2018-22-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-22 :var input_data=input-2018-22 :tangle /tmp/advent_of_code/aoc2018-22-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-22 :var input_data=input-2018-22 :tangle /tmp/advent_of_code/aoc2018-22-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-22 :var input_data=input-2018-22 :tangle /tmp/advent_of_code/aoc2018-22-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-22 :var input_data=input-2018-22 :tangle /tmp/advent_of_code/aoc2018-22-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-22 :var input_data=input-2018-22 :tangle /tmp/advent_of_code/aoc2018-22-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-22 :var input_data=input-2018-22 :tangle /tmp/advent_of_code/aoc2018-22-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-22 :var input_data=input-2018-22 :tangle /tmp/advent_of_code/aoc2018-22-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-22 :var input_data=input-2018-22 :tangle /tmp/advent_of_code/aoc2018-22-2.pl :results output 
#+end_src
*** Day 23: Experimental Emergency Teleportation
**** Part 1
***** Description
You're not sure how it got so far in this cave.  It looks sick - too sick to walk - and too heavy for you to carry all the way back.  Sleighs won't be invented for another 1500 years, of course.
The only option is ~experimental emergency teleportation~.
You hit the "experimental emergency teleportation" <span title="We've always had this button; we've just been too scared to press it.">button</span> on the device and push ~I accept the risk~ on no fewer than 18 different warning messages. Immediately, the device deploys hundreds of tiny ~nanobots~ which fly around the cavern, apparently assembling themselves into a very specific ~formation~. The device lists the X,Y,Z position (pos) for each nanobot as well as its ~signal radius~ (r) on its tiny screen (your puzzle input).
Each nanobot can transmit signals to any integer coordinate which is a distance away from it ~less than or equal to~ its signal radius (as measured by <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distance</a>). Coordinates a distance away of less than or equal to a nanobot's signal radius are said to be ~in range~ of that nanobot.
Before you start the teleportation process, you should determine which nanobot is the ~strongest~ (that is, which has the largest signal radius) and then, for that nanobot, the ~total number of nanobots that are in range~ of it, ~including itself~.
For example, given the following nanobots:

#+begin_src text
pos=&lt;0,0,0&gt;, r=4
pos=&lt;1,0,0&gt;, r=1
pos=&lt;4,0,0&gt;, r=3
pos=&lt;0,2,0&gt;, r=1
pos=&lt;0,5,0&gt;, r=3
pos=&lt;0,0,3&gt;, r=1
pos=&lt;1,1,1&gt;, r=1
pos=&lt;1,1,2&gt;, r=1
pos=&lt;1,3,1&gt;, r=1

#+end_src

The strongest nanobot is the first one (position 0,0,0) because its signal radius, 4 is the largest. Using that nanobot's location and signal radius, the following nanobots are in or out of range:

~The nanobot at 0,0,0 is distance 0 away, and so it is ~in range~.~
~The nanobot at 1,0,0 is distance 1 away, and so it is ~in range~.~
~The nanobot at 4,0,0 is distance 4 away, and so it is ~in range~.~
~The nanobot at 0,2,0 is distance 2 away, and so it is ~in range~.~
~The nanobot at 0,5,0 is distance 5 away, and so it is ~not~ in range.~
~The nanobot at 0,0,3 is distance 3 away, and so it is ~in range~.~
~The nanobot at 1,1,1 is distance 3 away, and so it is ~in range~.~
~The nanobot at 1,1,2 is distance 4 away, and so it is ~in range~.~
~The nanobot at 1,3,1 is distance 5 away, and so it is ~not~ in range.~

In this example, in total, ~7~ nanobots are in range of the nanobot with the largest signal radius.
Find the nanobot with the largest signal radius.  ~How many nanobots are in range~ of its signals?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-23 :var input_data=input-2018-23 :tangle /tmp/advent_of_code/aoc2018-23-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-23 :var input_data=input-2018-23 :tangle /tmp/advent_of_code/aoc2018-23-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-23 :var input_data=input-2018-23 :tangle /tmp/advent_of_code/aoc2018-23-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-23 :var input_data=input-2018-23 :tangle /tmp/advent_of_code/aoc2018-23-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-23 :var input_data=input-2018-23 :tangle /tmp/advent_of_code/aoc2018-23-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-23 :var input_data=input-2018-23 :tangle /tmp/advent_of_code/aoc2018-23-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-23 :var input_data=input-2018-23 :tangle /tmp/advent_of_code/aoc2018-23-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-23 :var input_data=input-2018-23 :tangle /tmp/advent_of_code/aoc2018-23-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-23 :var input_data=input-2018-23 :tangle /tmp/advent_of_code/aoc2018-23-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-23 :var input_data=input-2018-23 :tangle /tmp/advent_of_code/aoc2018-23-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-23 :var input_data=input-2018-23 :tangle /tmp/advent_of_code/aoc2018-23-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-23 :var input_data=input-2018-23 :tangle /tmp/advent_of_code/aoc2018-23-2.pl :results output 
#+end_src
*** Day 24: Immune System Simulator 20XX
**** Part 1
***** Description
The portly man explains that this reindeer's immune system isn't similar to regular reindeer immune systems:
The ~immune system~ and the ~infection~ each have <span title="On second thought, it's pretty similar to regular reindeer immune systems.">an army</span> made up of several ~groups~; each ~group~ consists of one or more identical ~units~.  The armies repeatedly ~fight~ until only one army has units remaining.
~Units~ within a group all have the same ~hit points~ (amount of damage a unit can take before it is destroyed), ~attack damage~ (the amount of damage each unit deals), an ~attack type~, an ~initiative~ (higher initiative units attack first and win ties), and sometimes ~weaknesses~ or ~immunities~. Here is an example group:

#+begin_src text
18 units each with 729 hit points (weak to fire; immune to cold, slashing)
 with an attack that does 8 radiation damage at initiative 10

#+end_src

Each group also has an ~effective power~: the number of units in that group multiplied by their attack damage. The above group has an effective power of 18 * 8 = 144. Groups never have zero or negative units; instead, the group is removed from combat.
Each ~fight~ consists of two phases: ~target selection~ and ~attacking~.
During the ~target selection~ phase, each group attempts to choose one target. In decreasing order of effective power, groups choose their targets; in a tie, the group with the higher initiative chooses first. The attacking group chooses to target the group in the enemy army to which it would deal the most damage (after accounting for weaknesses and immunities, but not accounting for whether the defending group has enough units to actually receive all of that damage).
If an attacking group is considering two defending groups to which it would deal equal damage, it chooses to target the defending group with the largest effective power; if there is still a tie, it chooses the defending group with the highest initiative.  If it cannot deal any defending groups damage, it does not choose a target.  Defending groups can only be chosen as a target by one attacking group.
At the end of the target selection phase, each group has selected zero or one groups to attack, and each group is being attacked by zero or one groups.
During the ~attacking~ phase, each group deals damage to the target it selected, if any. Groups attack in decreasing order of initiative, regardless of whether they are part of the infection or the immune system. (If a group contains no units, it cannot attack.)
The damage an attacking group deals to a defending group depends on the attacking group's attack type and the defending group's immunities and weaknesses.  By default, an attacking group would deal damage equal to its ~effective power~ to the defending group.  However, if the defending group is ~immune~ to the attacking group's attack type, the defending group instead takes ~no damage~; if the defending group is ~weak~ to the attacking group's attack type, the defending group instead takes ~double damage~.
The defending group only loses ~whole units~ from damage; damage is always dealt in such a way that it kills the most units possible, and any remaining damage to a unit that does not immediately kill it is ignored. For example, if a defending group contains 10 units with 10 hit points each and receives 75 damage, it loses exactly 7 units and is left with 3 units at full health.
After the fight is over, if both armies still contain units, a new fight begins; combat only ends once one army has lost all of its units.
For example, consider the following armies:

#+begin_src text
Immune System:
17 units each with 5390 hit points (weak to radiation, bludgeoning) with
 an attack that does 4507 fire damage at initiative 2
989 units each with 1274 hit points (immune to fire; weak to bludgeoning,
 slashing) with an attack that does 25 slashing damage at initiative 3

Infection:
801 units each with 4706 hit points (weak to radiation) with an attack
 that does 116 bludgeoning damage at initiative 1
4485 units each with 2961 hit points (immune to radiation; weak to fire,
 cold) with an attack that does 12 slashing damage at initiative 4

#+end_src

If these armies were to enter combat, the following fights, including details during the target selection and attacking phases, would take place:

#+begin_src text
Immune System:
Group 1 contains 17 units
Group 2 contains 989 units
Infection:
Group 1 contains 801 units
Group 2 contains 4485 units

Infection group 1 would deal defending group 1 185832 damage
Infection group 1 would deal defending group 2 185832 damage
Infection group 2 would deal defending group 2 107640 damage
Immune System group 1 would deal defending group 1 76619 damage
Immune System group 1 would deal defending group 2 153238 damage
Immune System group 2 would deal defending group 1 24725 damage

Infection group 2 attacks defending group 2, killing 84 units
Immune System group 2 attacks defending group 1, killing 4 units
Immune System group 1 attacks defending group 2, killing 51 units
Infection group 1 attacks defending group 1, killing 17 units

#+end_src


#+begin_src text
Immune System:
Group 2 contains 905 units
Infection:
Group 1 contains 797 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 184904 damage
Immune System group 2 would deal defending group 1 22625 damage
Immune System group 2 would deal defending group 2 22625 damage

Immune System group 2 attacks defending group 1, killing 4 units
Infection group 1 attacks defending group 2, killing 144 units

#+end_src


#+begin_src text
Immune System:
Group 2 contains 761 units
Infection:
Group 1 contains 793 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 183976 damage
Immune System group 2 would deal defending group 1 19025 damage
Immune System group 2 would deal defending group 2 19025 damage

Immune System group 2 attacks defending group 1, killing 4 units
Infection group 1 attacks defending group 2, killing 143 units

#+end_src


#+begin_src text
Immune System:
Group 2 contains 618 units
Infection:
Group 1 contains 789 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 183048 damage
Immune System group 2 would deal defending group 1 15450 damage
Immune System group 2 would deal defending group 2 15450 damage

Immune System group 2 attacks defending group 1, killing 3 units
Infection group 1 attacks defending group 2, killing 143 units

#+end_src


#+begin_src text
Immune System:
Group 2 contains 475 units
Infection:
Group 1 contains 786 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 182352 damage
Immune System group 2 would deal defending group 1 11875 damage
Immune System group 2 would deal defending group 2 11875 damage

Immune System group 2 attacks defending group 1, killing 2 units
Infection group 1 attacks defending group 2, killing 142 units

#+end_src


#+begin_src text
Immune System:
Group 2 contains 333 units
Infection:
Group 1 contains 784 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 181888 damage
Immune System group 2 would deal defending group 1 8325 damage
Immune System group 2 would deal defending group 2 8325 damage

Immune System group 2 attacks defending group 1, killing 1 unit
Infection group 1 attacks defending group 2, killing 142 units

#+end_src


#+begin_src text
Immune System:
Group 2 contains 191 units
Infection:
Group 1 contains 783 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 181656 damage
Immune System group 2 would deal defending group 1 4775 damage
Immune System group 2 would deal defending group 2 4775 damage

Immune System group 2 attacks defending group 1, killing 1 unit
Infection group 1 attacks defending group 2, killing 142 units

#+end_src


#+begin_src text
Immune System:
Group 2 contains 49 units
Infection:
Group 1 contains 782 units
Group 2 contains 4434 units

Infection group 1 would deal defending group 2 181424 damage
Immune System group 2 would deal defending group 1 1225 damage
Immune System group 2 would deal defending group 2 1225 damage

Immune System group 2 attacks defending group 1, killing 0 units
Infection group 1 attacks defending group 2, killing 49 units

#+end_src


#+begin_src text
Immune System:
No groups remain.
Infection:
Group 1 contains 782 units
Group 2 contains 4434 units

#+end_src

In the example above, the winning army ends up with 782 + 4434 = ~5216~ units.
You scan the reindeer's condition (your puzzle input); the white-bearded man looks nervous.  As it stands now, ~how many units would the winning army have~?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-24 :var input_data=input-2018-24 :tangle /tmp/advent_of_code/aoc2018-24-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-24 :var input_data=input-2018-24 :tangle /tmp/advent_of_code/aoc2018-24-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-24 :var input_data=input-2018-24 :tangle /tmp/advent_of_code/aoc2018-24-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-24 :var input_data=input-2018-24 :tangle /tmp/advent_of_code/aoc2018-24-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-24 :var input_data=input-2018-24 :tangle /tmp/advent_of_code/aoc2018-24-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-24 :var input_data=input-2018-24 :tangle /tmp/advent_of_code/aoc2018-24-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-24 :var input_data=input-2018-24 :tangle /tmp/advent_of_code/aoc2018-24-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-24 :var input_data=input-2018-24 :tangle /tmp/advent_of_code/aoc2018-24-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-24 :var input_data=input-2018-24 :tangle /tmp/advent_of_code/aoc2018-24-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-24 :var input_data=input-2018-24 :tangle /tmp/advent_of_code/aoc2018-24-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-24 :var input_data=input-2018-24 :tangle /tmp/advent_of_code/aoc2018-24-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-24 :var input_data=input-2018-24 :tangle /tmp/advent_of_code/aoc2018-24-2.pl :results output 
#+end_src
*** Day 25: Four-Dimensional Adventure
**** Part 1
***** Description
As you reach down, the reindeer looks up at you, <span title="It was not an accident.">accidentally</span> bumping a button on your wrist-mounted device with its nose in the process - a button labeled ~"help"~.
"Hello, and welcome to the Time Travel Support Hotline! If you are lost in time and space, press 1. If you are trapped in a time paradox, press 2. If you need help caring for a sick reindeer, press 3. If you--"
~Beep.~
A few seconds later, you hear a new voice. "Hello; please state the nature of your reindeer." You try to describe the situation.
"Just a moment, I think I can remotely run a diagnostic scan." A beam of light projects from the device and sweeps over the reindeer a few times.
"Okay, it looks like your reindeer is very low on magical energy; it should fully recover if we can fix that.  Let me check your timeline for a source.... Got one. There's actually a powerful source of magical energy about 1000 years forward from you, and at roughly your position, too!  It looks like... hot chocolate?  Anyway, you should be able to travel there to pick some up; just don't forget a mug!  Is there anything else I can help you with today?"
You explain that your device isn't capable of going forward in time.  "I... see. That's tricky. Well, according to this information, your device should have the necessary hardware to open a small portal and send some hot chocolate back to you. You'll need a list of ~fixed points in spacetime~; I'm transmitting it to you now."
"You just need to align your device to the constellations of fixed points so that it can lock on to the destination and open the portal. Let me look up how much hot chocolate that breed of reindeer needs."
"It says here that your particular reindeer is-- this can't be right, it says there's only one like that in the universe!  But THAT means that you're--" You disconnect the call.
The list of fixed points in spacetime (your puzzle input) is a set of four-dimensional coordinates. To align your device, acquire the hot chocolate, and save the reindeer, you just need to find the ~number of constellations~ of points in the list.
Two points are in the same ~constellation~ if their manhattan distance apart is ~no more than 3~ or if they can form a chain of points, each a manhattan distance no more than 3 from the last, between the two of them. (That is, if a point is close enough to a constellation, it "joins" that constellation.) For example:

#+begin_src text
 0,0,0,0
 3,0,0,0
 0,3,0,0
 0,0,3,0
 0,0,0,3
 0,0,0,6
 9,0,0,0
12,0,0,0

#+end_src

In the above list, the first six points form a single constellation: 0,0,0,0 is exactly distance 3 from the next four, and the point at 0,0,0,6 is connected to the others by being 3 away from 0,0,0,3, which is already in the constellation. The bottom two points, 9,0,0,0 and 12,0,0,0 are in a separate constellation because no point is close enough to connect them to the first constellation.  So, in the above list, the number of constellations is ~2~.  (If a point at 6,0,0,0 were present, it would connect 3,0,0,0 and 9,0,0,0, merging all of the points into a single giant constellation instead.)
In this example, the number of constellations is 4:

#+begin_src text
-1,2,2,0
0,0,2,-2
0,0,0,-2
-1,2,0,0
-2,-2,-2,2
3,0,2,-1
-1,3,2,2
-1,0,-1,0
0,2,1,-2
3,0,0,0

#+end_src

In this one, it's 3:

#+begin_src text
1,-1,0,1
2,0,-1,0
3,2,-1,0
0,0,3,1
0,0,-1,-1
2,3,-2,0
-2,2,0,0
2,-2,0,-1
1,-1,0,-1
3,2,0,2

#+end_src

Finally, in this one, it's 8:

#+begin_src text
1,-1,-1,-2
-2,-2,0,1
0,2,1,3
-2,3,-2,1
0,2,3,-2
-1,-1,1,-2
0,-2,-1,0
-2,2,3,-1
1,2,2,0
-1,-2,0,-2

#+end_src

The portly man nervously strokes his white beard. It's time to get that hot chocolate.
~How many constellations are formed by the fixed points in spacetime?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-25 :var input_data=input-2018-25 :tangle /tmp/advent_of_code/aoc2018-25-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-25 :var input_data=input-2018-25 :tangle /tmp/advent_of_code/aoc2018-25-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-25 :var input_data=input-2018-25 :tangle /tmp/advent_of_code/aoc2018-25-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-25 :var input_data=input-2018-25 :tangle /tmp/advent_of_code/aoc2018-25-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-25 :var input_data=input-2018-25 :tangle /tmp/advent_of_code/aoc2018-25-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-25 :var input_data=input-2018-25 :tangle /tmp/advent_of_code/aoc2018-25-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2018-25 :var input_data=input-2018-25 :tangle /tmp/advent_of_code/aoc2018-25-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2018-25 :var input_data=input-2018-25 :tangle /tmp/advent_of_code/aoc2018-25-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2018-25 :var input_data=input-2018-25 :tangle /tmp/advent_of_code/aoc2018-25-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2018-25 :var input_data=input-2018-25 :tangle /tmp/advent_of_code/aoc2018-25-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2018-25 :var input_data=input-2018-25 :tangle /tmp/advent_of_code/aoc2018-25-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2018-25 :var input_data=input-2018-25 :tangle /tmp/advent_of_code/aoc2018-25-2.pl :results output 
#+end_src
** 2019
*** Day 01: The Tyranny of the Rocket Equation
**** Part 1
***** Description
Collect stars by solving puzzles.  Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first.  Each puzzle grants <em class="star">one star~. Good luck!
The Elves quickly load you into a spacecraft and prepare to launch.
At the first Go / No Go poll, every Elf is Go until the Fuel Counter-Upper.  They haven't determined the amount of fuel required yet.
Fuel required to launch a given ~module~ is based on its ~mass~.  Specifically, to find the fuel required for a module, take its mass, divide by three, round down, and subtract 2.
For example:

~For a mass of 12, divide by 3 and round down to get 4, then subtract 2 to get 2.~
~For a mass of 14, dividing by 3 and rounding down still yields 4, so the fuel required is also 2.~
~For a mass of 1969, the fuel required is 654.~
~For a mass of 100756, the fuel required is 33583.~

The Fuel Counter-Upper needs to know the total fuel requirement.  To find it, individually calculate the fuel needed for the mass of each module (your puzzle input), then add together all the fuel values.
~What is the sum of the fuel requirements~ for all of the modules on your spacecraft?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-01 :var input_data=input-2019-01 :tangle /tmp/advent_of_code/aoc2019-01-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-01 :var input_data=input-2019-01 :tangle /tmp/advent_of_code/aoc2019-01-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-01 :var input_data=input-2019-01 :tangle /tmp/advent_of_code/aoc2019-01-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-01 :var input_data=input-2019-01 :tangle /tmp/advent_of_code/aoc2019-01-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-01 :var input_data=input-2019-01 :tangle /tmp/advent_of_code/aoc2019-01-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-01 :var input_data=input-2019-01 :tangle /tmp/advent_of_code/aoc2019-01-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-01 :var input_data=input-2019-01 :tangle /tmp/advent_of_code/aoc2019-01-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-01 :var input_data=input-2019-01 :tangle /tmp/advent_of_code/aoc2019-01-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-01 :var input_data=input-2019-01 :tangle /tmp/advent_of_code/aoc2019-01-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-01 :var input_data=input-2019-01 :tangle /tmp/advent_of_code/aoc2019-01-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-01 :var input_data=input-2019-01 :tangle /tmp/advent_of_code/aoc2019-01-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-01 :var input_data=input-2019-01 :tangle /tmp/advent_of_code/aoc2019-01-2.pl :results output 
#+end_src
*** Day 02: 1202 Program Alarm
**** Part 1
***** Description
You notify the Elves that the computer's <a href="https://en.wikipedia.org/wiki/Magic_smoke">magic smoke</a> seems to have <span title="Looks like SOMEONE forgot to change the switch to 'more magic'.">escaped</span>. "That computer ran ~Intcode~ programs like the gravity assist program it was working on; surely there are enough spare parts up there to build a new Intcode computer!"
An Intcode program is a list of <a href="https://en.wikipedia.org/wiki/Integer">integers</a> separated by commas (like 1,0,0,3,99).  To run one, start by looking at the first integer (called position 0). Here, you will find an ~opcode~ - either 1, 2, or 99. The opcode indicates what to do; for example, 99 means that the program is finished and should immediately halt. Encountering an unknown opcode means something went wrong.
Opcode 1 ~adds~ together numbers read from two positions and stores the result in a third position. The three integers ~immediately after~ the opcode tell you these three positions - the first two indicate the ~positions~ from which you should read the input values, and the third indicates the ~position~ at which the output should be stored.
For example, if your Intcode computer encounters 1,10,20,30, it should read the values at positions 10 and 20, add those values, and then overwrite the value at position 30 with their sum.
Opcode 2 works exactly like opcode 1, except it ~multiplies~ the two inputs instead of adding them. Again, the three integers after the opcode indicate ~where~ the inputs and outputs are, not their values.
Once you're done processing an opcode, ~move to the next one~ by stepping forward 4 positions.
For example, suppose you have the following program:

#+begin_src text
1,9,10,3,2,3,11,0,99,30,40,50
#+end_src

For the purposes of illustration, here is the same program split into multiple lines:

#+begin_src text
1,9,10,3,
2,3,11,0,
99,
30,40,50

#+end_src

The first four integers, 1,9,10,3, are at positions 0, 1, 2, and 3. Together, they represent the first opcode (1, addition), the positions of the two inputs (9 and 10), and the position of the output (3).  To handle this opcode, you first need to get the values at the input positions: position 9 contains 30, and position 10 contains 40.  ~Add~ these numbers together to get 70.  Then, store this value at the output position; here, the output position (3) is ~at~ position 3, so it overwrites itself.  Afterward, the program looks like this:

#+begin_src text
1,9,10,~70~,
2,3,11,0,
99,
30,40,50

#+end_src

Step forward 4 positions to reach the next opcode, 2. This opcode works just like the previous, but it multiplies instead of adding.  The inputs are at positions 3 and 11; these positions contain 70 and 50 respectively. Multiplying these produces 3500; this is stored at position 0:

#+begin_src text
~3500~,9,10,70,
2,3,11,0,
99,
30,40,50

#+end_src

Stepping forward 4 more positions arrives at opcode 99, halting the program.
Here are the initial and final states of a few more small programs:

~1,0,0,0,99 becomes ~2~,0,0,0,99 (1 + 1 = 2).~
~2,3,0,3,99 becomes 2,3,0,~6~,99 (3 * 2 = 6).~
~2,4,4,5,99,0 becomes 2,4,4,5,99,~9801~ (99 * 99 = 9801).~
~1,1,1,4,99,5,6,0,99 becomes ~30~,1,1,4,~2~,5,6,0,99.~

Once you have a working computer, the first step is to restore the gravity assist program (your puzzle input) to the "1202 program alarm" state it had just before the last computer caught fire. To do this, ~before running the program~, replace position 1 with the value 12 and replace position 2 with the value 2. ~What value is left at position 0~ after the program halts?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-02 :var input_data=input-2019-02 :tangle /tmp/advent_of_code/aoc2019-02-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-02 :var input_data=input-2019-02 :tangle /tmp/advent_of_code/aoc2019-02-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-02 :var input_data=input-2019-02 :tangle /tmp/advent_of_code/aoc2019-02-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-02 :var input_data=input-2019-02 :tangle /tmp/advent_of_code/aoc2019-02-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-02 :var input_data=input-2019-02 :tangle /tmp/advent_of_code/aoc2019-02-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-02 :var input_data=input-2019-02 :tangle /tmp/advent_of_code/aoc2019-02-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-02 :var input_data=input-2019-02 :tangle /tmp/advent_of_code/aoc2019-02-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-02 :var input_data=input-2019-02 :tangle /tmp/advent_of_code/aoc2019-02-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-02 :var input_data=input-2019-02 :tangle /tmp/advent_of_code/aoc2019-02-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-02 :var input_data=input-2019-02 :tangle /tmp/advent_of_code/aoc2019-02-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-02 :var input_data=input-2019-02 :tangle /tmp/advent_of_code/aoc2019-02-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-02 :var input_data=input-2019-02 :tangle /tmp/advent_of_code/aoc2019-02-2.pl :results output 
#+end_src
*** Day 03: Crossed Wires
**** Part 1
***** Description
Opening the front panel reveals a jumble of wires. Specifically, ~two wires~ are connected to a central port and extend outward on a grid.  You trace the path each wire takes as it leaves the central port, one wire per line of text (your puzzle input).
The wires <span title="A jumble of twisty little wires, all alike.">twist and turn</span>, but the two wires occasionally cross paths. To fix the circuit, you need to ~find the intersection point closest to the central port~. Because the wires are on a grid, use the <a href="https://en.wikipedia.org/wiki/Taxicab_geometry">Manhattan distance</a> for this measurement. While the wires do technically cross right at the central port where they both start, this point does not count, nor does a wire count as crossing with itself.
For example, if the first wire's path is R8,U5,L5,D3, then starting from the central port (o), it goes right 8, up 5, left 5, and finally down 3:

#+begin_src text
...........
...........
...........
....+----+.
....|....|.
....|....|.
....|....|.
.........|.
.o-------+.
...........

#+end_src

Then, if the second wire's path is U7,R6,D4,L4, it goes up 7, right 6, down 4, and left 4:

#+begin_src text
...........
.+-----+...
.|.....|...
.|..+--X-+.
.|..|..|.|.
.|.-~X~--+.|.
.|..|....|.
.|.......|.
.o-------+.
...........

#+end_src

These wires cross at two locations (marked X), but the lower-left one is closer to the central port: its distance is 3 + 3 = 6.
Here are a few more examples:

~R75,D30,R83,U83,L12,D49,R71,U7,L72<br/>U62,R66,U55,R34,D71,R55,D58,R83 = distance 159~
~R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51<br/>U98,R91,D20,R16,D67,R40,U7,R15,U6,R7 = distance 135~

~What is the Manhattan distance~ from the central port to the closest intersection?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-03 :var input_data=input-2019-03 :tangle /tmp/advent_of_code/aoc2019-03-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-03 :var input_data=input-2019-03 :tangle /tmp/advent_of_code/aoc2019-03-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-03 :var input_data=input-2019-03 :tangle /tmp/advent_of_code/aoc2019-03-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-03 :var input_data=input-2019-03 :tangle /tmp/advent_of_code/aoc2019-03-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-03 :var input_data=input-2019-03 :tangle /tmp/advent_of_code/aoc2019-03-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-03 :var input_data=input-2019-03 :tangle /tmp/advent_of_code/aoc2019-03-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-03 :var input_data=input-2019-03 :tangle /tmp/advent_of_code/aoc2019-03-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-03 :var input_data=input-2019-03 :tangle /tmp/advent_of_code/aoc2019-03-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-03 :var input_data=input-2019-03 :tangle /tmp/advent_of_code/aoc2019-03-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-03 :var input_data=input-2019-03 :tangle /tmp/advent_of_code/aoc2019-03-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-03 :var input_data=input-2019-03 :tangle /tmp/advent_of_code/aoc2019-03-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-03 :var input_data=input-2019-03 :tangle /tmp/advent_of_code/aoc2019-03-2.pl :results output 
#+end_src
*** Day 04: Secure Container
**** Part 1
***** Description
However, they do remember a few key facts about the password:

~It is a six-digit number.~
~The value is within the range given in your puzzle input.~
~Two adjacent digits are the same (like 22 in 1~22~345).~
~Going from left to right, the digits ~never decrease~; they only ever increase or stay the same (like 111123 or 135679).~

Other than the range rule, the following are true:

~111111 meets these criteria (double 11, never decreases).~
~2234~50~ does not meet these criteria (decreasing pair of digits 50).~
~123789 does not meet these criteria (no double).~

~How many different passwords~ within the range given in your puzzle input meet these criteria?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-04 :var input_data=input-2019-04 :tangle /tmp/advent_of_code/aoc2019-04-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-04 :var input_data=input-2019-04 :tangle /tmp/advent_of_code/aoc2019-04-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-04 :var input_data=input-2019-04 :tangle /tmp/advent_of_code/aoc2019-04-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-04 :var input_data=input-2019-04 :tangle /tmp/advent_of_code/aoc2019-04-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-04 :var input_data=input-2019-04 :tangle /tmp/advent_of_code/aoc2019-04-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-04 :var input_data=input-2019-04 :tangle /tmp/advent_of_code/aoc2019-04-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-04 :var input_data=input-2019-04 :tangle /tmp/advent_of_code/aoc2019-04-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-04 :var input_data=input-2019-04 :tangle /tmp/advent_of_code/aoc2019-04-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-04 :var input_data=input-2019-04 :tangle /tmp/advent_of_code/aoc2019-04-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-04 :var input_data=input-2019-04 :tangle /tmp/advent_of_code/aoc2019-04-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-04 :var input_data=input-2019-04 :tangle /tmp/advent_of_code/aoc2019-04-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-04 :var input_data=input-2019-04 :tangle /tmp/advent_of_code/aoc2019-04-2.pl :results output 
#+end_src
*** Day 05: Sunny with a Chance of Asteroids
**** Part 1
***** Description
The Thermal Environment Supervision Terminal (TEST) starts by running a ~diagnostic program~ (your puzzle input).  The TEST diagnostic program will run on <a href="2">your existing Intcode computer</a> after a few modifications:
~First~, you'll need to add ~two new instructions~:

~Opcode 3 takes a single integer as ~input~ and saves it to the position given by its only parameter. For example, the instruction 3,50 would take an input value and store it at address 50.~
~Opcode 4 ~outputs~ the value of its only parameter. For example, the instruction 4,50 would output the value at address 50.~

Programs that use these instructions will come with documentation that explains what should be connected to the input and output. The program 3,0,4,0,99 outputs whatever it gets as input, then halts.
~Second~, you'll need to add support for ~parameter modes~:
Each parameter of an instruction is handled based on its parameter mode.  Right now, your ship computer already understands parameter mode 0, ~position mode~, which causes the parameter to be interpreted as a ~position~ - if the parameter is 50, its value is ~the value stored at address 50 in memory~. Until now, all parameters have been in position mode.
Now, your ship computer will also need to handle parameters in mode 1, ~immediate mode~. In immediate mode, a parameter is interpreted as a ~value~ - if the parameter is 50, its value is simply ~50~.
Parameter modes are stored in the same value as the instruction's opcode.  The opcode is a two-digit number based only on the ones and tens digit of the value, that is, the opcode is the rightmost two digits of the first value in an instruction. Parameter modes are single digits, one per parameter, read right-to-left from the opcode: the first parameter's mode is in the hundreds digit, the second parameter's mode is in the thousands digit, the third parameter's mode is in the ten-thousands digit, and so on. Any missing modes are 0.
For example, consider the program 1002,4,3,4,33.
The first instruction, 1002,4,3,4, is a ~multiply~ instruction - the rightmost two digits of the first value, 02, indicate opcode 2, multiplication.  Then, going right to left, the parameter modes are 0 (hundreds digit), 1 (thousands digit), and 0 (ten-thousands digit, not present and therefore zero):

#+begin_src text
ABCDE
 1002

DE - two-digit opcode,      02 == opcode 2
 C - mode of 1st parameter,  0 == position mode
 B - mode of 2nd parameter,  1 == immediate mode
 A - mode of 3rd parameter,  0 == position mode,
                                  omitted due to being a leading zero

#+end_src

This instruction multiplies its first two parameters.  The first parameter, 4 in position mode, works like it did before - its value is the value stored at address 4 (33). The second parameter, 3 in immediate mode, simply has value 3. The result of this operation, 33 * 3 = 99, is written according to the third parameter, 4 in position mode, which also works like it did before - 99 is written to address 4.
Parameters that an instruction writes to will ~never be in immediate mode~.
~Finally~, some notes:

~It is important to remember that the instruction pointer should increase by ~the number of values in the instruction~ after the instruction finishes. Because of the new instructions, this amount is no longer always 4.~
~Integers can be negative: 1101,100,-1,4,0 is a valid program (find 100 + -1, store the result in position 4).~

The TEST diagnostic program will start by requesting from the user the ID of the system to test by running an ~input~ instruction - provide it 1, the ID for the ship's air conditioner unit.
It will then perform a series of diagnostic tests confirming that various parts of the Intcode computer, like parameter modes, function correctly. For each test, it will run an ~output~ instruction indicating how far the result of the test was from the expected value, where 0 means the test was successful.  Non-zero outputs mean that a function is not working correctly; check the instructions that were run before the output instruction to see which one failed.
Finally, the program will output a ~diagnostic code~ and immediately halt. This final output isn't an error; an output followed immediately by a halt means the program finished.  If all outputs were zero except the diagnostic code, the diagnostic program ran successfully.
After providing 1 to the only input instruction and passing all the tests, ~what diagnostic code does the program produce?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-05 :var input_data=input-2019-05 :tangle /tmp/advent_of_code/aoc2019-05-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-05 :var input_data=input-2019-05 :tangle /tmp/advent_of_code/aoc2019-05-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-05 :var input_data=input-2019-05 :tangle /tmp/advent_of_code/aoc2019-05-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-05 :var input_data=input-2019-05 :tangle /tmp/advent_of_code/aoc2019-05-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-05 :var input_data=input-2019-05 :tangle /tmp/advent_of_code/aoc2019-05-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-05 :var input_data=input-2019-05 :tangle /tmp/advent_of_code/aoc2019-05-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-05 :var input_data=input-2019-05 :tangle /tmp/advent_of_code/aoc2019-05-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-05 :var input_data=input-2019-05 :tangle /tmp/advent_of_code/aoc2019-05-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-05 :var input_data=input-2019-05 :tangle /tmp/advent_of_code/aoc2019-05-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-05 :var input_data=input-2019-05 :tangle /tmp/advent_of_code/aoc2019-05-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-05 :var input_data=input-2019-05 :tangle /tmp/advent_of_code/aoc2019-05-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-05 :var input_data=input-2019-05 :tangle /tmp/advent_of_code/aoc2019-05-2.pl :results output 
#+end_src
*** Day 06: Universal Orbit Map
**** Part 1
***** Description
Except for the universal Center of Mass (COM), every object in space is in orbit around <span title="What do you mean, Kerbal Space Program doesn't have accurate orbital physics?">exactly one other object</span>.  An <a href="https://en.wikipedia.org/wiki/Orbit">orbit</a> looks roughly like this:

#+begin_src text
                  \
                   \
                    |
                    |
AAA--&gt; o            o &lt;--BBB
                    |
                    |
                   /
                  /

#+end_src

In this diagram, the object BBB is in orbit around AAA. The path that BBB takes around AAA (drawn with lines) is only partly shown. In the map data, this orbital relationship is written AAA)BBB, which means "BBB is in orbit around AAA".
Before you use your map data to plot a course, you need to make sure it wasn't corrupted during the download.  To verify maps, the Universal Orbit Map facility uses ~orbit count checksums~ - the total number of ~direct orbits~ (like the one shown above) and ~indirect orbits~.
Whenever A orbits B and B orbits C, then A ~indirectly orbits~ C.  This chain can be any number of objects long: if A orbits B, B orbits C, and C orbits D, then A indirectly orbits D.
For example, suppose you have the following map:

#+begin_src text
COM)B
B)C
C)D
D)E
E)F
B)G
G)H
D)I
E)J
J)K
K)L

#+end_src

Visually, the above map of orbits looks like this:

#+begin_src text
        G - H       J - K - L
       /           /
COM - B - C - D - E - F
               \
                I

#+end_src

In this visual representation, when two objects are connected by a line, the one on the right directly orbits the one on the left.
Here, we can count the total number of orbits as follows:

~D directly orbits C and indirectly orbits B and COM, a total of 3 orbits.~
~L directly orbits K and indirectly orbits J, E, D, C, B, and COM, a total of 7 orbits.~
~COM orbits nothing.~

The total number of direct and indirect orbits in this example is ~42~.
~What is the total number of direct and indirect orbits~ in your map data?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-06 :var input_data=input-2019-06 :tangle /tmp/advent_of_code/aoc2019-06-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-06 :var input_data=input-2019-06 :tangle /tmp/advent_of_code/aoc2019-06-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-06 :var input_data=input-2019-06 :tangle /tmp/advent_of_code/aoc2019-06-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-06 :var input_data=input-2019-06 :tangle /tmp/advent_of_code/aoc2019-06-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-06 :var input_data=input-2019-06 :tangle /tmp/advent_of_code/aoc2019-06-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-06 :var input_data=input-2019-06 :tangle /tmp/advent_of_code/aoc2019-06-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-06 :var input_data=input-2019-06 :tangle /tmp/advent_of_code/aoc2019-06-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-06 :var input_data=input-2019-06 :tangle /tmp/advent_of_code/aoc2019-06-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-06 :var input_data=input-2019-06 :tangle /tmp/advent_of_code/aoc2019-06-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-06 :var input_data=input-2019-06 :tangle /tmp/advent_of_code/aoc2019-06-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-06 :var input_data=input-2019-06 :tangle /tmp/advent_of_code/aoc2019-06-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-06 :var input_data=input-2019-06 :tangle /tmp/advent_of_code/aoc2019-06-2.pl :results output 
#+end_src
*** Day 07: Amplification Circuit
**** Part 1
***** Description
There are five <span title="As you can see, I know exactly how rockets work.">amplifiers connected in series</span>; each one receives an input signal and produces an output signal.  They are connected such that the first amplifier's output leads to the second amplifier's input, the second amplifier's output leads to the third amplifier's input, and so on.  The first amplifier's input value is 0, and the last amplifier's output leads to your ship's thrusters.

#+begin_src text
    O-------O  O-------O  O-------O  O-------O  O-------O
0 -&gt;| Amp A |-&gt;| Amp B |-&gt;| Amp C |-&gt;| Amp D |-&gt;| Amp E |-&gt; (to thrusters)
    O-------O  O-------O  O-------O  O-------O  O-------O

#+end_src

The Elves have sent you some ~Amplifier Controller Software~ (your puzzle input), a program that should run on your <a href="5">existing Intcode computer</a>. Each amplifier will need to run a copy of the program.
When a copy of the program starts running on an amplifier, it will first use an input instruction to ask the amplifier for its current ~phase setting~ (an integer from 0 to 4). Each phase setting is used ~exactly once~, but the Elves can't remember which amplifier needs which phase setting.
The program will then call another input instruction to get the amplifier's input signal, compute the correct output signal, and supply it back to the amplifier with an output instruction. (If the amplifier has not yet received an input signal, it waits until one arrives.)
Your job is to ~find the largest output signal that can be sent to the thrusters~ by trying every possible combination of phase settings on the amplifiers. Make sure that memory is not shared or reused between copies of the program.
For example, suppose you want to try the phase setting sequence 3,1,2,4,0, which would mean setting amplifier A to phase setting 3, amplifier B to setting 1, C to 2, D to 4, and E to 0. Then, you could determine the output signal that gets sent from amplifier E to the thrusters with the following steps:

~Start the copy of the amplifier controller software that will run on amplifier A. At its first input instruction, provide it the amplifier's phase setting, 3.  At its second input instruction, provide it the input signal, 0.  After some calculations, it will use an output instruction to indicate the amplifier's output signal.~
~Start the software for amplifier B. Provide it the phase setting (1) and then whatever output signal was produced from amplifier A. It will then produce a new output signal destined for amplifier C.~
~Start the software for amplifier C, provide the phase setting (2) and the value from amplifier B, then collect its output signal.~
~Run amplifier D's software, provide the phase setting (4) and input value, and collect its output signal.~
~Run amplifier E's software, provide the phase setting (0) and input value, and collect its output signal.~

The final output signal from amplifier E would be sent to the thrusters. However, this phase setting sequence may not have been the best one; another sequence might have sent a higher signal to the thrusters.
Here are some example programs:

~Max thruster signal ~43210~ (from phase setting sequence 4,3,2,1,0):
#+begin_src text
3,15,3,16,1002,16,10,16,1,16,15,15,4,15,99,0,0
#+end_src
~
~Max thruster signal ~54321~ (from phase setting sequence 0,1,2,3,4):
#+begin_src text
3,23,3,24,1002,24,10,24,1002,23,-1,23,<br/>101,5,23,23,1,24,23,23,4,23,99,0,0
#+end_src
~
~Max thruster signal ~65210~ (from phase setting sequence 1,0,4,3,2):
#+begin_src text
3,31,3,32,1002,32,10,32,1001,31,-2,31,1007,31,0,33,<br/>1002,33,7,33,1,33,31,31,1,32,31,31,4,31,99,0,0,0
#+end_src
~

Try every combination of phase settings on the amplifiers.  ~What is the highest signal that can be sent to the thrusters?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-07 :var input_data=input-2019-07 :tangle /tmp/advent_of_code/aoc2019-07-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-07 :var input_data=input-2019-07 :tangle /tmp/advent_of_code/aoc2019-07-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-07 :var input_data=input-2019-07 :tangle /tmp/advent_of_code/aoc2019-07-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-07 :var input_data=input-2019-07 :tangle /tmp/advent_of_code/aoc2019-07-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-07 :var input_data=input-2019-07 :tangle /tmp/advent_of_code/aoc2019-07-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-07 :var input_data=input-2019-07 :tangle /tmp/advent_of_code/aoc2019-07-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-07 :var input_data=input-2019-07 :tangle /tmp/advent_of_code/aoc2019-07-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-07 :var input_data=input-2019-07 :tangle /tmp/advent_of_code/aoc2019-07-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-07 :var input_data=input-2019-07 :tangle /tmp/advent_of_code/aoc2019-07-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-07 :var input_data=input-2019-07 :tangle /tmp/advent_of_code/aoc2019-07-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-07 :var input_data=input-2019-07 :tangle /tmp/advent_of_code/aoc2019-07-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-07 :var input_data=input-2019-07 :tangle /tmp/advent_of_code/aoc2019-07-2.pl :results output 
#+end_src
*** Day 08: Space Image Format
**** Part 1
***** Description
When you reach the rover, you discover that it's already in the process of rebooting! It's just waiting for someone to enter a <a href="https://en.wikipedia.org/wiki/BIOS">BIOS</a> password. The Elf responsible for the rover takes a picture of the password (your puzzle input) and sends it to you via the Digital Sending Network.
Unfortunately, images sent via the Digital Sending Network aren't encoded with any normal encoding; instead, they're encoded in a special Space Image Format.  None of the Elves seem to remember why this is the case. They send you the instructions to decode it.
Images are sent as a series of digits that each represent the color of a single pixel.  The digits fill each row of the image left-to-right, then move downward to the next row, filling rows top-to-bottom until every pixel of the image is filled.
Each image actually consists of a series of identically-sized ~layers~ that are filled in this way. So, the first digit corresponds to the top-left pixel of the first layer, the second digit corresponds to the pixel to the right of that on the same layer, and so on until the last digit, which corresponds to the bottom-right pixel of the last layer.
For example, given an image 3 pixels wide and 2 pixels tall, the image data 123456789012 corresponds to the following image layers:

#+begin_src text
Layer 1: 123
         456

Layer 2: 789
         012

#+end_src

The image you received is ~25 pixels wide and 6 pixels tall~.
To make sure the image wasn't corrupted during transmission, the Elves would like you to find the layer that contains the ~fewest 0 digits~.  On that layer, what is ~the number of 1 digits multiplied by the number of 2 digits?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-08 :var input_data=input-2019-08 :tangle /tmp/advent_of_code/aoc2019-08-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-08 :var input_data=input-2019-08 :tangle /tmp/advent_of_code/aoc2019-08-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-08 :var input_data=input-2019-08 :tangle /tmp/advent_of_code/aoc2019-08-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-08 :var input_data=input-2019-08 :tangle /tmp/advent_of_code/aoc2019-08-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-08 :var input_data=input-2019-08 :tangle /tmp/advent_of_code/aoc2019-08-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-08 :var input_data=input-2019-08 :tangle /tmp/advent_of_code/aoc2019-08-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-08 :var input_data=input-2019-08 :tangle /tmp/advent_of_code/aoc2019-08-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-08 :var input_data=input-2019-08 :tangle /tmp/advent_of_code/aoc2019-08-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-08 :var input_data=input-2019-08 :tangle /tmp/advent_of_code/aoc2019-08-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-08 :var input_data=input-2019-08 :tangle /tmp/advent_of_code/aoc2019-08-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-08 :var input_data=input-2019-08 :tangle /tmp/advent_of_code/aoc2019-08-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-08 :var input_data=input-2019-08 :tangle /tmp/advent_of_code/aoc2019-08-2.pl :results output 
#+end_src
*** Day 09: Sensor Boost
**** Part 1
***** Description
In order to lock on to the signal, you'll need to boost your sensors. The Elves send up the latest ~BOOST~ program - Basic Operation Of System Test.
While BOOST (your puzzle input) is capable of boosting your sensors, for <span title="Oh sure, NOW safety is a priority.">tenuous safety reasons</span>, it refuses to do so until the computer it runs on passes some checks to demonstrate it is a ~complete Intcode computer~.
<a href="5">Your existing Intcode computer</a> is missing one key feature: it needs support for parameters in ~relative mode~.
Parameters in mode 2, ~relative mode~, behave very similarly to parameters in ~position mode~: the parameter is interpreted as a position.  Like position mode, parameters in relative mode can be read from or written to.
The important difference is that relative mode parameters don't count from address 0.  Instead, they count from a value called the ~relative base~. The ~relative base~ starts at 0.
The address a relative mode parameter refers to is itself ~plus~ the current ~relative base~. When the relative base is 0, relative mode parameters and position mode parameters with the same value refer to the same address.
For example, given a relative base of 50, a relative mode parameter of -7 refers to memory address 50 + -7 = ~43~.
The relative base is modified with the ~relative base offset~ instruction:

~Opcode 9 ~adjusts the relative base~ by the value of its only parameter. The relative base increases (or decreases, if the value is negative) by the value of the parameter.~

For example, if the relative base is 2000, then after the instruction 109,19, the relative base would be 2019. If the next instruction were 204,-34, then the value at address 1985 would be output.
Your Intcode computer will also need a few other capabilities:

~The computer's available memory should be much larger than the initial program. Memory beyond the initial program starts with the value 0 and can be read or written like any other memory. (It is invalid to try to access memory at a negative address, though.)~
~The computer should have support for large numbers. Some instructions near the beginning of the BOOST program will verify this capability.~

Here are some example programs that use these features:

~109,1,204,-1,1001,100,1,100,1008,100,16,101,1006,101,0,99 takes no input and produces a <a href="https://en.wikipedia.org/wiki/Quine_(computing)">copy of itself</a> as output.~
~1102,34915192,34915192,7,4,7,99,0 should output a 16-digit number.~
~104,1125899906842624,99 should output the large number in the middle.~

The BOOST program will ask for a single input; run it in test mode by providing it the value 1. It will perform a series of checks on each opcode, output any opcodes (and the associated parameter modes) that seem to be functioning incorrectly, and finally output a BOOST keycode.
Once your Intcode computer is fully functional, the BOOST program should report no malfunctioning opcodes when run in test mode; it should only output a single value, the BOOST keycode. ~What BOOST keycode does it produce?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-09 :var input_data=input-2019-09 :tangle /tmp/advent_of_code/aoc2019-09-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-09 :var input_data=input-2019-09 :tangle /tmp/advent_of_code/aoc2019-09-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-09 :var input_data=input-2019-09 :tangle /tmp/advent_of_code/aoc2019-09-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-09 :var input_data=input-2019-09 :tangle /tmp/advent_of_code/aoc2019-09-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-09 :var input_data=input-2019-09 :tangle /tmp/advent_of_code/aoc2019-09-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-09 :var input_data=input-2019-09 :tangle /tmp/advent_of_code/aoc2019-09-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-09 :var input_data=input-2019-09 :tangle /tmp/advent_of_code/aoc2019-09-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-09 :var input_data=input-2019-09 :tangle /tmp/advent_of_code/aoc2019-09-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-09 :var input_data=input-2019-09 :tangle /tmp/advent_of_code/aoc2019-09-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-09 :var input_data=input-2019-09 :tangle /tmp/advent_of_code/aoc2019-09-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-09 :var input_data=input-2019-09 :tangle /tmp/advent_of_code/aoc2019-09-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-09 :var input_data=input-2019-09 :tangle /tmp/advent_of_code/aoc2019-09-2.pl :results output 
#+end_src
*** Day 10: Monitoring Station
**** Part 1
***** Description
The Elves would like to build a new monitoring station in a nearby area of space; they hand you a map of all of the asteroids in that region (your puzzle input).
The map indicates whether each position is empty (.) or contains an asteroid (#).  The asteroids are much smaller than they appear on the map, and every asteroid is exactly in the center of its marked position.  The asteroids can be described with X,Y coordinates where X is the distance from the left edge and Y is the distance from the top edge (so the top-left corner is 0,0 and the position immediately to its right is 1,0).
Your job is to figure out which asteroid would be the best place to build a ~new monitoring station~. A monitoring station can ~detect~ any asteroid to which it has ~direct line of sight~ - that is, there cannot be another asteroid ~exactly~ between them. This line of sight can be at any angle, not just lines aligned to the grid or <span title="The Elves on Ceres are clearly not concerned with honor.">diagonally</span>. The ~best~ location is the asteroid that can ~detect~ the largest number of other asteroids.
For example, consider the following map:

#+begin_src text
.#..#
.....
#####
....#
...~#~#

#+end_src

The best location for a new monitoring station on this map is the highlighted asteroid at 3,4 because it can detect 8 asteroids, more than any other location. (The only asteroid it cannot detect is the one at 1,0; its view of this asteroid is blocked by the asteroid at 2,2.) All other asteroids are worse locations; they can detect 7 or fewer other asteroids. Here is the number of other asteroids a monitoring station on each asteroid could detect:

#+begin_src text
.7..7
.....
67775
....7
...87

#+end_src

Here is an asteroid (#) and some examples of the ways its line of sight might be blocked. If there were another asteroid at the location of a capital letter, the locations marked with the corresponding lowercase letter would be blocked and could not be detected:

#+begin_src text
#.........
...A......
...B..a...
.EDCG....a
..F.c.b...
.....c....
..efd.c.gb
.......c..
....f...c.
...e..d..c

#+end_src

Here are some larger examples:

~Best is 5,8 with 33 other asteroids detected:

#+begin_src text
......#.#.
#..#.#....
..#######.
.#.#.###..
.#..#.....
..#....#.#
#..#....#.
.##.#..###
##...~#~..#.
.#....####

#+end_src
~
~Best is 1,2 with 35 other asteroids detected:

#+begin_src text
#.#...#.#.
.###....#.
.~#~....#...
##.#.#.#.#
....#.#.#.
.##..###.#
..#...##..
..##....##
......#...
.####.###.

#+end_src
~
~Best is 6,3 with 41 other asteroids detected:

#+begin_src text
.#..#..###
####.###.#
....###.#.
..###.~#~#.#
##.##.#.#.
....###..#
..#.#..#.#
#..#.#.###
.##...##.#
.....#.#..

#+end_src
~
~Best is 11,13 with 210 other asteroids detected:

#+begin_src text
.#..##.###...#######
##.############..##.
.#.######.########.#
.###.#######.####.#.
#####.##.#.##.###.##
..#####..#.#########
####################
#.####....###.#.#.##
##.#################
#####.##.###..####..
..######..##.#######
####.##.####...##..#
.#####..#.######.###
##...#.####~#~#####...
#.##########.#######
.####.#.###.###.#.##
....##.##.###..#####
.#.#.###########.###
#.#.#.#####.####.###
###.##.####.##.#..##

#+end_src
~

Find the best location for a new monitoring station.  ~How many other asteroids can be detected from that location?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-10 :var input_data=input-2019-10 :tangle /tmp/advent_of_code/aoc2019-10-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-10 :var input_data=input-2019-10 :tangle /tmp/advent_of_code/aoc2019-10-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-10 :var input_data=input-2019-10 :tangle /tmp/advent_of_code/aoc2019-10-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-10 :var input_data=input-2019-10 :tangle /tmp/advent_of_code/aoc2019-10-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-10 :var input_data=input-2019-10 :tangle /tmp/advent_of_code/aoc2019-10-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-10 :var input_data=input-2019-10 :tangle /tmp/advent_of_code/aoc2019-10-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-10 :var input_data=input-2019-10 :tangle /tmp/advent_of_code/aoc2019-10-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-10 :var input_data=input-2019-10 :tangle /tmp/advent_of_code/aoc2019-10-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-10 :var input_data=input-2019-10 :tangle /tmp/advent_of_code/aoc2019-10-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-10 :var input_data=input-2019-10 :tangle /tmp/advent_of_code/aoc2019-10-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-10 :var input_data=input-2019-10 :tangle /tmp/advent_of_code/aoc2019-10-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-10 :var input_data=input-2019-10 :tangle /tmp/advent_of_code/aoc2019-10-2.pl :results output 
#+end_src
*** Day 11: Space Police
**** Part 1
***** Description
"Attention, unmarked spacecraft! You are in violation of Space Law! All spacecraft must have a clearly visible ~registration identifier~! You have 24 hours to comply or be sent to <a href="https://www.youtube.com/watch?v=BVn1oQL9sWg&amp;t=5">Space Jail</a>!"
Not wanting to be sent to Space Jail, you radio back to the Elves on Earth for help. Although it takes almost three hours for their reply signal to reach you, they send instructions for how to power up the ~emergency hull painting robot~ and even provide a small <a href="9">Intcode program</a> (your puzzle input) that will cause it to paint your ship appropriately.
There's just one problem: you don't have an emergency hull painting robot.
You'll need to build a new emergency hull painting robot. The robot needs to be able to move around on the grid of square panels on the side of your ship, detect the color of its current panel, and paint its current panel ~black~ or ~white~. (All of the panels are currently ~black~.)
The Intcode program will serve as the brain of the robot. The program uses input instructions to access the robot's camera: provide 0 if the robot is over a ~black~ panel or 1 if the robot is over a ~white~ panel. Then, the program will output two values:

~First, it will output a value indicating the ~color to paint the panel~ the robot is over: 0 means to paint the panel ~black~, and 1 means to paint the panel ~white~.~
~Second, it will output a value indicating the ~direction the robot should turn~: 0 means it should turn ~left 90 degrees~, and 1 means it should turn ~right 90 degrees~.~

After the robot turns, it should always move ~forward exactly one panel~. The robot starts facing ~up~.
The robot will continue running for a while like this and halt when it is finished drawing.  Do not restart the Intcode computer inside the robot during this process.
For example, suppose the robot is about to start running.  Drawing black panels as ., white panels as #, and the robot pointing the direction it is facing (&lt; ^ &gt; v), the initial state and region near the robot looks like this:

#+begin_src text
.....
.....
..^..
.....
.....

#+end_src

The panel under the robot (not visible here because a ^ is shown instead) is also black, and so any input instructions at this point should be provided 0. Suppose the robot eventually outputs 1 (paint white) and then 0 (turn left). After taking these actions and moving forward one panel, the region now looks like this:

#+begin_src text
.....
.....
.&lt;#..
.....
.....

#+end_src

Input instructions should still be provided 0. Next, the robot might output 0 (paint black) and then 0 (turn left):

#+begin_src text
.....
.....
..#..
.v...
.....

#+end_src

After more outputs (1,0, 1,0):

#+begin_src text
.....
.....
..^..
.##..
.....

#+end_src

The robot is now back where it started, but because it is now on a white panel, input instructions should be provided 1.  After several more outputs (0,1, 1,0, 1,0), the area looks like this:

#+begin_src text
.....
..&lt;#.
...#.
.##..
.....

#+end_src

Before you deploy the robot, you should probably have an estimate of the area it will cover: specifically, you need to know the ~number of panels it paints at least once~, regardless of color. In the example above, the robot painted ~6 panels~ at least once. (It painted its starting panel twice, but that panel is <a href="https://www.youtube.com/watch?v=KjsSvjA5TuE">still only counted once</a>; it also never painted the panel it ended on.)
Build a new emergency hull painting robot and run the Intcode program on it. ~How many panels does it paint at least once?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-11 :var input_data=input-2019-11 :tangle /tmp/advent_of_code/aoc2019-11-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-11 :var input_data=input-2019-11 :tangle /tmp/advent_of_code/aoc2019-11-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-11 :var input_data=input-2019-11 :tangle /tmp/advent_of_code/aoc2019-11-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-11 :var input_data=input-2019-11 :tangle /tmp/advent_of_code/aoc2019-11-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-11 :var input_data=input-2019-11 :tangle /tmp/advent_of_code/aoc2019-11-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-11 :var input_data=input-2019-11 :tangle /tmp/advent_of_code/aoc2019-11-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-11 :var input_data=input-2019-11 :tangle /tmp/advent_of_code/aoc2019-11-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-11 :var input_data=input-2019-11 :tangle /tmp/advent_of_code/aoc2019-11-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-11 :var input_data=input-2019-11 :tangle /tmp/advent_of_code/aoc2019-11-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-11 :var input_data=input-2019-11 :tangle /tmp/advent_of_code/aoc2019-11-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-11 :var input_data=input-2019-11 :tangle /tmp/advent_of_code/aoc2019-11-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-11 :var input_data=input-2019-11 :tangle /tmp/advent_of_code/aoc2019-11-2.pl :results output 
#+end_src
*** Day 12: The N-Body Problem
**** Part 1
***** Description
After a brief scan, you calculate the ~position of each moon~ (your puzzle input). You just need to ~simulate their motion~ so you can <span title="Or you could just leave, but where's the fun in that?">avoid them</span>.
Each moon has a 3-dimensional position (x, y, and z) and a 3-dimensional velocity.  The position of each moon is given in your scan; the x, y, and z velocity of each moon starts at 0.
Simulate the motion of the moons in ~time steps~. Within each time step, first update the velocity of every moon by applying ~gravity~. Then, once all moons' velocities have been updated, update the position of every moon by applying ~velocity~. Time progresses by one step once all of the positions are updated.
To apply ~gravity~, consider every ~pair~ of moons. On each axis (x, y, and z), the velocity of each moon changes by ~exactly +1 or -1~ to pull the moons together.  For example, if Ganymede has an x position of 3, and Callisto has a x position of 5, then Ganymede's x velocity ~changes by +1~ (because 5 &gt; 3) and Callisto's x velocity ~changes by -1~ (because 3 &lt; 5). However, if the positions on a given axis are the same, the velocity on that axis ~does not change~ for that pair of moons.
Once all gravity has been applied, apply ~velocity~: simply add the velocity of each moon to its own position. For example, if Europa has a position of x=1, y=2, z=3 and a velocity of x=-2, y=0,z=3, then its new position would be x=-1, y=2, z=6. This process does not modify the velocity of any moon.
For example, suppose your scan reveals the following positions:

#+begin_src text
&lt;x=-1, y=0, z=2&gt;
&lt;x=2, y=-10, z=-7&gt;
&lt;x=4, y=-8, z=8&gt;
&lt;x=3, y=5, z=-1&gt;

#+end_src

Simulating the motion of these moons would produce the following:

#+begin_src text
After 0 steps:
pos=&lt;x=-1, y=  0, z= 2&gt;, vel=&lt;x= 0, y= 0, z= 0&gt;
pos=&lt;x= 2, y=-10, z=-7&gt;, vel=&lt;x= 0, y= 0, z= 0&gt;
pos=&lt;x= 4, y= -8, z= 8&gt;, vel=&lt;x= 0, y= 0, z= 0&gt;
pos=&lt;x= 3, y=  5, z=-1&gt;, vel=&lt;x= 0, y= 0, z= 0&gt;

After 1 step:
pos=&lt;x= 2, y=-1, z= 1&gt;, vel=&lt;x= 3, y=-1, z=-1&gt;
pos=&lt;x= 3, y=-7, z=-4&gt;, vel=&lt;x= 1, y= 3, z= 3&gt;
pos=&lt;x= 1, y=-7, z= 5&gt;, vel=&lt;x=-3, y= 1, z=-3&gt;
pos=&lt;x= 2, y= 2, z= 0&gt;, vel=&lt;x=-1, y=-3, z= 1&gt;

After 2 steps:
pos=&lt;x= 5, y=-3, z=-1&gt;, vel=&lt;x= 3, y=-2, z=-2&gt;
pos=&lt;x= 1, y=-2, z= 2&gt;, vel=&lt;x=-2, y= 5, z= 6&gt;
pos=&lt;x= 1, y=-4, z=-1&gt;, vel=&lt;x= 0, y= 3, z=-6&gt;
pos=&lt;x= 1, y=-4, z= 2&gt;, vel=&lt;x=-1, y=-6, z= 2&gt;

After 3 steps:
pos=&lt;x= 5, y=-6, z=-1&gt;, vel=&lt;x= 0, y=-3, z= 0&gt;
pos=&lt;x= 0, y= 0, z= 6&gt;, vel=&lt;x=-1, y= 2, z= 4&gt;
pos=&lt;x= 2, y= 1, z=-5&gt;, vel=&lt;x= 1, y= 5, z=-4&gt;
pos=&lt;x= 1, y=-8, z= 2&gt;, vel=&lt;x= 0, y=-4, z= 0&gt;

After 4 steps:
pos=&lt;x= 2, y=-8, z= 0&gt;, vel=&lt;x=-3, y=-2, z= 1&gt;
pos=&lt;x= 2, y= 1, z= 7&gt;, vel=&lt;x= 2, y= 1, z= 1&gt;
pos=&lt;x= 2, y= 3, z=-6&gt;, vel=&lt;x= 0, y= 2, z=-1&gt;
pos=&lt;x= 2, y=-9, z= 1&gt;, vel=&lt;x= 1, y=-1, z=-1&gt;

After 5 steps:
pos=&lt;x=-1, y=-9, z= 2&gt;, vel=&lt;x=-3, y=-1, z= 2&gt;
pos=&lt;x= 4, y= 1, z= 5&gt;, vel=&lt;x= 2, y= 0, z=-2&gt;
pos=&lt;x= 2, y= 2, z=-4&gt;, vel=&lt;x= 0, y=-1, z= 2&gt;
pos=&lt;x= 3, y=-7, z=-1&gt;, vel=&lt;x= 1, y= 2, z=-2&gt;

After 6 steps:
pos=&lt;x=-1, y=-7, z= 3&gt;, vel=&lt;x= 0, y= 2, z= 1&gt;
pos=&lt;x= 3, y= 0, z= 0&gt;, vel=&lt;x=-1, y=-1, z=-5&gt;
pos=&lt;x= 3, y=-2, z= 1&gt;, vel=&lt;x= 1, y=-4, z= 5&gt;
pos=&lt;x= 3, y=-4, z=-2&gt;, vel=&lt;x= 0, y= 3, z=-1&gt;

After 7 steps:
pos=&lt;x= 2, y=-2, z= 1&gt;, vel=&lt;x= 3, y= 5, z=-2&gt;
pos=&lt;x= 1, y=-4, z=-4&gt;, vel=&lt;x=-2, y=-4, z=-4&gt;
pos=&lt;x= 3, y=-7, z= 5&gt;, vel=&lt;x= 0, y=-5, z= 4&gt;
pos=&lt;x= 2, y= 0, z= 0&gt;, vel=&lt;x=-1, y= 4, z= 2&gt;

After 8 steps:
pos=&lt;x= 5, y= 2, z=-2&gt;, vel=&lt;x= 3, y= 4, z=-3&gt;
pos=&lt;x= 2, y=-7, z=-5&gt;, vel=&lt;x= 1, y=-3, z=-1&gt;
pos=&lt;x= 0, y=-9, z= 6&gt;, vel=&lt;x=-3, y=-2, z= 1&gt;
pos=&lt;x= 1, y= 1, z= 3&gt;, vel=&lt;x=-1, y= 1, z= 3&gt;

After 9 steps:
pos=&lt;x= 5, y= 3, z=-4&gt;, vel=&lt;x= 0, y= 1, z=-2&gt;
pos=&lt;x= 2, y=-9, z=-3&gt;, vel=&lt;x= 0, y=-2, z= 2&gt;
pos=&lt;x= 0, y=-8, z= 4&gt;, vel=&lt;x= 0, y= 1, z=-2&gt;
pos=&lt;x= 1, y= 1, z= 5&gt;, vel=&lt;x= 0, y= 0, z= 2&gt;

After 10 steps:
pos=&lt;x= 2, y= 1, z=-3&gt;, vel=&lt;x=-3, y=-2, z= 1&gt;
pos=&lt;x= 1, y=-8, z= 0&gt;, vel=&lt;x=-1, y= 1, z= 3&gt;
pos=&lt;x= 3, y=-6, z= 1&gt;, vel=&lt;x= 3, y= 2, z=-3&gt;
pos=&lt;x= 2, y= 0, z= 4&gt;, vel=&lt;x= 1, y=-1, z=-1&gt;

#+end_src

Then, it might help to calculate the ~total energy in the system~. The total energy for a single moon is its ~potential energy~ multiplied by its ~kinetic energy~. A moon's ~potential energy~ is the sum of the <a href="https://en.wikipedia.org/wiki/Absolute_value">absolute values</a> of its x, y, and z position coordinates. A moon's ~kinetic energy~ is the sum of the absolute values of its velocity coordinates.  Below, each line shows the calculations for a moon's potential energy (pot), kinetic energy (kin), and total energy:

#+begin_src text
Energy after 10 steps:
pot: 2 + 1 + 3 =  6;   kin: 3 + 2 + 1 = 6;   total:  6 * 6 = 36
pot: 1 + 8 + 0 =  9;   kin: 1 + 1 + 3 = 5;   total:  9 * 5 = 45
pot: 3 + 6 + 1 = 10;   kin: 3 + 2 + 3 = 8;   total: 10 * 8 = 80
pot: 2 + 0 + 4 =  6;   kin: 1 + 1 + 1 = 3;   total:  6 * 3 = 18
Sum of total energy: 36 + 45 + 80 + 18 = ~179~

#+end_src

In the above example, adding together the total energy for all moons after 10 steps produces the total energy in the system, ~179~.
Here's a second example:

#+begin_src text
&lt;x=-8, y=-10, z=0&gt;
&lt;x=5, y=5, z=10&gt;
&lt;x=2, y=-7, z=3&gt;
&lt;x=9, y=-8, z=-3&gt;

#+end_src

Every ten steps of simulation for 100 steps produces:

#+begin_src text
After 0 steps:
pos=&lt;x= -8, y=-10, z=  0&gt;, vel=&lt;x=  0, y=  0, z=  0&gt;
pos=&lt;x=  5, y=  5, z= 10&gt;, vel=&lt;x=  0, y=  0, z=  0&gt;
pos=&lt;x=  2, y= -7, z=  3&gt;, vel=&lt;x=  0, y=  0, z=  0&gt;
pos=&lt;x=  9, y= -8, z= -3&gt;, vel=&lt;x=  0, y=  0, z=  0&gt;

After 10 steps:
pos=&lt;x= -9, y=-10, z=  1&gt;, vel=&lt;x= -2, y= -2, z= -1&gt;
pos=&lt;x=  4, y= 10, z=  9&gt;, vel=&lt;x= -3, y=  7, z= -2&gt;
pos=&lt;x=  8, y=-10, z= -3&gt;, vel=&lt;x=  5, y= -1, z= -2&gt;
pos=&lt;x=  5, y=-10, z=  3&gt;, vel=&lt;x=  0, y= -4, z=  5&gt;

After 20 steps:
pos=&lt;x=-10, y=  3, z= -4&gt;, vel=&lt;x= -5, y=  2, z=  0&gt;
pos=&lt;x=  5, y=-25, z=  6&gt;, vel=&lt;x=  1, y=  1, z= -4&gt;
pos=&lt;x= 13, y=  1, z=  1&gt;, vel=&lt;x=  5, y= -2, z=  2&gt;
pos=&lt;x=  0, y=  1, z=  7&gt;, vel=&lt;x= -1, y= -1, z=  2&gt;

After 30 steps:
pos=&lt;x= 15, y= -6, z= -9&gt;, vel=&lt;x= -5, y=  4, z=  0&gt;
pos=&lt;x= -4, y=-11, z=  3&gt;, vel=&lt;x= -3, y=-10, z=  0&gt;
pos=&lt;x=  0, y= -1, z= 11&gt;, vel=&lt;x=  7, y=  4, z=  3&gt;
pos=&lt;x= -3, y= -2, z=  5&gt;, vel=&lt;x=  1, y=  2, z= -3&gt;

After 40 steps:
pos=&lt;x= 14, y=-12, z= -4&gt;, vel=&lt;x= 11, y=  3, z=  0&gt;
pos=&lt;x= -1, y= 18, z=  8&gt;, vel=&lt;x= -5, y=  2, z=  3&gt;
pos=&lt;x= -5, y=-14, z=  8&gt;, vel=&lt;x=  1, y= -2, z=  0&gt;
pos=&lt;x=  0, y=-12, z= -2&gt;, vel=&lt;x= -7, y= -3, z= -3&gt;

After 50 steps:
pos=&lt;x=-23, y=  4, z=  1&gt;, vel=&lt;x= -7, y= -1, z=  2&gt;
pos=&lt;x= 20, y=-31, z= 13&gt;, vel=&lt;x=  5, y=  3, z=  4&gt;
pos=&lt;x= -4, y=  6, z=  1&gt;, vel=&lt;x= -1, y=  1, z= -3&gt;
pos=&lt;x= 15, y=  1, z= -5&gt;, vel=&lt;x=  3, y= -3, z= -3&gt;

After 60 steps:
pos=&lt;x= 36, y=-10, z=  6&gt;, vel=&lt;x=  5, y=  0, z=  3&gt;
pos=&lt;x=-18, y= 10, z=  9&gt;, vel=&lt;x= -3, y= -7, z=  5&gt;
pos=&lt;x=  8, y=-12, z= -3&gt;, vel=&lt;x= -2, y=  1, z= -7&gt;
pos=&lt;x=-18, y= -8, z= -2&gt;, vel=&lt;x=  0, y=  6, z= -1&gt;

After 70 steps:
pos=&lt;x=-33, y= -6, z=  5&gt;, vel=&lt;x= -5, y= -4, z=  7&gt;
pos=&lt;x= 13, y= -9, z=  2&gt;, vel=&lt;x= -2, y= 11, z=  3&gt;
pos=&lt;x= 11, y= -8, z=  2&gt;, vel=&lt;x=  8, y= -6, z= -7&gt;
pos=&lt;x= 17, y=  3, z=  1&gt;, vel=&lt;x= -1, y= -1, z= -3&gt;

After 80 steps:
pos=&lt;x= 30, y= -8, z=  3&gt;, vel=&lt;x=  3, y=  3, z=  0&gt;
pos=&lt;x= -2, y= -4, z=  0&gt;, vel=&lt;x=  4, y=-13, z=  2&gt;
pos=&lt;x=-18, y= -7, z= 15&gt;, vel=&lt;x= -8, y=  2, z= -2&gt;
pos=&lt;x= -2, y= -1, z= -8&gt;, vel=&lt;x=  1, y=  8, z=  0&gt;

After 90 steps:
pos=&lt;x=-25, y= -1, z=  4&gt;, vel=&lt;x=  1, y= -3, z=  4&gt;
pos=&lt;x=  2, y= -9, z=  0&gt;, vel=&lt;x= -3, y= 13, z= -1&gt;
pos=&lt;x= 32, y= -8, z= 14&gt;, vel=&lt;x=  5, y= -4, z=  6&gt;
pos=&lt;x= -1, y= -2, z= -8&gt;, vel=&lt;x= -3, y= -6, z= -9&gt;

After 100 steps:
pos=&lt;x=  8, y=-12, z= -9&gt;, vel=&lt;x= -7, y=  3, z=  0&gt;
pos=&lt;x= 13, y= 16, z= -3&gt;, vel=&lt;x=  3, y=-11, z= -5&gt;
pos=&lt;x=-29, y=-11, z= -1&gt;, vel=&lt;x= -3, y=  7, z=  4&gt;
pos=&lt;x= 16, y=-13, z= 23&gt;, vel=&lt;x=  7, y=  1, z=  1&gt;

Energy after 100 steps:
pot:  8 + 12 +  9 = 29;   kin: 7 +  3 + 0 = 10;   total: 29 * 10 = 290
pot: 13 + 16 +  3 = 32;   kin: 3 + 11 + 5 = 19;   total: 32 * 19 = 608
pot: 29 + 11 +  1 = 41;   kin: 3 +  7 + 4 = 14;   total: 41 * 14 = 574
pot: 16 + 13 + 23 = 52;   kin: 7 +  1 + 1 =  9;   total: 52 *  9 = 468
Sum of total energy: 290 + 608 + 574 + 468 = ~1940~

#+end_src

~What is the total energy in the system~ after simulating the moons given in your scan for 1000 steps?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-12 :var input_data=input-2019-12 :tangle /tmp/advent_of_code/aoc2019-12-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-12 :var input_data=input-2019-12 :tangle /tmp/advent_of_code/aoc2019-12-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-12 :var input_data=input-2019-12 :tangle /tmp/advent_of_code/aoc2019-12-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-12 :var input_data=input-2019-12 :tangle /tmp/advent_of_code/aoc2019-12-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-12 :var input_data=input-2019-12 :tangle /tmp/advent_of_code/aoc2019-12-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-12 :var input_data=input-2019-12 :tangle /tmp/advent_of_code/aoc2019-12-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-12 :var input_data=input-2019-12 :tangle /tmp/advent_of_code/aoc2019-12-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-12 :var input_data=input-2019-12 :tangle /tmp/advent_of_code/aoc2019-12-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-12 :var input_data=input-2019-12 :tangle /tmp/advent_of_code/aoc2019-12-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-12 :var input_data=input-2019-12 :tangle /tmp/advent_of_code/aoc2019-12-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-12 :var input_data=input-2019-12 :tangle /tmp/advent_of_code/aoc2019-12-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-12 :var input_data=input-2019-12 :tangle /tmp/advent_of_code/aoc2019-12-2.pl :results output 
#+end_src
*** Day 13: Care Package
**** Part 1
***** Description
It's a new game for the ship's <a href="https://en.wikipedia.org/wiki/Arcade_cabinet">arcade cabinet</a>! Unfortunately, the arcade is ~all the way~ on the other end of the ship. Surely, it won't be hard to build your own - the care package even comes with schematics.
The arcade cabinet runs <a href="9">Intcode</a> software like the game the Elves sent (your puzzle input). It has a primitive screen capable of drawing square ~tiles~ on a grid.  The software draws tiles to the screen with output instructions: every three output instructions specify the x position (distance from the left), y position (distance from the top), and tile id. The tile id is interpreted as follows:

~0 is an ~empty~ tile.  No game object appears in this tile.~
~1 is a ~wall~ tile.  Walls are indestructible barriers.~
~2 is a ~block~ tile.  Blocks can be broken by the ball.~
~3 is a ~horizontal paddle~ tile.  The paddle is indestructible.~
~4 is a ~ball~ tile.  The ball moves diagonally and bounces off objects.~

For example, a sequence of output values like 1,2,3,6,5,4 would draw a ~horizontal paddle~ tile (1 tile from the left and 2 tiles from the top) and a ~ball~ tile (6 tiles from the left and 5 tiles from the top).
Start the game. ~How many block tiles are on the screen when the game exits?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-13 :var input_data=input-2019-13 :tangle /tmp/advent_of_code/aoc2019-13-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-13 :var input_data=input-2019-13 :tangle /tmp/advent_of_code/aoc2019-13-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-13 :var input_data=input-2019-13 :tangle /tmp/advent_of_code/aoc2019-13-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-13 :var input_data=input-2019-13 :tangle /tmp/advent_of_code/aoc2019-13-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-13 :var input_data=input-2019-13 :tangle /tmp/advent_of_code/aoc2019-13-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-13 :var input_data=input-2019-13 :tangle /tmp/advent_of_code/aoc2019-13-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-13 :var input_data=input-2019-13 :tangle /tmp/advent_of_code/aoc2019-13-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-13 :var input_data=input-2019-13 :tangle /tmp/advent_of_code/aoc2019-13-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-13 :var input_data=input-2019-13 :tangle /tmp/advent_of_code/aoc2019-13-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-13 :var input_data=input-2019-13 :tangle /tmp/advent_of_code/aoc2019-13-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-13 :var input_data=input-2019-13 :tangle /tmp/advent_of_code/aoc2019-13-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-13 :var input_data=input-2019-13 :tangle /tmp/advent_of_code/aoc2019-13-2.pl :results output 
#+end_src
*** Day 14: Space Stoichiometry
**** Part 1
***** Description
You ask the nanofactory to produce a list of the ~reactions~ it can perform that are relevant to this process (your puzzle input). Every reaction turns some quantities of specific ~input chemicals~ into some quantity of an ~output chemical~. Almost every ~chemical~ is produced by exactly one reaction; the only exception, ORE, is the raw material input to the entire process and is not produced by a reaction.
You just need to know how much ~ORE~ you'll need to collect before you can produce one unit of ~FUEL~.
Each reaction gives specific quantities for its inputs and output; reactions cannot be partially run, so only whole integer multiples of these quantities can be used.  (It's okay to have leftover chemicals when you're done, though.) For example, the reaction 1 A, 2 B, 3 C =&gt; 2 D means that exactly 2 units of chemical D can be produced by consuming exactly 1 A, 2 B and 3 C.  You can run the full reaction as many times as necessary; for example, you could produce 10 D by consuming 5 A, 10 B, and 15 C.
Suppose your nanofactory produces the following list of reactions:

#+begin_src text
10 ORE =&gt; 10 A
1 ORE =&gt; 1 B
7 A, 1 B =&gt; 1 C
7 A, 1 C =&gt; 1 D
7 A, 1 D =&gt; 1 E
7 A, 1 E =&gt; 1 FUEL

#+end_src

The first two reactions use only ORE as inputs; they indicate that you can produce as much of chemical A as you want (in increments of 10 units, each 10 costing 10 ORE) and as much of chemical B as you want (each costing 1 ORE).  To produce 1 FUEL, a total of ~31~ ORE is required: 1 ORE to produce 1 B, then 30 more ORE to produce the 7 + 7 + 7 + 7 = 28 A (with 2 extra A wasted) required in the reactions to convert the B into C, C into D, D into E, and finally E into FUEL. (30 A is produced because its reaction requires that it is created in increments of 10.)
Or, suppose you have the following list of reactions:

#+begin_src text
9 ORE =&gt; 2 A
8 ORE =&gt; 3 B
7 ORE =&gt; 5 C
3 A, 4 B =&gt; 1 AB
5 B, 7 C =&gt; 1 BC
4 C, 1 A =&gt; 1 CA
2 AB, 3 BC, 4 CA =&gt; 1 FUEL

#+end_src

The above list of reactions requires ~165~ ORE to produce 1 FUEL:

~Consume 45 ORE to produce 10 A.~
~Consume 64 ORE to produce 24 B.~
~Consume 56 ORE to produce 40 C.~
~Consume 6 A, 8 B to produce 2 AB.~
~Consume 15 B, 21 C to produce 3 BC.~
~Consume 16 C, 4 A to produce 4 CA.~
~Consume 2 AB, 3 BC, 4 CA to produce 1 FUEL.~

Here are some larger examples:

~~13312~ ORE for 1 FUEL:

#+begin_src text
157 ORE =&gt; 5 NZVS
165 ORE =&gt; 6 DCFZ
44 XJWVT, 5 KHKGT, 1 QDVJ, 29 NZVS, 9 GPVTF, 48 HKGWZ =&gt; 1 FUEL
12 HKGWZ, 1 GPVTF, 8 PSHF =&gt; 9 QDVJ
179 ORE =&gt; 7 PSHF
177 ORE =&gt; 5 HKGWZ
7 DCFZ, 7 PSHF =&gt; 2 XJWVT
165 ORE =&gt; 2 GPVTF
3 DCFZ, 7 NZVS, 5 HKGWZ, 10 PSHF =&gt; 8 KHKGT

#+end_src
~
~~180697~ ORE for 1 FUEL:

#+begin_src text
2 VPVL, 7 FWMGM, 2 CXFTF, 11 MNCFX =&gt; 1 STKFG
17 NVRVD, 3 JNWZP =&gt; 8 VPVL
53 STKFG, 6 MNCFX, 46 VJHF, 81 HVMC, 68 CXFTF, 25 GNMV =&gt; 1 FUEL
22 VJHF, 37 MNCFX =&gt; 5 FWMGM
139 ORE =&gt; 4 NVRVD
144 ORE =&gt; 7 JNWZP
5 MNCFX, 7 RFSQX, 2 FWMGM, 2 VPVL, 19 CXFTF =&gt; 3 HVMC
5 VJHF, 7 MNCFX, 9 VPVL, 37 CXFTF =&gt; 6 GNMV
145 ORE =&gt; 6 MNCFX
1 NVRVD =&gt; 8 CXFTF
1 VJHF, 6 MNCFX =&gt; 4 RFSQX
176 ORE =&gt; 6 VJHF

#+end_src
~
~~2210736~ ORE for 1 FUEL:

#+begin_src text
171 ORE =&gt; 8 CNZTR
7 ZLQW, 3 BMBT, 9 XCVML, 26 XMNCP, 1 WPTQ, 2 MZWV, 1 RJRHP =&gt; 4 PLWSL
114 ORE =&gt; 4 BHXH
14 VRPVC =&gt; 6 BMBT
6 BHXH, 18 KTJDG, 12 WPTQ, 7 PLWSL, 31 FHTLT, 37 ZDVW =&gt; 1 FUEL
6 WPTQ, 2 BMBT, 8 ZLQW, 18 KTJDG, 1 XMNCP, 6 MZWV, 1 RJRHP =&gt; 6 FHTLT
15 XDBXC, 2 LTCX, 1 VRPVC =&gt; 6 ZLQW
13 WPTQ, 10 LTCX, 3 RJRHP, 14 XMNCP, 2 MZWV, 1 ZLQW =&gt; 1 ZDVW
5 BMBT =&gt; 4 WPTQ
189 ORE =&gt; 9 KTJDG
1 MZWV, 17 XDBXC, 3 XCVML =&gt; 2 XMNCP
12 VRPVC, 27 CNZTR =&gt; 2 XDBXC
15 KTJDG, 12 BHXH =&gt; 5 XCVML
3 BHXH, 2 VRPVC =&gt; 7 MZWV
121 ORE =&gt; 7 VRPVC
7 XCVML =&gt; 6 RJRHP
5 BHXH, 4 VRPVC =&gt; 5 LTCX

#+end_src
~

Given the list of reactions in your puzzle input, ~what is the minimum amount of ORE required to produce exactly 1 FUEL?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-14 :var input_data=input-2019-14 :tangle /tmp/advent_of_code/aoc2019-14-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-14 :var input_data=input-2019-14 :tangle /tmp/advent_of_code/aoc2019-14-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-14 :var input_data=input-2019-14 :tangle /tmp/advent_of_code/aoc2019-14-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-14 :var input_data=input-2019-14 :tangle /tmp/advent_of_code/aoc2019-14-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-14 :var input_data=input-2019-14 :tangle /tmp/advent_of_code/aoc2019-14-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-14 :var input_data=input-2019-14 :tangle /tmp/advent_of_code/aoc2019-14-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-14 :var input_data=input-2019-14 :tangle /tmp/advent_of_code/aoc2019-14-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-14 :var input_data=input-2019-14 :tangle /tmp/advent_of_code/aoc2019-14-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-14 :var input_data=input-2019-14 :tangle /tmp/advent_of_code/aoc2019-14-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-14 :var input_data=input-2019-14 :tangle /tmp/advent_of_code/aoc2019-14-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-14 :var input_data=input-2019-14 :tangle /tmp/advent_of_code/aoc2019-14-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-14 :var input_data=input-2019-14 :tangle /tmp/advent_of_code/aoc2019-14-2.pl :results output 
#+end_src
*** Day 15: Oxygen System
**** Part 1
***** Description
According to the readouts, the oxygen system must have failed days ago after a rupture in oxygen tank two; that section of the ship was automatically sealed once oxygen levels went dangerously low. A single remotely-operated ~repair droid~ is your only option for fixing the oxygen system.
The Elves' care package included an <a href="9">Intcode</a> program (your puzzle input) that you can use to remotely control the repair droid. By running that program, you can direct the repair droid to the oxygen system and fix the problem.
The remote control program executes the following steps in a loop forever:

~Accept a ~movement command~ via an input instruction.~
~Send the movement command to the repair droid.~
~Wait for the repair droid to finish the movement operation.~
~Report on the ~status~ of the repair droid via an output instruction.~

Only four ~movement commands~ are understood: north (1), south (2), west (3), and east (4). Any other command is invalid. The movements differ in direction, but not in distance: in a long enough east-west hallway, a series of commands like 4,4,4,4,3,3,3,3 would leave the repair droid back where it started.
The repair droid can reply with any of the following ~status~ codes:

~0: The repair droid hit a wall. Its position has not changed.~
~1: The repair droid has moved one step in the requested direction.~
~2: The repair droid has moved one step in the requested direction; its new position is the location of the oxygen system.~

You don't know anything about the area around the repair droid, but you can figure it out by watching the status codes.
For example, we can draw the area using D for the droid, # for walls, . for locations the droid can traverse, and empty space for unexplored locations.  Then, the initial state looks like this:

#+begin_src text
      
      
   D  
      
      

#+end_src

To make the droid go north, send it 1. If it replies with 0, you know that location is a wall and that the droid didn't move:

#+begin_src text
      
   #  
   D  
      
      

#+end_src

To move east, send 4; a reply of 1 means the movement was successful:

#+begin_src text
      
   #  
   .D 
      
      

#+end_src

Then, perhaps attempts to move north (1), south (2), and east (4) are all met with replies of 0:

#+begin_src text
      
   ## 
   .D#
    # 
      

#+end_src

Now, you know the repair droid is in a dead end. Backtrack with 3 (which you already know will get a reply of 1 because you already know that location is open):

#+begin_src text
      
   ## 
   D.#
    # 
      

#+end_src

Then, perhaps west (3) gets a reply of 0, south (2) gets a reply of 1, south again (2) gets a reply of 0, and then west (3) gets a reply of 2:

#+begin_src text
      
   ## 
  #..#
  D.# 
   #  

#+end_src

Now, because of the reply of 2, you know you've found the ~oxygen system~! In this example, it was only ~2~ moves away from the repair droid's starting position.
~What is the fewest number of movement commands~ required to move the repair droid from its starting position to the location of the oxygen system?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-15 :var input_data=input-2019-15 :tangle /tmp/advent_of_code/aoc2019-15-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-15 :var input_data=input-2019-15 :tangle /tmp/advent_of_code/aoc2019-15-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-15 :var input_data=input-2019-15 :tangle /tmp/advent_of_code/aoc2019-15-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-15 :var input_data=input-2019-15 :tangle /tmp/advent_of_code/aoc2019-15-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-15 :var input_data=input-2019-15 :tangle /tmp/advent_of_code/aoc2019-15-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-15 :var input_data=input-2019-15 :tangle /tmp/advent_of_code/aoc2019-15-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-15 :var input_data=input-2019-15 :tangle /tmp/advent_of_code/aoc2019-15-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-15 :var input_data=input-2019-15 :tangle /tmp/advent_of_code/aoc2019-15-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-15 :var input_data=input-2019-15 :tangle /tmp/advent_of_code/aoc2019-15-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-15 :var input_data=input-2019-15 :tangle /tmp/advent_of_code/aoc2019-15-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-15 :var input_data=input-2019-15 :tangle /tmp/advent_of_code/aoc2019-15-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-15 :var input_data=input-2019-15 :tangle /tmp/advent_of_code/aoc2019-15-2.pl :results output 
#+end_src
*** Day 16: Flawed Frequency Transmission
**** Part 1
***** Description
As input, FFT takes a list of numbers.  In the signal you received (your puzzle input), each number is a single digit: data like 15243 represents the sequence 1, 5, 2, 4, 3.
FFT operates in repeated ~phases~.  In each phase, a new list is constructed with the same length as the input list.  This new list is also used as the input for the next phase.
Each element in the new list is built by multiplying every value in the input list by a value in a repeating ~pattern~ and then adding up the results. So, if the input list were 9, 8, 7, 6, 5 and the pattern for a given element were 1, 2, 3, the result would be 9*1 + 8*2 + 7*3 + 6*1 + 5*2 (with each input element on the left and each value in the repeating pattern on the right of each multiplication). Then, only the ones digit is kept: 38 becomes 8, -17 becomes 7, and so on.
While each element in the output array uses all of the same input array elements, the actual repeating pattern to use depends on ~which output element~ is being calculated. The base pattern is 0, 1, 0, -1.  Then, repeat each value in the pattern a number of times equal to the ~position in the output list~ being considered. Repeat once for the first element, twice for the second element, three times for the third element, and so on.  So, if the third element of the output list is being calculated, repeating the values would produce: 0, 0, 0, 1, 1, 1, 0, 0, 0, -1, -1, -1.
When applying the pattern, skip the very first value exactly once. (In other words, offset the whole pattern left by one.) So, for the second element of the output list, the actual pattern used would be: 0, 1, 1, 0, 0, -1, -1, 0, 0, 1, 1, 0, 0, -1, -1, ....
After using this process to calculate each element of the output list, the phase is complete, and the output list of this phase is used as the new input list for the next phase, if any.
Given the input signal 12345678, below are four phases of FFT. Within each phase, each output digit is calculated on a single line with the result at the far right; each multiplication operation shows the input digit on the left and the pattern value on the right:

#+begin_src text
Input signal: 12345678

1*1  + 2*0  + 3*-1 + 4*0  + 5*1  + 6*0  + 7*-1 + 8*0  = 4
1*0  + 2*1  + 3*1  + 4*0  + 5*0  + 6*-1 + 7*-1 + 8*0  = 8
1*0  + 2*0  + 3*1  + 4*1  + 5*1  + 6*0  + 7*0  + 8*0  = 2
1*0  + 2*0  + 3*0  + 4*1  + 5*1  + 6*1  + 7*1  + 8*0  = 2
1*0  + 2*0  + 3*0  + 4*0  + 5*1  + 6*1  + 7*1  + 8*1  = 6
1*0  + 2*0  + 3*0  + 4*0  + 5*0  + 6*1  + 7*1  + 8*1  = 1
1*0  + 2*0  + 3*0  + 4*0  + 5*0  + 6*0  + 7*1  + 8*1  = 5
1*0  + 2*0  + 3*0  + 4*0  + 5*0  + 6*0  + 7*0  + 8*1  = 8

After 1 phase: 48226158

4*1  + 8*0  + 2*-1 + 2*0  + 6*1  + 1*0  + 5*-1 + 8*0  = 3
4*0  + 8*1  + 2*1  + 2*0  + 6*0  + 1*-1 + 5*-1 + 8*0  = 4
4*0  + 8*0  + 2*1  + 2*1  + 6*1  + 1*0  + 5*0  + 8*0  = 0
4*0  + 8*0  + 2*0  + 2*1  + 6*1  + 1*1  + 5*1  + 8*0  = 4
4*0  + 8*0  + 2*0  + 2*0  + 6*1  + 1*1  + 5*1  + 8*1  = 0
4*0  + 8*0  + 2*0  + 2*0  + 6*0  + 1*1  + 5*1  + 8*1  = 4
4*0  + 8*0  + 2*0  + 2*0  + 6*0  + 1*0  + 5*1  + 8*1  = 3
4*0  + 8*0  + 2*0  + 2*0  + 6*0  + 1*0  + 5*0  + 8*1  = 8

After 2 phases: 34040438

3*1  + 4*0  + 0*-1 + 4*0  + 0*1  + 4*0  + 3*-1 + 8*0  = 0
3*0  + 4*1  + 0*1  + 4*0  + 0*0  + 4*-1 + 3*-1 + 8*0  = 3
3*0  + 4*0  + 0*1  + 4*1  + 0*1  + 4*0  + 3*0  + 8*0  = 4
3*0  + 4*0  + 0*0  + 4*1  + 0*1  + 4*1  + 3*1  + 8*0  = 1
3*0  + 4*0  + 0*0  + 4*0  + 0*1  + 4*1  + 3*1  + 8*1  = 5
3*0  + 4*0  + 0*0  + 4*0  + 0*0  + 4*1  + 3*1  + 8*1  = 5
3*0  + 4*0  + 0*0  + 4*0  + 0*0  + 4*0  + 3*1  + 8*1  = 1
3*0  + 4*0  + 0*0  + 4*0  + 0*0  + 4*0  + 3*0  + 8*1  = 8

After 3 phases: 03415518

0*1  + 3*0  + 4*-1 + 1*0  + 5*1  + 5*0  + 1*-1 + 8*0  = 0
0*0  + 3*1  + 4*1  + 1*0  + 5*0  + 5*-1 + 1*-1 + 8*0  = 1
0*0  + 3*0  + 4*1  + 1*1  + 5*1  + 5*0  + 1*0  + 8*0  = 0
0*0  + 3*0  + 4*0  + 1*1  + 5*1  + 5*1  + 1*1  + 8*0  = 2
0*0  + 3*0  + 4*0  + 1*0  + 5*1  + 5*1  + 1*1  + 8*1  = 9
0*0  + 3*0  + 4*0  + 1*0  + 5*0  + 5*1  + 1*1  + 8*1  = 4
0*0  + 3*0  + 4*0  + 1*0  + 5*0  + 5*0  + 1*1  + 8*1  = 9
0*0  + 3*0  + 4*0  + 1*0  + 5*0  + 5*0  + 1*0  + 8*1  = 8

After 4 phases: 01029498

#+end_src

Here are the first eight digits of the final output list after 100 phases for some larger inputs:

~80871224585914546619083218645595 becomes 24176176.~
~19617804207202209144916044189917 becomes 73745418.~
~69317163492948606335995924319873 becomes 52432133.~

After ~100~ phases of FFT, ~what are the first eight digits in the final output list?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-16 :var input_data=input-2019-16 :tangle /tmp/advent_of_code/aoc2019-16-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-16 :var input_data=input-2019-16 :tangle /tmp/advent_of_code/aoc2019-16-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-16 :var input_data=input-2019-16 :tangle /tmp/advent_of_code/aoc2019-16-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-16 :var input_data=input-2019-16 :tangle /tmp/advent_of_code/aoc2019-16-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-16 :var input_data=input-2019-16 :tangle /tmp/advent_of_code/aoc2019-16-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-16 :var input_data=input-2019-16 :tangle /tmp/advent_of_code/aoc2019-16-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-16 :var input_data=input-2019-16 :tangle /tmp/advent_of_code/aoc2019-16-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-16 :var input_data=input-2019-16 :tangle /tmp/advent_of_code/aoc2019-16-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-16 :var input_data=input-2019-16 :tangle /tmp/advent_of_code/aoc2019-16-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-16 :var input_data=input-2019-16 :tangle /tmp/advent_of_code/aoc2019-16-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-16 :var input_data=input-2019-16 :tangle /tmp/advent_of_code/aoc2019-16-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-16 :var input_data=input-2019-16 :tangle /tmp/advent_of_code/aoc2019-16-2.pl :results output 
#+end_src
*** Day 17: Set and Forget
**** Part 1
***** Description
The only tools at your disposal are some wired cameras and a small vacuum robot currently asleep at its charging station. The video quality is poor, but the vacuum robot has a needlessly bright LED that makes it easy to spot no matter where it is.
An <a href="9">Intcode</a> program, the ~Aft Scaffolding Control and Information Interface~ (ASCII, your puzzle input), provides access to the cameras and the vacuum robot.  Currently, because the vacuum robot is asleep, you can only access the cameras.
Running the ASCII program on your Intcode computer will provide the current view of the scaffolds.  This is output, <span title="PURELY COINCIDENTALLY">purely coincidentally</span>, as <a href="https://simple.wikipedia.org/wiki/ASCII">ASCII code</a>: 35 means #, 46 means ., 10 starts a <a href="https://en.wikipedia.org/wiki/Newline#In_programming_languages">new line</a> of output below the current one, and so on. (Within a line, characters are drawn left-to-right.)
In the camera output, # represents a scaffold and . represents open space. The vacuum robot is visible as ^, v, &lt;, or &gt; depending on whether it is facing up, down, left, or right respectively. When drawn like this, the vacuum robot is ~always on a scaffold~; if the vacuum robot ever walks off of a scaffold and begins ~tumbling through space uncontrollably~, it will instead be visible as X.
In general, the scaffold forms a path, but it sometimes loops back onto itself.  For example, suppose you can see the following view from the cameras:

#+begin_src text
..#..........
..#..........
#######...###
#.#...#...#.#
#############
..#...#...#..
..#####...^..

#+end_src

Here, the vacuum robot, ^ is facing up and sitting at one end of the scaffold near the bottom-right of the image. The scaffold continues up, loops across itself several times, and ends at the top-left of the image.
The first step is to calibrate the cameras by getting the ~alignment parameters~ of some well-defined points.  Locate all ~scaffold intersections~; for each, its alignment parameter is the distance between its left edge and the left edge of the view multiplied by the distance between its top edge and the top edge of the view.  Here, the intersections from the above image are marked O:

#+begin_src text
..#..........
..#..........
##O####...###
#.#...#...#.#
##O###O###O##
..#...#...#..
..#####...^..

#+end_src

For these intersections:

~The top-left intersection is 2 units from the left of the image and 2 units from the top of the image, so its alignment parameter is 2 * 2 = ~4~.~
~The bottom-left intersection is 2 units from the left and 4 units from the top, so its alignment parameter is 2 * 4 = ~8~.~
~The bottom-middle intersection is 6 from the left and 4 from the top, so its alignment parameter is ~24~.~
~The bottom-right intersection's alignment parameter is ~40~.~

To calibrate the cameras, you need the ~sum of the alignment parameters~.  In the above example, this is ~76~.
Run your ASCII program. ~What is the sum of the alignment parameters~ for the scaffold intersections?
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-17 :var input_data=input-2019-17 :tangle /tmp/advent_of_code/aoc2019-17-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-17 :var input_data=input-2019-17 :tangle /tmp/advent_of_code/aoc2019-17-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-17 :var input_data=input-2019-17 :tangle /tmp/advent_of_code/aoc2019-17-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-17 :var input_data=input-2019-17 :tangle /tmp/advent_of_code/aoc2019-17-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-17 :var input_data=input-2019-17 :tangle /tmp/advent_of_code/aoc2019-17-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-17 :var input_data=input-2019-17 :tangle /tmp/advent_of_code/aoc2019-17-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-17 :var input_data=input-2019-17 :tangle /tmp/advent_of_code/aoc2019-17-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-17 :var input_data=input-2019-17 :tangle /tmp/advent_of_code/aoc2019-17-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-17 :var input_data=input-2019-17 :tangle /tmp/advent_of_code/aoc2019-17-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-17 :var input_data=input-2019-17 :tangle /tmp/advent_of_code/aoc2019-17-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-17 :var input_data=input-2019-17 :tangle /tmp/advent_of_code/aoc2019-17-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-17 :var input_data=input-2019-17 :tangle /tmp/advent_of_code/aoc2019-17-2.pl :results output 
#+end_src
*** Day 18: Many-Worlds Interpretation
**** Part 1
***** Description
A scan of the local area reveals only one interesting feature: a massive underground vault.  You generate a map of the tunnels (your puzzle input).  The tunnels are too narrow to move diagonally.
Only one ~entrance~ (marked @) is present among the ~open passages~ (marked .) and ~stone walls~ (#), but you also detect an assortment of ~keys~ (shown as lowercase letters) and ~doors~ (shown as uppercase letters). Keys of a given letter open the door of the same letter: a opens A, b opens B, and so on.  You aren't sure which key you need to disable the tractor beam, so you'll need to ~collect all of them~.
For example, suppose you have the following map:

#+begin_src text
#########
#b.A.@.a#
#########

#+end_src

Starting from the entrance (@), you can only access a large door (A) and a key (a). Moving toward the door doesn't help you, but you can move 2 steps to collect the key, unlocking A in the process:

#+begin_src text
#########
#b.....@#
#########

#+end_src

Then, you can move 6 steps to collect the only other key, b:

#+begin_src text
#########
#@......#
#########

#+end_src

So, collecting every key took a total of ~8~ steps.
Here is a larger example:

#+begin_src text
########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################

#+end_src

The only reasonable move is to take key a and unlock door A:

#+begin_src text
########################
#f.D.E.e.C.b.....@.B.c.#
######################.#
#d.....................#
########################

#+end_src

Then, do the same with key b:

#+begin_src text
########################
#f.D.E.e.C.@.........c.#
######################.#
#d.....................#
########################

#+end_src

...and the same with key c:

#+begin_src text
########################
#f.D.E.e.............@.#
######################.#
#d.....................#
########################

#+end_src

Now, you have a choice between keys d and e.  While key e is closer, collecting it now would be slower in the long run than collecting key d first, so that's the best choice:

#+begin_src text
########################
#f...E.e...............#
######################.#
#@.....................#
########################

#+end_src

Finally, collect key e to unlock door E, then collect key f, taking a grand total of ~86~ steps.
Here are a few more examples:

~
#+begin_src text
########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################

#+end_src

Shortest path is 132 steps: b, a, c, d, f, e, g~
~
#+begin_src text
#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################

#+end_src

Shortest paths are 136 steps;<br/>one is: a, f, b, j, g, n, h, d, l, o, e, p, c, i, k, m~
~
#+begin_src text
########################
#@..............ac.GI.b#
###d#e#f################
###A#B#C################
###g#h#i################
########################

#+end_src

Shortest paths are 81 steps; one is: a, c, f, i, d, g, b, e, h~

~How many steps is the shortest path that collects all of the keys?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-18 :var input_data=input-2019-18 :tangle /tmp/advent_of_code/aoc2019-18-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-18 :var input_data=input-2019-18 :tangle /tmp/advent_of_code/aoc2019-18-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-18 :var input_data=input-2019-18 :tangle /tmp/advent_of_code/aoc2019-18-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-18 :var input_data=input-2019-18 :tangle /tmp/advent_of_code/aoc2019-18-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-18 :var input_data=input-2019-18 :tangle /tmp/advent_of_code/aoc2019-18-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-18 :var input_data=input-2019-18 :tangle /tmp/advent_of_code/aoc2019-18-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-18 :var input_data=input-2019-18 :tangle /tmp/advent_of_code/aoc2019-18-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-18 :var input_data=input-2019-18 :tangle /tmp/advent_of_code/aoc2019-18-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-18 :var input_data=input-2019-18 :tangle /tmp/advent_of_code/aoc2019-18-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-18 :var input_data=input-2019-18 :tangle /tmp/advent_of_code/aoc2019-18-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-18 :var input_data=input-2019-18 :tangle /tmp/advent_of_code/aoc2019-18-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-18 :var input_data=input-2019-18 :tangle /tmp/advent_of_code/aoc2019-18-2.pl :results output 
#+end_src
*** Day 19: Tractor Beam
**** Part 1
***** Description
When you're safely away from anything else, you activate the tractor beam, but nothing happens.  It's hard to tell whether it's working if there's nothing to use it on. Fortunately, your ship's drone system can be configured to deploy a drone to specific coordinates and then check whether it's being pulled. There's even an <a href="9">Intcode</a> program (your puzzle input) that gives you access to the drone system.
The program uses two input instructions to request the ~X and Y position~ to which the drone should be deployed.  Negative numbers are invalid and will confuse the drone; all numbers should be ~zero or positive~.
Then, the program will output whether the drone is ~stationary~ (0) or ~being pulled by something~ (1). For example, the coordinate X=0, Y=0 is directly in front of the tractor beam emitter, so the drone control program will always report 1 at that location.
To better understand the tractor beam, it is important to ~get a good picture~ of the beam itself. For example, suppose you scan the 10x10 grid of points closest to the emitter:

#+begin_src text
       X
  0-&gt;      9
 0#.........
 |.#........
 v..##......
  ...###....
  ....###...
Y .....####.
  ......####
  ......####
  .......###
 9........##

#+end_src

In this example, the ~number of points affected by the tractor beam~ in the 10x10 area closest to the emitter is ~27~.
However, you'll need to scan a larger area to ~understand the shape~ of the beam. ~How many points are affected by the tractor beam in the 50x50 area closest to the emitter?~ (For each of X and Y, this will be 0 through 49.)
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-19 :var input_data=input-2019-19 :tangle /tmp/advent_of_code/aoc2019-19-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-19 :var input_data=input-2019-19 :tangle /tmp/advent_of_code/aoc2019-19-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-19 :var input_data=input-2019-19 :tangle /tmp/advent_of_code/aoc2019-19-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-19 :var input_data=input-2019-19 :tangle /tmp/advent_of_code/aoc2019-19-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-19 :var input_data=input-2019-19 :tangle /tmp/advent_of_code/aoc2019-19-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-19 :var input_data=input-2019-19 :tangle /tmp/advent_of_code/aoc2019-19-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-19 :var input_data=input-2019-19 :tangle /tmp/advent_of_code/aoc2019-19-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-19 :var input_data=input-2019-19 :tangle /tmp/advent_of_code/aoc2019-19-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-19 :var input_data=input-2019-19 :tangle /tmp/advent_of_code/aoc2019-19-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-19 :var input_data=input-2019-19 :tangle /tmp/advent_of_code/aoc2019-19-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-19 :var input_data=input-2019-19 :tangle /tmp/advent_of_code/aoc2019-19-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-19 :var input_data=input-2019-19 :tangle /tmp/advent_of_code/aoc2019-19-2.pl :results output 
#+end_src
*** Day 20: Donut Maze
**** Part 1
***** Description
Because there isn't much space on Pluto, the civilization that used to live here thrived by inventing a method for folding spacetime.  Although the technology is no longer understood, mazes like this one provide a small glimpse into the <span title="So really, this puzzle is more archaeology than math, right?">daily life of an ancient Pluto citizen</span>.
This maze is shaped like a <a href="https://en.wikipedia.org/wiki/Torus">donut</a>. Portals along the inner and outer edge of the donut can instantly teleport you from one side to the other.  For example:

#+begin_src text
         A           
         A           
  #######.#########  
  #######.........#  
  #######.#######.#  
  #######.#######.#  
  #######.#######.#  
  #####  B    ###.#  
BC...##  C    ###.#  
  ##.##       ###.#  
  ##...DE  F  ###.#  
  #####    G  ###.#  
  #########.#####.#  
DE..#######...###.#  
  #.#########.###.#  
FG..#########.....#  
  ###########.#####  
             Z       
             Z       

#+end_src

This map of the maze shows solid walls (#) and open passages (.). Every maze on Pluto has a start (the open tile next to AA) and an end (the open tile next to ZZ). Mazes on Pluto also have portals; this maze has three pairs of portals: BC, DE, and FG. When on an open tile next to one of these labels, a single step can take you to the other tile with the same label. (You can only walk on . tiles; labels and empty space are not traversable.)
One path through the maze doesn't require any portals.  Starting at AA, you could go down 1, right 8, down 12, left 4, and down 1 to reach ZZ, a total of 26 steps.
However, there is a shorter path:  You could walk from AA to the inner BC portal (4 steps), warp to the outer BC portal (1 step), walk to the inner DE (6 steps), warp to the outer DE (1 step), walk to the outer FG (4 steps), warp to the inner FG (1 step), and finally walk to ZZ (6 steps). In total, this is only ~23~ steps.
Here is a larger example:

#+begin_src text
                   A               
                   A               
  #################.#############  
  #.#...#...................#.#.#  
  #.#.#.###.###.###.#########.#.#  
  #.#.#.......#...#.....#.#.#...#  
  #.#########.###.#####.#.#.###.#  
  #.............#.#.....#.......#  
  ###.###########.###.#####.#.#.#  
  #.....#        A   C    #.#.#.#  
  #######        S   P    #####.#  
  #.#...#                 #......VT
  #.#.#.#                 #.#####  
  #...#.#               YN....#.#  
  #.###.#                 #####.#  
DI....#.#                 #.....#  
  #####.#                 #.###.#  
ZZ......#               QG....#..AS
  ###.###                 #######  
JO..#.#.#                 #.....#  
  #.#.#.#                 ###.#.#  
  #...#..DI             BU....#..LF
  #####.#                 #.#####  
YN......#               VT..#....QG
  #.###.#                 #.###.#  
  #.#...#                 #.....#  
  ###.###    J L     J    #.#.###  
  #.....#    O F     P    #.#...#  
  #.###.#####.#.#####.#####.###.#  
  #...#.#.#...#.....#.....#.#...#  
  #.#####.###.###.#.#.#########.#  
  #...#.#.....#...#.#.#.#.....#.#  
  #.###.#####.###.###.#.#.#######  
  #.#.........#...#.............#  
  #########.###.###.#############  
           B   J   C               
           U   P   P               

#+end_src

Here, AA has no direct path to ZZ, but it does connect to AS and CP. By passing through AS, QG, BU, and JO, you can reach ZZ in ~58~ steps.
In your maze, ~how many steps does it take to get from the open tile marked AA to the open tile marked ZZ?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-20 :var input_data=input-2019-20 :tangle /tmp/advent_of_code/aoc2019-20-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-20 :var input_data=input-2019-20 :tangle /tmp/advent_of_code/aoc2019-20-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-20 :var input_data=input-2019-20 :tangle /tmp/advent_of_code/aoc2019-20-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-20 :var input_data=input-2019-20 :tangle /tmp/advent_of_code/aoc2019-20-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-20 :var input_data=input-2019-20 :tangle /tmp/advent_of_code/aoc2019-20-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-20 :var input_data=input-2019-20 :tangle /tmp/advent_of_code/aoc2019-20-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-20 :var input_data=input-2019-20 :tangle /tmp/advent_of_code/aoc2019-20-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-20 :var input_data=input-2019-20 :tangle /tmp/advent_of_code/aoc2019-20-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-20 :var input_data=input-2019-20 :tangle /tmp/advent_of_code/aoc2019-20-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-20 :var input_data=input-2019-20 :tangle /tmp/advent_of_code/aoc2019-20-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-20 :var input_data=input-2019-20 :tangle /tmp/advent_of_code/aoc2019-20-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-20 :var input_data=input-2019-20 :tangle /tmp/advent_of_code/aoc2019-20-2.pl :results output 
#+end_src
*** Day 21: Springdroid Adventure
**** Part 1
***** Description
While experimenting further with the tractor beam, you accidentally pull an asteroid directly into your ship!  It deals significant damage to your hull and causes your ship to begin tumbling violently.
You can send a droid out to investigate, but the tumbling is causing enough <a href="https://en.wikipedia.org/wiki/Artificial_gravity">artificial gravity</a> that one wrong step could send the droid through a hole in the hull and flying out into space.
The clear choice for this mission is a <span title="I picture the Bouncy enemy from Kirby games.">droid</span> that can ~jump~ over the holes in the hull - a ~springdroid~.
You can use an <a href="9">Intcode</a> program (your puzzle input) running on an <a href="17">ASCII-capable</a> computer to <a href="https://en.wikipedia.org/wiki/Programmable_read-only_memory">program</a> the springdroid. However, springdroids don't run Intcode; instead, they run a simplified assembly language called ~springscript~.
While a springdroid is certainly capable of navigating the artificial gravity and giant holes, it has one downside: it can only remember at most ~15~ springscript instructions.
The springdroid will move forward automatically, constantly thinking about ~whether to jump~.  The springscript program defines the logic for this decision.
Springscript programs only use <a href="https://en.wikipedia.org/wiki/Boolean_data_type">Boolean values</a>, not numbers or strings.  Two registers are available: T, the ~temporary value~ register, and J, the ~jump~ register.  If the jump register is ~true~ at the end of the springscript program, the springdroid will try to jump. Both of these registers start with the value ~false~.
Springdroids have a sensor that can detect ~whether there is ground~ at various distances in the direction it is facing; these values are provided in ~read-only registers~.  Your springdroid can detect ground at four distances: one tile away (A), two tiles away (B), three tiles away (C), and four tiles away (D). If there is ground at the given distance, the register will be ~true~; if there is a hole, the register will be ~false~.
There are only ~three instructions~ available in springscript:

~AND X Y sets Y to ~true~ if both X and Y are ~true~; otherwise, it sets Y to ~false~.~
~OR X Y sets Y to ~true~ if at least one of X or Y is ~true~; otherwise, it sets Y to ~false~.~
~NOT X Y sets Y to ~true~ if X is ~false~; otherwise, it sets Y to ~false~.~

In all three instructions, the second argument (Y) needs to be a ~writable register~ (either T or J). The first argument (X) can be ~any register~ (including A, B, C, or D).
For example, the one-instruction program NOT A J means "if the tile immediately in front of me is not ground, jump".
Or, here is a program that jumps if a three-tile-wide hole (with ground on the other side of the hole) is detected:

#+begin_src text
NOT A J
NOT B T
AND T J
NOT C T
AND T J
AND D J

#+end_src

The Intcode program expects ASCII inputs and outputs.  It will begin by displaying a prompt; then, input the desired instructions one per line. End each line with a newline (ASCII code 10). ~When you have finished entering your program~, provide the command WALK followed by a newline to instruct the springdroid to begin surveying the hull.
If the springdroid ~falls into space~, an ASCII rendering of the last moments of its life will be produced.  In these, @ is the springdroid, # is hull, and . is empty space.  For example, suppose you program the springdroid like this:

#+begin_src text
NOT D J
WALK

#+end_src

This one-instruction program sets J to ~true~ if and only if there is no ground four tiles away.  In other words, it attempts to jump into any hole it finds:

#+begin_src text
.................
.................
~@~................
#####.###########

.................
.................
.~@~...............
#####.###########

.................
..~@~..............
.................
#####.###########

...~@~.............
.................
.................
#####.###########

.................
....~@~............
.................
#####.###########

.................
.................
.....~@~...........
#####.###########

.................
.................
.................
#####~@~###########

#+end_src

However, if the springdroid successfully makes it across, it will use an output instruction to indicate the ~amount of damage to the hull~ as a single giant integer outside the normal ASCII range.
Program the springdroid with logic that allows it to survey the hull without falling into space.  ~What amount of hull damage does it report?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-21 :var input_data=input-2019-21 :tangle /tmp/advent_of_code/aoc2019-21-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-21 :var input_data=input-2019-21 :tangle /tmp/advent_of_code/aoc2019-21-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-21 :var input_data=input-2019-21 :tangle /tmp/advent_of_code/aoc2019-21-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-21 :var input_data=input-2019-21 :tangle /tmp/advent_of_code/aoc2019-21-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-21 :var input_data=input-2019-21 :tangle /tmp/advent_of_code/aoc2019-21-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-21 :var input_data=input-2019-21 :tangle /tmp/advent_of_code/aoc2019-21-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-21 :var input_data=input-2019-21 :tangle /tmp/advent_of_code/aoc2019-21-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-21 :var input_data=input-2019-21 :tangle /tmp/advent_of_code/aoc2019-21-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-21 :var input_data=input-2019-21 :tangle /tmp/advent_of_code/aoc2019-21-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-21 :var input_data=input-2019-21 :tangle /tmp/advent_of_code/aoc2019-21-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-21 :var input_data=input-2019-21 :tangle /tmp/advent_of_code/aoc2019-21-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-21 :var input_data=input-2019-21 :tangle /tmp/advent_of_code/aoc2019-21-2.pl :results output 
#+end_src
*** Day 22: Slam Shuffle
**** Part 1
***** Description
Digging through the ship's storage, you find a deck of ~space cards~! Just like <span title="What do you mean, you've never heard of space cards? They're all the rage in Zozo.">any deck of space cards</span>, there are 10007 cards in the deck numbered 0 through 10006. The deck must be new - they're still in ~factory order~, with 0 on the top, then 1, then 2, and so on, all the way through to 10006 on the bottom.
You've been practicing three different ~techniques~ that you use while shuffling. Suppose you have a deck of only 10 cards (numbered 0 through 9):
~To deal into new stack~, create a new stack of cards by dealing the top card of the deck onto the top of the new stack repeatedly until you run out of cards:

#+begin_src text
Top          Bottom
0 1 2 3 4 5 6 7 8 9   Your deck
                      New stack

  1 2 3 4 5 6 7 8 9   Your deck
                  0   New stack

    2 3 4 5 6 7 8 9   Your deck
                1 0   New stack

      3 4 5 6 7 8 9   Your deck
              2 1 0   New stack

Several steps later...

                  9   Your deck
  8 7 6 5 4 3 2 1 0   New stack

                      Your deck
9 8 7 6 5 4 3 2 1 0   New stack

#+end_src

Finally, pick up the new stack you've just created and use it as the deck for the next technique.
~To cut N cards~, take the top N cards off the top of the deck and move them as a single unit to the bottom of the deck, retaining their order. For example, to cut 3:

#+begin_src text
Top          Bottom
0 1 2 3 4 5 6 7 8 9   Your deck

      3 4 5 6 7 8 9   Your deck
0 1 2                 Cut cards

3 4 5 6 7 8 9         Your deck
              0 1 2   Cut cards

3 4 5 6 7 8 9 0 1 2   Your deck

#+end_src

You've also been getting pretty good at a version of this technique where N is negative! In that case, cut (the absolute value of) N cards from the bottom of the deck onto the top.  For example, to cut -4:

#+begin_src text
Top          Bottom
0 1 2 3 4 5 6 7 8 9   Your deck

0 1 2 3 4 5           Your deck
            6 7 8 9   Cut cards

        0 1 2 3 4 5   Your deck
6 7 8 9               Cut cards

6 7 8 9 0 1 2 3 4 5   Your deck

#+end_src

~To deal with increment N~, start by clearing enough space on your table to lay out all of the cards individually in a long line.  Deal the top card into the leftmost position. Then, move N positions to the right and deal the next card there. If you would move into a position past the end of the space on your table, wrap around and keep counting from the leftmost card again.  Continue this process until you run out of cards.
For example, to deal with increment 3:

#+begin_src text

0 1 2 3 4 5 6 7 8 9   Your deck
. . . . . . . . . .   Space on table
^                     Current position

Deal the top card to the current position:

  1 2 3 4 5 6 7 8 9   Your deck
0 . . . . . . . . .   Space on table
^                     Current position

Move the current position right 3:

  1 2 3 4 5 6 7 8 9   Your deck
0 . . . . . . . . .   Space on table
      ^               Current position

Deal the top card:

    2 3 4 5 6 7 8 9   Your deck
0 . . 1 . . . . . .   Space on table
      ^               Current position

Move right 3 and deal:

      3 4 5 6 7 8 9   Your deck
0 . . 1 . . 2 . . .   Space on table
            ^         Current position

Move right 3 and deal:

        4 5 6 7 8 9   Your deck
0 . . 1 . . 2 . . 3   Space on table
                  ^   Current position

Move right 3, wrapping around, and deal:

          5 6 7 8 9   Your deck
0 . 4 1 . . 2 . . 3   Space on table
    ^                 Current position

And so on:

0 7 4 1 8 5 2 9 6 3   Space on table

#+end_src

Positions on the table which already contain cards are still counted; they're not skipped.  Of course, this technique is carefully designed so it will never put two cards in the same position or leave a position empty.
Finally, collect the cards on the table so that the leftmost card ends up at the top of your deck, the card to its right ends up just below the top card, and so on, until the rightmost card ends up at the bottom of the deck.
The complete shuffle process (your puzzle input) consists of applying many of these techniques.  Here are some examples that combine techniques; they all start with a ~factory order~ deck of 10 cards:

#+begin_src text
deal with increment 7
deal into new stack
deal into new stack
Result: 0 3 6 9 2 5 8 1 4 7

#+end_src


#+begin_src text
cut 6
deal with increment 7
deal into new stack
Result: 3 0 7 4 1 8 5 2 9 6

#+end_src


#+begin_src text
deal with increment 7
deal with increment 9
cut -2
Result: 6 3 0 7 4 1 8 5 2 9

#+end_src


#+begin_src text
deal into new stack
cut -2
deal with increment 7
cut 8
cut -4
deal with increment 7
cut 3
deal with increment 9
deal with increment 3
cut -1
Result: 9 2 5 8 1 4 7 0 3 6

#+end_src

Positions within the deck count from 0 at the top, then 1 for the card immediately below the top card, and so on to the bottom.  (That is, cards start in the position matching their number.)
After shuffling your ~factory order~ deck of 10007 cards, ~what is the position of card 2019?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-22 :var input_data=input-2019-22 :tangle /tmp/advent_of_code/aoc2019-22-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-22 :var input_data=input-2019-22 :tangle /tmp/advent_of_code/aoc2019-22-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-22 :var input_data=input-2019-22 :tangle /tmp/advent_of_code/aoc2019-22-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-22 :var input_data=input-2019-22 :tangle /tmp/advent_of_code/aoc2019-22-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-22 :var input_data=input-2019-22 :tangle /tmp/advent_of_code/aoc2019-22-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-22 :var input_data=input-2019-22 :tangle /tmp/advent_of_code/aoc2019-22-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-22 :var input_data=input-2019-22 :tangle /tmp/advent_of_code/aoc2019-22-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-22 :var input_data=input-2019-22 :tangle /tmp/advent_of_code/aoc2019-22-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-22 :var input_data=input-2019-22 :tangle /tmp/advent_of_code/aoc2019-22-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-22 :var input_data=input-2019-22 :tangle /tmp/advent_of_code/aoc2019-22-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-22 :var input_data=input-2019-22 :tangle /tmp/advent_of_code/aoc2019-22-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-22 :var input_data=input-2019-22 :tangle /tmp/advent_of_code/aoc2019-22-2.pl :results output 
#+end_src
*** Day 23: Category Six
**** Part 1
***** Description
You'll need to ~rebuild the network from scratch~.
The computers on the network are standard <a href="9">Intcode</a> computers that communicate by sending ~packets~ to each other.  There are 50 of them in total, each running a copy of the same ~Network Interface Controller~ (NIC) software (your puzzle input). The computers have ~network addresses~ 0 through 49; when each computer boots up, it will request its network address via a single input instruction. Be sure to give each computer a unique network address.
Once a computer has received its network address, it will begin doing work and communicating over the network by sending and receiving ~packets~. All packets contain ~two values~ named X and Y. Packets sent to a computer are queued by the recipient and read in the order they are received.
To ~send~ a packet to another computer, the NIC will use ~three output instructions~ that provide the ~destination address~ of the packet followed by its X and Y values.  For example, three output instructions that provide the values 10, 20, 30 would send a packet with X=20 and Y=30 to the computer with address 10.
To ~receive~ a packet from another computer, the NIC will use an ~input instruction~.  If the incoming packet queue is ~empty~, provide -1.  Otherwise, provide the X value of the next packet; the computer will then use a second input instruction to receive the Y value for the same packet.  Once both values of the packet are read in this way, the packet is removed from the queue.
Note that these input and output instructions never <a href="https://en.wikipedia.org/wiki/Blocking_(computing)">block</a>. Specifically, output instructions do not wait for the sent packet to be received - the computer might send multiple packets before receiving any. Similarly, input instructions do not wait for a packet to arrive - if no packet is waiting, input instructions should receive -1.
Boot up all 50 computers and attach them to your network.  ~What is the Y value of the first packet sent to address 255?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-23 :var input_data=input-2019-23 :tangle /tmp/advent_of_code/aoc2019-23-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-23 :var input_data=input-2019-23 :tangle /tmp/advent_of_code/aoc2019-23-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-23 :var input_data=input-2019-23 :tangle /tmp/advent_of_code/aoc2019-23-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-23 :var input_data=input-2019-23 :tangle /tmp/advent_of_code/aoc2019-23-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-23 :var input_data=input-2019-23 :tangle /tmp/advent_of_code/aoc2019-23-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-23 :var input_data=input-2019-23 :tangle /tmp/advent_of_code/aoc2019-23-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-23 :var input_data=input-2019-23 :tangle /tmp/advent_of_code/aoc2019-23-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-23 :var input_data=input-2019-23 :tangle /tmp/advent_of_code/aoc2019-23-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-23 :var input_data=input-2019-23 :tangle /tmp/advent_of_code/aoc2019-23-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-23 :var input_data=input-2019-23 :tangle /tmp/advent_of_code/aoc2019-23-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-23 :var input_data=input-2019-23 :tangle /tmp/advent_of_code/aoc2019-23-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-23 :var input_data=input-2019-23 :tangle /tmp/advent_of_code/aoc2019-23-2.pl :results output 
#+end_src
*** Day 24: Planet of Discord
**** Part 1
***** Description
Eris isn't a very large place; a scan of the entire area fits into a 5x5 grid (your puzzle input). The scan shows ~bugs~ (#) and ~empty spaces~ (.).
Each ~minute~, The bugs live and die based on the number of bugs in the ~four adjacent tiles~:

~A bug ~dies~ (becoming an empty space) unless there is ~exactly one~ bug adjacent to it.~
~An empty space ~becomes infested~ with a bug if ~exactly one or two~ bugs are adjacent to it.~

Otherwise, a bug or empty space remains the same.  (Tiles on the edges of the grid have fewer than four adjacent tiles; the missing tiles count as empty space.) This process happens in every location ~simultaneously~; that is, within the same minute, the number of adjacent bugs is counted for every tile first, and then the tiles are updated.
Here are the first few minutes of an example scenario:

#+begin_src text
Initial state:
....#
#..#.
#..##
..#..
#....

After 1 minute:
#..#.
####.
###.#
##.##
.##..

After 2 minutes:
#####
....#
....#
...#.
#.###

After 3 minutes:
#....
####.
...##
#.##.
.##.#

After 4 minutes:
####.
....#
##..#
.....
##...

#+end_src

To understand the nature of the bugs, watch for the first time a layout of bugs and empty spaces ~matches any previous layout~. In the example above, the first layout to appear twice is:

#+begin_src text
.....
.....
.....
#....
.#...

#+end_src

To calculate the ~biodiversity rating~ for this layout, consider each tile left-to-right in the top row, then left-to-right in the second row, and so on. Each of these tiles is worth biodiversity points equal to ~increasing powers of two~: 1, 2, 4, 8, 16, 32, and so on.  Add up the biodiversity points for tiles with bugs; in this example, the 16th tile (32768 points) and 22nd tile (2097152 points) have bugs, a total biodiversity rating of ~2129920~.
~What is the biodiversity rating for the first layout that appears twice?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-24 :var input_data=input-2019-24 :tangle /tmp/advent_of_code/aoc2019-24-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-24 :var input_data=input-2019-24 :tangle /tmp/advent_of_code/aoc2019-24-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-24 :var input_data=input-2019-24 :tangle /tmp/advent_of_code/aoc2019-24-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-24 :var input_data=input-2019-24 :tangle /tmp/advent_of_code/aoc2019-24-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-24 :var input_data=input-2019-24 :tangle /tmp/advent_of_code/aoc2019-24-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-24 :var input_data=input-2019-24 :tangle /tmp/advent_of_code/aoc2019-24-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-24 :var input_data=input-2019-24 :tangle /tmp/advent_of_code/aoc2019-24-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-24 :var input_data=input-2019-24 :tangle /tmp/advent_of_code/aoc2019-24-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-24 :var input_data=input-2019-24 :tangle /tmp/advent_of_code/aoc2019-24-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-24 :var input_data=input-2019-24 :tangle /tmp/advent_of_code/aoc2019-24-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-24 :var input_data=input-2019-24 :tangle /tmp/advent_of_code/aoc2019-24-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-24 :var input_data=input-2019-24 :tangle /tmp/advent_of_code/aoc2019-24-2.pl :results output 
#+end_src
*** Day 25: Cryostasis
**** Part 1
***** Description
First, that you might be too late: the internal temperature is <span title="This is the same in Fahrenheit and Celsius.">-40 degrees</span>.
Second, that one faint life signature is somewhere on the ship.
The airlock door is locked with a code; your best option is to send in a small droid to investigate the situation.  You attach your ship to Santa's, break a small hole in the hull, and let the droid run in before you seal it up again. Before your ship starts freezing, you detach your ship and set it to automatically stay within range of Santa's ship.
This droid can follow basic instructions and report on its surroundings; you can communicate with it through an <a href="9">Intcode</a> program (your puzzle input) running on an <a href="17">ASCII-capable</a> computer.
As the droid moves through its environment, it will describe what it encounters.  When it says Command?, you can give it a single instruction terminated with a newline (ASCII code 10). Possible instructions are:

~~Movement~ via north, south, east, or west.~
~To ~take~ an item the droid sees in the environment, use the command take &lt;name of item&gt;. For example, if the droid reports seeing a red ball, you can pick it up with take red ball.~
~To ~drop~ an item the droid is carrying, use the command drop &lt;name of item&gt;. For example, if the droid is carrying a green ball, you can drop it with drop green ball.~
~To get a ~list of all of the items~ the droid is currently carrying, use the command inv (for "inventory").~

Extra spaces or other characters aren't allowed - instructions must be provided precisely.
Santa's ship is a ~Reindeer-class starship~; these ships use pressure-sensitive floors to determine the identity of droids and crew members.  The standard configuration for these starships is for all droids to weigh exactly the same amount to make them easier to detect.  If you need to get past such a sensor, you might be able to reach the correct weight by carrying items from the environment.
Look around the ship and see if you can find the ~password for the main airlock~.
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-25 :var input_data=input-2019-25 :tangle /tmp/advent_of_code/aoc2019-25-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-25 :var input_data=input-2019-25 :tangle /tmp/advent_of_code/aoc2019-25-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-25 :var input_data=input-2019-25 :tangle /tmp/advent_of_code/aoc2019-25-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-25 :var input_data=input-2019-25 :tangle /tmp/advent_of_code/aoc2019-25-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-25 :var input_data=input-2019-25 :tangle /tmp/advent_of_code/aoc2019-25-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-25 :var input_data=input-2019-25 :tangle /tmp/advent_of_code/aoc2019-25-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2019-25 :var input_data=input-2019-25 :tangle /tmp/advent_of_code/aoc2019-25-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2019-25 :var input_data=input-2019-25 :tangle /tmp/advent_of_code/aoc2019-25-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2019-25 :var input_data=input-2019-25 :tangle /tmp/advent_of_code/aoc2019-25-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2019-25 :var input_data=input-2019-25 :tangle /tmp/advent_of_code/aoc2019-25-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2019-25 :var input_data=input-2019-25 :tangle /tmp/advent_of_code/aoc2019-25-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2019-25 :var input_data=input-2019-25 :tangle /tmp/advent_of_code/aoc2019-25-2.pl :results output 
#+end_src
** 2020
*** Day 01: Report Repair
**** Part 1
***** Description
The tropical island has its own currency and is entirely cash-only.  The gold coins used there have a little picture of a starfish; the locals just call them <em class="star">stars~. None of the currency exchanges seem to have heard of them, but somehow, you'll need to find fifty of these coins by the time you arrive so you can pay the deposit on your room.
To save your vacation, you need to get all <em class="star">fifty stars~ by December 25th.
Collect stars by solving puzzles.  Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first.  Each puzzle grants <em class="star">one star~. Good luck!
Before you leave, the Elves in accounting just need you to fix your ~expense report~ (your puzzle input); apparently, something isn't quite adding up.
Specifically, they need you to ~find the two entries that sum to 2020~ and then multiply those two numbers together.
For example, suppose your expense report contained the following:

#+begin_src text
1721
979
366
299
675
1456

#+end_src

In this list, the two entries that sum to 2020 are 1721 and 299. Multiplying them together produces 1721 * 299 = 514579, so the correct answer is ~514579~.
Of course, your expense report is much larger. ~Find the two entries that sum to 2020; what do you get if you multiply them together?~
 
***** Racket
#+begin_src racket :var sample_data=sample-2020-01 :var input_data=input-2020-01 :tangle /tmp/advent_of_code/aoc2020-01-1.rkt :results output
(define (fix-expense-report input)
  (for*/first ([i input]
               [j input]
               #:when (= (+ i j) 2020))
    (* i j)))

(define data1 (with-input-from-string (string-append "(" sample_data ")") read))
(define data2 (with-input-from-string (string-append "(" input_data ")") read))
(displayln (fix-expense-report data1))
(displayln (fix-expense-report data2))

#+end_src

#+RESULTS:
: 514579
: 365619

***** Python
#+begin_src python :var sample_data=sample-2020-01 :var input_data=input-2020-01 :tangle /tmp/advent_of_code/aoc2020-01-1.py :results output
def fix_expense_report(data):
    for i in data:
        for j in data:
            if i + j == 2020:
                return i * j

data1 = [int(x) for x in sample_data.split()]
data2 = [int(x) for x in input_data.split()]
print(fix_expense_report(data1))
print(fix_expense_report(data2))
#+end_src

#+RESULTS:
: 514579
: 365619

***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-01 :var input_data=input-2020-01 :tangle /tmp/advent_of_code/aoc2020-01-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-01 :var input_data=input-2020-01 :tangle /tmp/advent_of_code/aoc2020-01-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-01 :var input_data=input-2020-01 :tangle /tmp/advent_of_code/aoc2020-01-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-01 :var input_data=input-2020-01 :tangle /tmp/advent_of_code/aoc2020-01-1.pl :results output 
#+end_src
**** Part 2
***** Description
The Elves in accounting are thankful for your help; one of them even offers you a starfish coin they had left over from a past vacation. They offer you a second one if you can find three numbers in your expense report that meet the same criteria.

Using the above example again, the three entries that sum to 2020 are 979, 366, and 675. Multiplying them together produces the answer, 241861950.

In your expense report, what is the product of the three entries that sum to 2020?
***** Racket
#+begin_src racket :var sample_data=sample-2020-01 :var input_data=input-2020-01 :tangle /tmp/advent_of_code/aoc2020-01-2.rkt :results output
(define (fix-expense-report-2 input)
  (for*/first ([i input]
               [j input]
               [k input]
               #:when (= (+ i j k) 2020))
    (* i j k)))

(define data1 (with-input-from-string (string-append "(" sample_data ")") read))
(define data2 (with-input-from-string (string-append "(" input_data ")") read))
(displayln (fix-expense-report-2 data1))
(displayln (fix-expense-report-2 data2))
#+end_src

#+RESULTS:
: 241861950
: 236873508

***** Python
#+begin_src python :var sample_data=sample-2020-01 :var input_data=input-2020-01 :tangle /tmp/advent_of_code/aoc2020-01-2.py :results output
def fix_expense_report_2(data):
    for i in data:
        for j in data:
            for k in data:
                if i + j + k == 2020:
                    return i * j * k

data1 = [int(x) for x in sample_data.split()]
data2 = [int(x) for x in input_data.split()]
print(fix_expense_report_2(data1))
print(fix_expense_report_2(data2))
#+end_src

#+RESULTS:
: 241861950
: 236873508

***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-01 :var input_data=input-2020-01 :tangle /tmp/advent_of_code/aoc2020-01-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-01 :var input_data=input-2020-01 :tangle /tmp/advent_of_code/aoc2020-01-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-01 :var input_data=input-2020-01 :tangle /tmp/advent_of_code/aoc2020-01-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-01 :var input_data=input-2020-01 :tangle /tmp/advent_of_code/aoc2020-01-2.pl :results output 
#+end_src
*** Day 02: Password Philosophy
**** Part 1
***** Description
The shopkeeper at the North Pole Toboggan Rental Shop is having a bad day. "Something's wrong with our computers; we can't log in!" You ask if you can take a look.
Their password database seems to be a little corrupted: some of the passwords wouldn't have been allowed by the <span title="To ensure your safety, your password must be the following string...">Official Toboggan Corporate Policy</span> that was in effect when they were chosen.
To try to debug the problem, they have created a list (your puzzle input) of ~passwords~ (according to the corrupted database) and ~the corporate policy when that password was set~.
For example, suppose you have the following list:

#+begin_src text
1-3 a: abcde
1-3 b: cdefg
2-9 c: ccccccccc

#+end_src

Each line gives the password policy and then the password. The password policy indicates the lowest and highest number of times a given letter must appear for the password to be valid. For example, 1-3 a means that the password must contain a at least 1 time and at most 3 times.
In the above example, ~2~ passwords are valid. The middle password, cdefg, is not; it contains no instances of b, but needs at least 1. The first and third passwords are valid: they contain one a or nine c, both within the limits of their respective policies.
~How many passwords are valid~ according to their policies?
 
***** Racket
#+begin_src racket :var sample_data=sample-2020-02 :var input_data=input-2020-02 :tangle /tmp/advent_of_code/aoc2020-02-1.rkt :results output
(define count-substring
  (compose length regexp-match*))

(define (check_passwords data)
  (apply +
         (for/list ([line (string-split data "\n")])
           (define l (string-split line))
           (define min (string->number (car (string-split (car l) "-"))))
           (define max (string->number (cadr (string-split (car l) "-"))))
           (define char (car (string-split (cadr l) ":")))
           (define cnt (count-substring char (caddr l)))
           (if (and (>= cnt min) (<= cnt max)) 1 0))))

(displayln (check_passwords sample_data))
(displayln (check_passwords input_data))
#+end_src

#+RESULTS:
: 2
: 636

***** Python
#+begin_src python :var sample_data=sample-2020-02 :var input_data=input-2020-02 :tangle /tmp/advent_of_code/aoc2020-02-1.py :results output
def check_passwords(data):
    num = 0
    for line in data:
        min = int(line[0].split("-")[0])
        max = int(line[0].split("-")[1])
        letter = line[1][0]
        seq = line[2]
        count = seq.count(letter)
        if count >= min and count <= max:
            num += 1
    return num

data1 = [[part for part in line.split()] for line in sample_data.split("\n")]
data2 = [[part for part in line.split()] for line in input_data.split("\n")][:-1]
check_passwords(data1)
check_passwords(data2)
#+end_src

#+RESULTS:
: 2
: 636

***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-02 :var input_data=input-2020-02 :tangle /tmp/advent_of_code/aoc2020-02-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-02 :var input_data=input-2020-02 :tangle /tmp/advent_of_code/aoc2020-02-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-02 :var input_data=input-2020-02 :tangle /tmp/advent_of_code/aoc2020-02-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-02 :var input_data=input-2020-02 :tangle /tmp/advent_of_code/aoc2020-02-1.pl :results output 
#+end_src
**** Part 2
***** Description
While it appears you validated the passwords correctly, they don't seem to be what the Official Toboggan Corporate Authentication System is expecting.

The shopkeeper suddenly realizes that he just accidentally explained the password policy rules from his old job at the sled rental place down the street! The Official Toboggan Corporate Policy actually works a little differently.

Each policy actually describes two positions in the password, where 1 means the first character, 2 means the second character, and so on. (Be careful; Toboggan Corporate Policies have no concept of "index zero"!) Exactly one of these positions must contain the given letter. Other occurrences of the letter are irrelevant for the purposes of policy enforcement.

Given the same example list from above:

1-3 a: abcde is valid: position 1 contains a and position 3 does not.
1-3 b: cdefg is invalid: neither position 1 nor position 3 contains b.
2-9 c: ccccccccc is invalid: both position 2 and position 9 contain c.
How many passwords are valid according to the new interpretation of the policies?

***** Racket
Here I decided to use ~count identity~ rather than summing up the list with ~apply +~
#+begin_src racket :var sample_data=sample-2020-02 :var input_data=input-2020-02 :tangle /tmp/advent_of_code/aoc2020-02-2.rkt :results output
(define (check_passwords data)
  (count identity
         (for/list ([line (string-split data "\n")])
           (define l (string-split line))
           (define i1 (string->number (car (string-split (car l) "-"))))
           (define i2 (string->number (cadr (string-split (car l) "-"))))
           (define char (car (string-split (cadr l) ":")))
           (xor (equal? (substring (caddr l) (- i1 1) i1) char)
                (equal? (substring (caddr l) (- i2 1) i2) char)))))

(check_passwords sample_data)
(check_passwords input_data)
#+end_src

#+RESULTS:
: 1
: 588

***** Python
python solution and a cursed one liner which does the same thing as above using list comprehension
#+begin_src python :var sample_data=sample-2020-02 :var input_data=input-2020-02 :tangle /tmp/advent_of_code/aoc2020-02-2.py :results output
def check_passwords(input):
    num = 0
    for parts in [line.split() for line in input.split("\n") if line != ""]:
        first = int(parts[0].split("-")[0]) - 1
        second = int(parts[0].split("-")[1]) - 1
        char = parts[1][0]
        seq = parts[2]
        if ((seq[first] == char) ^ (seq[second] == char)):
            num += 1
    return num

def check_passwords_list_comp(input):
    return sum([1 if ((parts[2][int(parts[0].split("-")[0]) - 1] == parts[1][0]) ^ (parts[2][int(parts[0].split("-")[1]) - 1] == parts[1][0])) else 0 for parts in [line.split() for line in input.split("\n") if line != ""]])

check_passwords(sample_data)
check_passwords(input_data)
#+end_src

#+RESULTS:
: 1
: 588

***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-02 :var input_data=input-2020-02 :tangle /tmp/advent_of_code/aoc2020-02-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-02 :var input_data=input-2020-02 :tangle /tmp/advent_of_code/aoc2020-02-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-02 :var input_data=input-2020-02 :tangle /tmp/advent_of_code/aoc2020-02-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-02 :var input_data=input-2020-02 :tangle /tmp/advent_of_code/aoc2020-02-2.pl :results output 
#+end_src
*** Day 03: Toboggan Trajectory
**** Part 1
***** Description
Due to the local geology, trees in this area only grow on exact integer coordinates in a grid. You make a map (your puzzle input) of the open squares (.) and trees (#) you can see. For example:

#+begin_src text
..##.......
#...#...#..
.#....#..#.
..#.#...#.#
.#...##..#.
..#.##.....
.#.#.#....#
.#........#
#.##...#...
#...##....#
.#..#...#.#

#+end_src

These aren't the only trees, though; due to something you read about once involving arboreal genetics and biome stability, the same pattern repeats to the right many times:

#+begin_src text
~..##.......~..##.........##.........##.........##.........##.......  ---&gt;
~#...#...#..~#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..
~.#....#..#.~.#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.
~..#.#...#.#~..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#
~.#...##..#.~.#...##..#..#...##..#..#...##..#..#...##..#..#...##..#.
~..#.##.....~..#.##.......#.##.......#.##.......#.##.......#.##.....  ---&gt;
~.#.#.#....#~.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#
~.#........#~.#........#.#........#.#........#.#........#.#........#
~#.##...#...~#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...
~#...##....#~#...##....##...##....##...##....##...##....##...##....#
~.#..#...#.#~.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#  ---&gt;

#+end_src

You start on the open square (.) in the top-left corner and need to reach the bottom (below the bottom-most row on your map).
The toboggan can only follow a few specific slopes (you opted for a cheaper model that prefers rational numbers); start by ~counting all the trees~ you would encounter for the slope ~right 3, down 1~:
From your starting position at the top-left, check the position that is right 3 and down 1. Then, check the position that is right 3 and down 1 from there, and so on until you go past the bottom of the map.
The locations you'd check in the above example are marked here with ~O~ where there was an open square and ~X~ where there was a tree:

#+begin_src text
..##.........##.........##.........##.........##.........##.......  ---&gt;
#..~O~#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..
.#....~X~..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.
..#.#...#~O~#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#
.#...##..#..~X~...##..#..#...##..#..#...##..#..#...##..#..#...##..#.
..#.##.......#.~X~#.......#.##.......#.##.......#.##.......#.##.....  ---&gt;
.#.#.#....#.#.#.#.~O~..#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#
.#........#.#........~X~.#........#.#........#.#........#.#........#
#.##...#...#.##...#...#.~X~#...#...#.##...#...#.##...#...#.##...#...
#...##....##...##....##...#~X~....##...##....##...##....##...##....#
.#..#...#.#.#..#...#.#.#..#...~X~.#.#..#...#.#.#..#...#.#.#..#...#.#  ---&gt;

#+end_src

In this example, traversing the map using this slope would cause you to encounter ~7~ trees.
Starting at the top-left corner of your map and following a slope of right 3 and down 1, ~how many trees would you encounter?~
 
***** Racket
#+begin_src racket :var sample_data=sample-2020-03 :var input_data=input-2020-03 :tangle /tmp/advent_of_code/aoc2020-03-1.rkt :results output
(define (count_trees lines [idx 0])
  (if (empty? lines) 0
      (+ (if (equal? #\# (string-ref (car lines) (modulo idx (string-length (car lines))))) 1 0)
         (count_trees (cdr lines) (+ idx 3)))))

(define (count_trees2 lines [idx 0])
  (if (empty? lines) 0
      (let ([index (modulo idx (string-length (car lines)))])
        (+ (if (equal? #\# (string-ref (car lines) index)) 1 0)
           (count_trees2 (cdr lines) (+ idx 3))))))

(define (count_trees3 lines [idx 0])
  (let ([line (car lines)])
    (+ (if (equal? #\# (string-ref line (modulo idx (string-length line)))) 1 0)
       (if (empty? (cdr lines)) 0 (count_trees3 (cdr lines) (+ idx 3))))))

(define (count_trees4 lines [idx 0])
  (let ([index (modulo idx (string-length (car lines)))])
    (+ (if (equal? #\# (string-ref (car lines) index)) 1 0)
       (if (empty? (cdr lines)) 0 (count_trees4 (cdr lines) (+ idx 3))))))

(displayln (count_trees4 (string-split sample_data "\n")))
(displayln (count_trees4 (string-split input_data "\n")))
#+end_src

#+RESULTS:
: 7
: 193

***** Python
#+begin_src python :var sample_data=sample-2020-03 :var input_data=input-2020-03 :tangle /tmp/advent_of_code/aoc2020-03-1.py :results output
def count_trees(input):
    idx = 3
    num = 0
    for line in input.split("\n")[1:]:
        if line[idx % len(line)] == "#":
            num += 1
        idx = idx + 3
    return(num)

count_trees(sample_data[:-1])
count_trees(input_data[:-1])
#+end_src

#+RESULTS:
: 7
: 193

***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-03 :var input_data=input-2020-03 :tangle /tmp/advent_of_code/aoc2020-03-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-03 :var input_data=input-2020-03 :tangle /tmp/advent_of_code/aoc2020-03-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-03 :var input_data=input-2020-03 :tangle /tmp/advent_of_code/aoc2020-03-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-03 :var input_data=input-2020-03 :tangle /tmp/advent_of_code/aoc2020-03-1.pl :results output 
#+end_src
**** Part 2
***** Description
Time to check the rest of the slopes - you need to minimize the probability of a sudden arboreal stop, after all.

Determine the number of trees you would encounter if, for each of the following slopes, you start at the top-left corner and traverse the map all the way to the bottom:

~Right 1, down 1.~
~Right 3, down 1. (This is the slope you already checked.)~
~Right 5, down 1.~
~Right 7, down 1.~
~Right 1, down 2.~
In the above example, these slopes would find 2, 7, 3, 4, and 2 tree(s) respectively; multiplied together, these produce the answer 336.

What do you get if you multiply together the number of trees encountered on each of the listed slopes?
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-03 :var input_data=input-2020-03 :tangle /tmp/advent_of_code/aoc2020-03-2.rkt :results output
(define (count_trees lines [right 3] [down 1] [idx 0] [y 0])
  (let ([index (modulo idx (string-length (car lines)))])
    (+ (cond
         [(> y 0) (begin (set! y (- y 1)) 0)]
         [(equal? #\# (string-ref (car lines) index))
          (begin (set! y (- down 1)) 1)]
         [else 0])
       (if (empty? (cdr lines))
           0
           (count_trees (cdr lines) right down (+ idx right) y)))))

(define (mul_slopes data slopes)
  (let ([lines (string-split data "\n")])
    (apply *
           (for/list ([line slopes])
             (count_trees lines (car line) (cadr line))))))

(mul_slopes sample_data '((1 1) (3 1) (5 1) (7 1) (1 2)))
;; I think this second one is incorrect
(mul_slopes input_data '((1 1) (3 1) (5 1) (7 1) (1 2)))
#+end_src

#+RESULTS:
: 336
: 1936176000

***** Python
#+begin_src python :var sample_data=sample-2020-03 :var input_data=input-2020-03 :tangle /tmp/advent_of_code/aoc2020-03-2.py :results output
import math

def count_trees(input, slope):
    x = slope[0]
    y = slope[1]
    num = 0
    for line in input.split("\n"):
        if y < 1:
            if line[x % len(line)] == "#":
                num += 1
            x += slope[0]
            y = slope[1] - 1
        else:
            y -= 1
    return(num)

def mul_slopes(input, slopes):
    return math.prod([count_trees(input, slope) for slope in slopes])

slopes = [[1, 1], [3, 1], [5, 1], [7, 1], [1, 2]]
mul_slopes(sample_data[:-1], slopes)
mul_slopes(input_data[:-1], slopes)
#+end_src

#+RESULTS:
: 336
: 1355323200

***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-03 :var input_data=input-2020-03 :tangle /tmp/advent_of_code/aoc2020-03-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-03 :var input_data=input-2020-03 :tangle /tmp/advent_of_code/aoc2020-03-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-03 :var input_data=input-2020-03 :tangle /tmp/advent_of_code/aoc2020-03-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-03 :var input_data=input-2020-03 :tangle /tmp/advent_of_code/aoc2020-03-2.pl :results output 
#+end_src
*** Day 04: Passport Processing
**** Part 1
***** Description
It seems like you're not the only one having problems, though; a very long line has formed for the automatic passport scanners, and the delay could upset your travel itinerary.
Due to some questionable network security, you realize you might be able to solve both of these problems at the same time.
The automatic passport scanners are slow because they're having trouble ~detecting which passports have all required fields~. The expected fields are as follows:

~byr (Birth Year)~
~iyr (Issue Year)~
~eyr (Expiration Year)~
~hgt (Height)~
~hcl (Hair Color)~
~ecl (Eye Color)~
~pid (Passport ID)~
~cid (Country ID)~

Passport data is validated in batch files (your puzzle input). Each passport is represented as a sequence of key:value pairs separated by spaces or newlines. Passports are separated by blank lines.
Here is an example batch file containing four passports:

#+begin_src text
ecl:gry pid:860033327 eyr:2020 hcl:#fffffd
byr:1937 iyr:2017 cid:147 hgt:183cm

iyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884
hcl:#cfa07d byr:1929

hcl:#ae17e1 iyr:2013
eyr:2024
ecl:brn pid:760753108 byr:1931
hgt:179cm

hcl:#cfa07d eyr:2025 pid:166559648
iyr:2011 ecl:brn hgt:59in

#+end_src

The first passport is ~valid~ - all eight fields are present. The second passport is ~invalid~ - it is missing hgt (the Height field).
The third passport is interesting; the ~only missing field~ is cid, so it looks like data from North Pole Credentials, not a passport at all! Surely, nobody would mind if you made the system temporarily ignore missing cid fields.  Treat this "passport" as ~valid~.
The fourth passport is missing two fields, cid and byr. Missing cid is fine, but missing any other field is not, so this passport is ~invalid~.
According to the above rules, your improved system would report ~2~ valid passports.
Count the number of ~valid~ passports - those that have all required fields. Treat cid as optional. ~In your batch file, how many passports are valid?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-04 :var input_data=input-2020-04 :tangle /tmp/advent_of_code/aoc2020-04-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-04 :var input_data=input-2020-04 :tangle /tmp/advent_of_code/aoc2020-04-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-04 :var input_data=input-2020-04 :tangle /tmp/advent_of_code/aoc2020-04-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-04 :var input_data=input-2020-04 :tangle /tmp/advent_of_code/aoc2020-04-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-04 :var input_data=input-2020-04 :tangle /tmp/advent_of_code/aoc2020-04-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-04 :var input_data=input-2020-04 :tangle /tmp/advent_of_code/aoc2020-04-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-04 :var input_data=input-2020-04 :tangle /tmp/advent_of_code/aoc2020-04-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-04 :var input_data=input-2020-04 :tangle /tmp/advent_of_code/aoc2020-04-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-04 :var input_data=input-2020-04 :tangle /tmp/advent_of_code/aoc2020-04-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-04 :var input_data=input-2020-04 :tangle /tmp/advent_of_code/aoc2020-04-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-04 :var input_data=input-2020-04 :tangle /tmp/advent_of_code/aoc2020-04-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-04 :var input_data=input-2020-04 :tangle /tmp/advent_of_code/aoc2020-04-2.pl :results output 
#+end_src
*** Day 05: Binary Boarding
**** Part 1
***** Description
You write a <span title="No problem!">quick program</span> to use your phone's camera to scan all of the nearby boarding passes (your puzzle input); perhaps you can find your seat through process of elimination.
Instead of <a href="https://www.youtube.com/watch?v=oAHbLRjF0vo" target="_blank">zones or groups</a>, this airline uses ~binary space partitioning~ to seat people. A seat might be specified like FBFBBFFRLR, where F means "front", B means "back", L means "left", and R means "right".
The first 7 characters will either be F or B; these specify exactly one of the ~128 rows~ on the plane (numbered 0 through 127). Each letter tells you which half of a region the given seat is in. Start with the whole list of rows; the first letter indicates whether the seat is in the ~front~ (0 through 63) or the ~back~ (64 through 127). The next letter indicates which half of that region the seat is in, and so on until you're left with exactly one row.
For example, consider just the first seven characters of FBFBBFFRLR:

~Start by considering the whole range, rows 0 through 127.~
~F means to take the ~lower half~, keeping rows 0 through 63.~
~B means to take the ~upper half~, keeping rows 32 through 63.~
~F means to take the ~lower half~, keeping rows 32 through 47.~
~B means to take the ~upper half~, keeping rows 40 through 47.~
~B keeps rows 44 through 47.~
~F keeps rows 44 through 45.~
~The final F keeps the lower of the two, ~row 44~.~

The last three characters will be either L or R; these specify exactly one of the ~8 columns~ of seats on the plane (numbered 0 through 7). The same process as above proceeds again, this time with only three steps.  L means to keep the ~lower half~, while R means to keep the ~upper half~.
For example, consider just the last 3 characters of FBFBBFFRLR:

~Start by considering the whole range, columns 0 through 7.~
~R means to take the ~upper half~, keeping columns 4 through 7.~
~L means to take the ~lower half~, keeping columns 4 through 5.~
~The final R keeps the upper of the two, ~column 5~.~

So, decoding FBFBBFFRLR reveals that it is the seat at ~row 44, column 5~.
Every seat also has a unique ~seat ID~: multiply the row by 8, then add the column. In this example, the seat has ID 44 * 8 + 5 = ~357~.
Here are some other boarding passes:

~BFFFBBFRRR: row 70, column 7, seat ID 567.~
~FFFBBBFRRR: row 14, column 7, seat ID 119.~
~BBFFBBFRLL: row 102, column 4, seat ID 820.~

As a sanity check, look through your list of boarding passes. ~What is the highest seat ID on a boarding pass?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-05 :var input_data=input-2020-05 :tangle /tmp/advent_of_code/aoc2020-05-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-05 :var input_data=input-2020-05 :tangle /tmp/advent_of_code/aoc2020-05-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-05 :var input_data=input-2020-05 :tangle /tmp/advent_of_code/aoc2020-05-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-05 :var input_data=input-2020-05 :tangle /tmp/advent_of_code/aoc2020-05-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-05 :var input_data=input-2020-05 :tangle /tmp/advent_of_code/aoc2020-05-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-05 :var input_data=input-2020-05 :tangle /tmp/advent_of_code/aoc2020-05-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-05 :var input_data=input-2020-05 :tangle /tmp/advent_of_code/aoc2020-05-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-05 :var input_data=input-2020-05 :tangle /tmp/advent_of_code/aoc2020-05-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-05 :var input_data=input-2020-05 :tangle /tmp/advent_of_code/aoc2020-05-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-05 :var input_data=input-2020-05 :tangle /tmp/advent_of_code/aoc2020-05-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-05 :var input_data=input-2020-05 :tangle /tmp/advent_of_code/aoc2020-05-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-05 :var input_data=input-2020-05 :tangle /tmp/advent_of_code/aoc2020-05-2.pl :results output 
#+end_src
*** Day 06: Custom Customs
**** Part 1
***** Description
The form asks a series of 26 yes-or-no questions marked a through z. All you need to do is identify the questions for which ~anyone in your group~ answers "yes". Since your group is just you, this doesn't take very long.
However, the person sitting next to you seems to be experiencing a language barrier and asks if you can help. For each of the people in their group, you write down the questions for which they answer "yes", one per line.  For example:

#+begin_src text
abcx
abcy
abcz

#+end_src

In this group, there are ~6~ questions to which anyone answered "yes": a, b, c, x, y, and z. (Duplicate answers to the same question don't count extra; each question counts at most once.)
Another group asks for your help, then another, and eventually you've collected answers from every group on the plane (your puzzle input). Each group's answers are separated by a blank line, and within each group, each person's answers are on a single line. For example:

#+begin_src text
abc

a
b
c

ab
ac

a
a
a
a

b

#+end_src

This list represents answers from five groups:

~The first group contains one person who answered "yes" to ~3~ questions: a, b, and c.~
~The second group contains three people; combined, they answered "yes" to ~3~ questions: a, b, and c.~
~The third group contains two people; combined, they answered "yes" to ~3~ questions: a, b, and c.~
~The fourth group contains four people; combined, they answered "yes" to only ~1~ question, a.~
~The last group contains one person who answered "yes" to only ~1~ question, b.~

In this example, the sum of these counts is 3 + 3 + 3 + 1 + 1 = ~11~.
For each group, count the number of questions to which anyone answered "yes". ~What is the sum of those counts?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-06 :var input_data=input-2020-06 :tangle /tmp/advent_of_code/aoc2020-06-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-06 :var input_data=input-2020-06 :tangle /tmp/advent_of_code/aoc2020-06-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-06 :var input_data=input-2020-06 :tangle /tmp/advent_of_code/aoc2020-06-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-06 :var input_data=input-2020-06 :tangle /tmp/advent_of_code/aoc2020-06-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-06 :var input_data=input-2020-06 :tangle /tmp/advent_of_code/aoc2020-06-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-06 :var input_data=input-2020-06 :tangle /tmp/advent_of_code/aoc2020-06-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-06 :var input_data=input-2020-06 :tangle /tmp/advent_of_code/aoc2020-06-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-06 :var input_data=input-2020-06 :tangle /tmp/advent_of_code/aoc2020-06-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-06 :var input_data=input-2020-06 :tangle /tmp/advent_of_code/aoc2020-06-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-06 :var input_data=input-2020-06 :tangle /tmp/advent_of_code/aoc2020-06-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-06 :var input_data=input-2020-06 :tangle /tmp/advent_of_code/aoc2020-06-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-06 :var input_data=input-2020-06 :tangle /tmp/advent_of_code/aoc2020-06-2.pl :results output 
#+end_src
*** Day 07: Handy Haversacks
**** Part 1
***** Description
Due to recent aviation regulations, many rules (your puzzle input) are being enforced about bags and their contents; bags must be color-coded and must contain specific quantities of other color-coded bags. Apparently, nobody responsible for these regulations considered how long they would take to enforce!
For example, consider the following rules:

#+begin_src text
light red bags contain 1 bright white bag, 2 muted yellow bags.
dark orange bags contain 3 bright white bags, 4 muted yellow bags.
bright white bags contain 1 shiny gold bag.
muted yellow bags contain 2 shiny gold bags, 9 faded blue bags.
shiny gold bags contain 1 dark olive bag, 2 vibrant plum bags.
dark olive bags contain 3 faded blue bags, 4 dotted black bags.
vibrant plum bags contain 5 faded blue bags, 6 dotted black bags.
faded blue bags contain no other bags.
dotted black bags contain no other bags.

#+end_src

These rules specify the required contents for 9 bag types. In this example, every faded blue bag is empty, every vibrant plum bag contains 11 bags (5 faded blue and 6 dotted black), and so on.
You have a ~shiny gold~ bag. If you wanted to carry it in at least one other bag, how many different bag colors would be valid for the outermost bag? (In other words: how many colors can, eventually, contain at least one shiny gold bag?)
In the above rules, the following options would be available to you:

~A bright white bag, which can hold your shiny gold bag directly.~
~A muted yellow bag, which can hold your shiny gold bag directly, plus some other bags.~
~A dark orange bag, which can hold bright white and muted yellow bags, either of which could then hold your shiny gold bag.~
~A light red bag, which can hold bright white and muted yellow bags, either of which could then hold your shiny gold bag.~

So, in this example, the number of bag colors that can eventually contain at least one shiny gold bag is ~4~.
~How many bag colors can eventually contain at least one shiny gold bag?~ (The list of rules is quite long; make sure you get all of it.)
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-07 :var input_data=input-2020-07 :tangle /tmp/advent_of_code/aoc2020-07-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-07 :var input_data=input-2020-07 :tangle /tmp/advent_of_code/aoc2020-07-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-07 :var input_data=input-2020-07 :tangle /tmp/advent_of_code/aoc2020-07-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-07 :var input_data=input-2020-07 :tangle /tmp/advent_of_code/aoc2020-07-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-07 :var input_data=input-2020-07 :tangle /tmp/advent_of_code/aoc2020-07-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-07 :var input_data=input-2020-07 :tangle /tmp/advent_of_code/aoc2020-07-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-07 :var input_data=input-2020-07 :tangle /tmp/advent_of_code/aoc2020-07-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-07 :var input_data=input-2020-07 :tangle /tmp/advent_of_code/aoc2020-07-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-07 :var input_data=input-2020-07 :tangle /tmp/advent_of_code/aoc2020-07-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-07 :var input_data=input-2020-07 :tangle /tmp/advent_of_code/aoc2020-07-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-07 :var input_data=input-2020-07 :tangle /tmp/advent_of_code/aoc2020-07-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-07 :var input_data=input-2020-07 :tangle /tmp/advent_of_code/aoc2020-07-2.pl :results output 
#+end_src
*** Day 08: Handheld Halting
**** Part 1
***** Description
Their <a href="https://en.wikipedia.org/wiki/Handheld_game_console" target="_blank">handheld game console</a> won't turn on! They ask if you can take a look.
You narrow the problem down to a strange ~infinite loop~ in the <span title="A trendy new line of encrypted footwear?">boot code</span> (your puzzle input) of the device. You should be able to fix it, but first you need to be able to run the code in isolation.
The boot code is represented as a text file with one ~instruction~ per line of text. Each instruction consists of an ~operation~ (acc, jmp, or nop) and an ~argument~ (a signed number like +4 or -20).

~acc increases or decreases a single global value called the ~accumulator~ by the value given in the argument. For example, acc +7 would increase the accumulator by 7. The accumulator starts at 0. After an acc instruction, the instruction immediately below it is executed next.~
~jmp ~jumps~ to a new instruction relative to itself. The next instruction to execute is found using the argument as an ~offset~ from the jmp instruction; for example, jmp +2 would skip the next instruction, jmp +1 would continue to the instruction immediately below it, and jmp -20 would cause the instruction 20 lines above to be executed next.~
~nop stands for ~No OPeration~ - it does nothing.  The instruction immediately below it is executed next.~

For example, consider the following program:

#+begin_src text
nop +0
acc +1
jmp +4
acc +3
jmp -3
acc -99
acc +1
jmp -4
acc +6

#+end_src

These instructions are visited in this order:

#+begin_src text
nop +0  | 1
acc +1  | 2, 8(!)
jmp +4  | 3
acc +3  | 6
jmp -3  | 7
acc -99 |
acc +1  | 4
jmp -4  | 5
acc +6  |

#+end_src

First, the nop +0 does nothing. Then, the accumulator is increased from 0 to 1 (acc +1) and jmp +4 sets the next instruction to the other acc +1 near the bottom. After it increases the accumulator from 1 to 2, jmp -4 executes, setting the next instruction to the only acc +3. It sets the accumulator to 5, and jmp -3 causes the program to continue back at the first acc +1.
This is an ~infinite loop~: with this sequence of jumps, the program will run forever. The moment the program tries to run any instruction a second time, you know it will never terminate.
Immediately ~before~ the program would run an instruction a second time, the value in the accumulator is ~5~.
Run your copy of the boot code. Immediately before any instruction is executed a second time, ~what value is in the accumulator?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-08 :var input_data=input-2020-08 :tangle /tmp/advent_of_code/aoc2020-08-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-08 :var input_data=input-2020-08 :tangle /tmp/advent_of_code/aoc2020-08-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-08 :var input_data=input-2020-08 :tangle /tmp/advent_of_code/aoc2020-08-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-08 :var input_data=input-2020-08 :tangle /tmp/advent_of_code/aoc2020-08-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-08 :var input_data=input-2020-08 :tangle /tmp/advent_of_code/aoc2020-08-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-08 :var input_data=input-2020-08 :tangle /tmp/advent_of_code/aoc2020-08-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-08 :var input_data=input-2020-08 :tangle /tmp/advent_of_code/aoc2020-08-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-08 :var input_data=input-2020-08 :tangle /tmp/advent_of_code/aoc2020-08-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-08 :var input_data=input-2020-08 :tangle /tmp/advent_of_code/aoc2020-08-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-08 :var input_data=input-2020-08 :tangle /tmp/advent_of_code/aoc2020-08-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-08 :var input_data=input-2020-08 :tangle /tmp/advent_of_code/aoc2020-08-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-08 :var input_data=input-2020-08 :tangle /tmp/advent_of_code/aoc2020-08-2.pl :results output 
#+end_src
*** Day 09: Encoding Error
**** Part 1
***** Description
Though the port is non-standard, you manage to connect it to your computer through the clever use of several paperclips. Upon connection, the port outputs a series of numbers (your puzzle input).
The data appears to be encrypted with the eXchange-Masking Addition System (<span title="No relation.">XMAS</span>) which, conveniently for you, is an old cypher with an important weakness.
XMAS starts by transmitting a ~preamble~ of 25 numbers. After that, each number you receive should be the sum of any two of the 25 immediately previous numbers. The two numbers will have different values, and there might be more than one such pair.
For example, suppose your preamble consists of the numbers 1 through 25 in a random order. To be valid, the next number must be the sum of two of those numbers:

~26 would be a ~valid~ next number, as it could be 1 plus 25 (or many other pairs, like 2 and 24).~
~49 would be a ~valid~ next number, as it is the sum of 24 and 25.~
~100 would ~not~ be valid; no two of the previous 25 numbers sum to 100.~
~50 would also ~not~ be valid; although 25 appears in the previous 25 numbers, the two numbers in the pair must be different.~

Suppose the 26th number is 45, and the first number (no longer an option, as it is more than 25 numbers ago) was 20. Now, for the next number to be valid, there needs to be some pair of numbers among 1-19, 21-25, or 45 that add up to it:

~26 would still be a ~valid~ next number, as 1 and 25 are still within the previous 25 numbers.~
~65 would ~not~ be valid, as no two of the available numbers sum to it.~
~64 and 66 would both be ~valid~, as they are the result of 19+45 and 21+45 respectively.~

Here is a larger example which only considers the previous ~5~ numbers (and has a preamble of length 5):

#+begin_src text
35
20
15
25
47
40
62
55
65
95
102
117
150
182
127
219
299
277
309
576

#+end_src

In this example, after the 5-number preamble, almost every number is the sum of two of the previous 5 numbers; the only number that does not follow this rule is ~127~.
The first step of attacking the weakness in the XMAS data is to find the first number in the list (after the preamble) which is ~not~ the sum of two of the 25 numbers before it. ~What is the first number that does not have this property?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-09 :var input_data=input-2020-09 :tangle /tmp/advent_of_code/aoc2020-09-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-09 :var input_data=input-2020-09 :tangle /tmp/advent_of_code/aoc2020-09-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-09 :var input_data=input-2020-09 :tangle /tmp/advent_of_code/aoc2020-09-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-09 :var input_data=input-2020-09 :tangle /tmp/advent_of_code/aoc2020-09-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-09 :var input_data=input-2020-09 :tangle /tmp/advent_of_code/aoc2020-09-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-09 :var input_data=input-2020-09 :tangle /tmp/advent_of_code/aoc2020-09-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-09 :var input_data=input-2020-09 :tangle /tmp/advent_of_code/aoc2020-09-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-09 :var input_data=input-2020-09 :tangle /tmp/advent_of_code/aoc2020-09-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-09 :var input_data=input-2020-09 :tangle /tmp/advent_of_code/aoc2020-09-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-09 :var input_data=input-2020-09 :tangle /tmp/advent_of_code/aoc2020-09-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-09 :var input_data=input-2020-09 :tangle /tmp/advent_of_code/aoc2020-09-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-09 :var input_data=input-2020-09 :tangle /tmp/advent_of_code/aoc2020-09-2.pl :results output 
#+end_src
*** Day 10: Adapter Array
**** Part 1
***** Description
Its battery is dead.
You'll need to plug it in. There's only one problem: the charging outlet near your seat produces the wrong number of ~jolts~. Always prepared, you make a list of all of the joltage adapters in your bag.
Each of your joltage adapters is rated for a specific ~output joltage~ (your puzzle input). Any given adapter can take an input 1, 2, or 3 jolts ~lower~ than its rating and still produce its rated output joltage.
In addition, your device has a built-in joltage adapter rated for ~3 jolts higher~ than the highest-rated adapter in your bag. (If your adapter list were 3, 9, and 6, your device's built-in adapter would be rated for 12 jolts.)
Treat the charging outlet near your seat as having an effective joltage rating of 0.
Since you have some time to kill, you might as well test all of your adapters. Wouldn't want to get to your resort and realize you can't even charge your device!
If you ~use every adapter in your bag~ at once, what is the distribution of joltage differences between the charging outlet, the adapters, and your device?
For example, suppose that in your bag, you have adapters with the following joltage ratings:

#+begin_src text
16
10
15
5
1
11
7
19
6
12
4

#+end_src

With these adapters, your device's built-in joltage adapter would be rated for 19 + 3 = ~22~ jolts, 3 higher than the highest-rated adapter.
Because adapters can only connect to a source 1-3 jolts lower than its rating, in order to use every adapter, you'd need to choose them like this:

~The charging outlet has an effective rating of 0 jolts, so the only adapters that could connect to it directly would need to have a joltage rating of 1, 2, or 3 jolts. Of these, only one you have is an adapter rated 1 jolt (difference of ~1~).~
~From your 1-jolt rated adapter, the only choice is your 4-jolt rated adapter (difference of ~3~).~
~From the 4-jolt rated adapter, the adapters rated 5, 6, or 7 are valid choices. However, in order to not skip any adapters, you have to pick the adapter rated 5 jolts (difference of ~1~).~
~Similarly, the next choices would need to be the adapter rated 6 and then the adapter rated 7 (with difference of ~1~ and ~1~).~
~The only adapter that works with the 7-jolt rated adapter is the one rated 10 jolts (difference of ~3~).~
~From 10, the choices are 11 or 12; choose 11 (difference of ~1~) and then 12 (difference of ~1~).~
~After 12, only valid adapter has a rating of 15 (difference of ~3~), then 16 (difference of ~1~), then 19 (difference of ~3~).~
~Finally, your device's built-in adapter is always 3 higher than the highest adapter, so its rating is 22 jolts (always a difference of ~3~).~

In this example, when using every adapter, there are ~7~ differences of 1 jolt and ~5~ differences of 3 jolts.
Here is a larger example:

#+begin_src text
28
33
18
42
31
14
46
20
48
47
24
23
49
45
19
38
39
11
1
32
25
35
8
17
7
9
4
2
34
10
3

#+end_src

In this larger example, in a chain that uses all of the adapters, there are ~22~ differences of 1 jolt and ~10~ differences of 3 jolts.
Find a chain that uses all of your adapters to connect the charging outlet to your device's built-in adapter and count the joltage differences between the charging outlet, the adapters, and your device. ~What is the number of 1-jolt differences multiplied by the number of 3-jolt differences?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-10 :var input_data=input-2020-10 :tangle /tmp/advent_of_code/aoc2020-10-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-10 :var input_data=input-2020-10 :tangle /tmp/advent_of_code/aoc2020-10-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-10 :var input_data=input-2020-10 :tangle /tmp/advent_of_code/aoc2020-10-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-10 :var input_data=input-2020-10 :tangle /tmp/advent_of_code/aoc2020-10-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-10 :var input_data=input-2020-10 :tangle /tmp/advent_of_code/aoc2020-10-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-10 :var input_data=input-2020-10 :tangle /tmp/advent_of_code/aoc2020-10-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-10 :var input_data=input-2020-10 :tangle /tmp/advent_of_code/aoc2020-10-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-10 :var input_data=input-2020-10 :tangle /tmp/advent_of_code/aoc2020-10-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-10 :var input_data=input-2020-10 :tangle /tmp/advent_of_code/aoc2020-10-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-10 :var input_data=input-2020-10 :tangle /tmp/advent_of_code/aoc2020-10-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-10 :var input_data=input-2020-10 :tangle /tmp/advent_of_code/aoc2020-10-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-10 :var input_data=input-2020-10 :tangle /tmp/advent_of_code/aoc2020-10-2.pl :results output 
#+end_src
*** Day 11: Seating System
**** Part 1
***** Description
By modeling the process people use to choose (or abandon) their seat in the waiting area, you're pretty sure you can predict the best place to sit. You make a quick map of the seat layout (your puzzle input).
The seat layout fits neatly on a grid. Each position is either floor (.), an empty seat (L), or an occupied seat (#). For example, the initial seat layout might look like this:

#+begin_src text
L.LL.LL.LL
LLLLLLL.LL
L.L.L..L..
LLLL.LL.LL
L.LL.LL.LL
L.LLLLL.LL
..L.L.....
LLLLLLLLLL
L.LLLLLL.L
L.LLLLL.LL

#+end_src

Now, you just need to model the people who will be arriving shortly. Fortunately, people are entirely predictable and always follow a simple set of rules. All decisions are based on the ~number of occupied seats~ adjacent to a given seat (one of the eight positions immediately up, down, left, right, or diagonal from the seat). The following rules are applied to every seat simultaneously:

~If a seat is ~empty~ (L) and there are ~no~ occupied seats adjacent to it, the seat becomes ~occupied~.~
~If a seat is ~occupied~ (#) and ~four or more~ seats adjacent to it are also occupied, the seat becomes ~empty~.~
~Otherwise, the seat's state does not change.~

<span title="Floor... floor never changes.">Floor (.) never changes</span>; seats don't move, and nobody sits on the floor.
After one round of these rules, every seat in the example layout becomes occupied:

#+begin_src text
#.##.##.##
#######.##
#.#.#..#..
####.##.##
#.##.##.##
#.#####.##
..#.#.....
##########
#.######.#
#.#####.##

#+end_src

After a second round, the seats with four or more occupied adjacent seats become empty again:

#+begin_src text
#.LL.L#.##
#LLLLLL.L#
L.L.L..L..
#LLL.LL.L#
#.LL.LL.LL
#.LLLL#.##
..L.L.....
#LLLLLLLL#
#.LLLLLL.L
#.#LLLL.##

#+end_src

This process continues for three more rounds:

#+begin_src text
#.##.L#.##
#L###LL.L#
L.#.#..#..
#L##.##.L#
#.##.LL.LL
#.###L#.##
..#.#.....
#L######L#
#.LL###L.L
#.#L###.##

#+end_src


#+begin_src text
#.#L.L#.##
#LLL#LL.L#
L.L.L..#..
#LLL.##.L#
#.LL.LL.LL
#.LL#L#.##
..L.L.....
#L#LLLL#L#
#.LLLLLL.L
#.#L#L#.##

#+end_src


#+begin_src text
#.#L.L#.##
#LLL#LL.L#
L.#.L..#..
#L##.##.L#
#.#L.LL.LL
#.#L#L#.##
..L.L.....
#L#L##L#L#
#.LLLLLL.L
#.#L#L#.##

#+end_src

At this point, something interesting happens: the chaos stabilizes and further applications of these rules cause no seats to change state! Once people stop moving around, you count ~37~ occupied seats.
Simulate your seating area by applying the seating rules repeatedly until no seats change state. ~How many seats end up occupied?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-11 :var input_data=input-2020-11 :tangle /tmp/advent_of_code/aoc2020-11-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-11 :var input_data=input-2020-11 :tangle /tmp/advent_of_code/aoc2020-11-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-11 :var input_data=input-2020-11 :tangle /tmp/advent_of_code/aoc2020-11-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-11 :var input_data=input-2020-11 :tangle /tmp/advent_of_code/aoc2020-11-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-11 :var input_data=input-2020-11 :tangle /tmp/advent_of_code/aoc2020-11-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-11 :var input_data=input-2020-11 :tangle /tmp/advent_of_code/aoc2020-11-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-11 :var input_data=input-2020-11 :tangle /tmp/advent_of_code/aoc2020-11-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-11 :var input_data=input-2020-11 :tangle /tmp/advent_of_code/aoc2020-11-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-11 :var input_data=input-2020-11 :tangle /tmp/advent_of_code/aoc2020-11-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-11 :var input_data=input-2020-11 :tangle /tmp/advent_of_code/aoc2020-11-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-11 :var input_data=input-2020-11 :tangle /tmp/advent_of_code/aoc2020-11-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-11 :var input_data=input-2020-11 :tangle /tmp/advent_of_code/aoc2020-11-2.pl :results output 
#+end_src
*** Day 12: Rain Risk
**** Part 1
***** Description
Unfortunately, the ship's navigation computer seems to be malfunctioning; rather than giving a route directly to safety, it produced extremely circuitous instructions. When the captain uses the <a href="https://en.wikipedia.org/wiki/Public_address_system" target="_blank">PA system</a> to ask if anyone can help, you quickly volunteer.
The navigation instructions (your puzzle input) consists of a sequence of single-character ~actions~ paired with integer input ~values~. After staring at them for a few minutes, you work out what they probably mean:

~Action ~N~ means to move ~north~ by the given value.~
~Action ~S~ means to move ~south~ by the given value.~
~Action ~E~ means to move ~east~ by the given value.~
~Action ~W~ means to move ~west~ by the given value.~
~Action ~L~ means to turn ~left~ the given number of degrees.~
~Action ~R~ means to turn ~right~ the given number of degrees.~
~Action ~F~ means to move ~forward~ by the given value in the direction the ship is currently facing.~

The ship starts by facing ~east~. Only the L and R actions change the direction the ship is facing. (That is, if the ship is facing east and the next instruction is N10, the ship would move north 10 units, but would still move east if the following action were F.)
For example:

#+begin_src text
F10
N3
F7
R90
F11

#+end_src

These instructions would be handled as follows:

~F10 would move the ship 10 units east (because the ship starts by facing east) to ~east 10, north 0~.~
~N3 would move the ship 3 units north to ~east 10, north 3~.~
~F7 would move the ship another 7 units east (because the ship is still facing east) to ~east 17, north 3~.~
~R90 would cause the ship to turn right by 90 degrees and face ~south~; it remains at ~east 17, north 3~.~
~F11 would move the ship 11 units south to ~east 17, south 8~.~

At the end of these instructions, the ship's <a href="https://en.wikipedia.org/wiki/Manhattan_distance" target="_blank">Manhattan distance</a> (sum of the absolute values of its east/west position and its north/south position) from its starting position is 17 + 8 = ~25~.
Figure out where the navigation instructions lead. ~What is the Manhattan distance between that location and the ship's starting position?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-12 :var input_data=input-2020-12 :tangle /tmp/advent_of_code/aoc2020-12-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-12 :var input_data=input-2020-12 :tangle /tmp/advent_of_code/aoc2020-12-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-12 :var input_data=input-2020-12 :tangle /tmp/advent_of_code/aoc2020-12-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-12 :var input_data=input-2020-12 :tangle /tmp/advent_of_code/aoc2020-12-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-12 :var input_data=input-2020-12 :tangle /tmp/advent_of_code/aoc2020-12-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-12 :var input_data=input-2020-12 :tangle /tmp/advent_of_code/aoc2020-12-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-12 :var input_data=input-2020-12 :tangle /tmp/advent_of_code/aoc2020-12-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-12 :var input_data=input-2020-12 :tangle /tmp/advent_of_code/aoc2020-12-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-12 :var input_data=input-2020-12 :tangle /tmp/advent_of_code/aoc2020-12-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-12 :var input_data=input-2020-12 :tangle /tmp/advent_of_code/aoc2020-12-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-12 :var input_data=input-2020-12 :tangle /tmp/advent_of_code/aoc2020-12-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-12 :var input_data=input-2020-12 :tangle /tmp/advent_of_code/aoc2020-12-2.pl :results output 
#+end_src
*** Day 13: Shuttle Search
**** Part 1
***** Description
Fortunately, a shuttle bus service is available to bring you from the sea port to the airport!  Each bus has an ID number that also indicates ~how often the bus leaves for the airport~.
Bus schedules are defined based on a ~timestamp~ that measures the ~number of minutes~ since some fixed reference point in the past. At timestamp 0, every bus simultaneously departed from the sea port. After that, each bus travels to the airport, then various other locations, and finally returns to the sea port to repeat its journey forever.
The time this loop takes a particular bus is also its ID number: the bus with ID 5 departs from the sea port at timestamps 0, 5, 10, 15, and so on. The bus with ID 11 departs at 0, 11, 22, 33, and so on. If you are there when the bus departs, you can ride that bus to the airport!
Your notes (your puzzle input) consist of two lines.  The first line is your estimate of the ~earliest timestamp you could depart on a bus~. The second line lists the bus IDs that are in service according to the shuttle company; entries that show x must be out of service, so you decide to ignore them.
To save time once you arrive, your goal is to figure out ~the earliest bus you can take to the airport~. (There will be exactly one such bus.)
For example, suppose you have the following notes:

#+begin_src text
939
7,13,x,x,59,x,31,19

#+end_src

Here, the earliest timestamp you could depart is 939, and the bus IDs in service are 7, 13, 59, 31, and 19. Near timestamp 939, these bus IDs depart at the times marked D:

#+begin_src text
time   bus 7   bus 13  bus 59  bus 31  bus 19
929      .       .       .       .       .
930      .       .       .       D       .
931      D       .       .       .       D
932      .       .       .       .       .
933      .       .       .       .       .
934      .       .       .       .       .
935      .       .       .       .       .
936      .       D       .       .       .
937      .       .       .       .       .
938      D       .       .       .       .
~939      .       .       .       .       .~
940      .       .       .       .       .
941      .       .       .       .       .
942      .       .       .       .       .
943      .       .       .       .       .
~944      .       .       D       .       .~
945      D       .       .       .       .
946      .       .       .       .       .
947      .       .       .       .       .
948      .       .       .       .       .
949      .       D       .       .       .

#+end_src

The earliest bus you could take is bus ID 59. It doesn't depart until timestamp 944, so you would need to wait 944 - 939 = 5 minutes before it departs. Multiplying the bus ID by the number of minutes you'd need to wait gives ~295~.
~What is the ID of the earliest bus you can take to the airport multiplied by the number of minutes you'll need to wait for that bus?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-13 :var input_data=input-2020-13 :tangle /tmp/advent_of_code/aoc2020-13-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-13 :var input_data=input-2020-13 :tangle /tmp/advent_of_code/aoc2020-13-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-13 :var input_data=input-2020-13 :tangle /tmp/advent_of_code/aoc2020-13-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-13 :var input_data=input-2020-13 :tangle /tmp/advent_of_code/aoc2020-13-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-13 :var input_data=input-2020-13 :tangle /tmp/advent_of_code/aoc2020-13-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-13 :var input_data=input-2020-13 :tangle /tmp/advent_of_code/aoc2020-13-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-13 :var input_data=input-2020-13 :tangle /tmp/advent_of_code/aoc2020-13-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-13 :var input_data=input-2020-13 :tangle /tmp/advent_of_code/aoc2020-13-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-13 :var input_data=input-2020-13 :tangle /tmp/advent_of_code/aoc2020-13-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-13 :var input_data=input-2020-13 :tangle /tmp/advent_of_code/aoc2020-13-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-13 :var input_data=input-2020-13 :tangle /tmp/advent_of_code/aoc2020-13-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-13 :var input_data=input-2020-13 :tangle /tmp/advent_of_code/aoc2020-13-2.pl :results output 
#+end_src
*** Day 14: Docking Data
**** Part 1
***** Description
After a brief inspection, you discover that the sea port's computer system uses a strange <a href="https://en.wikipedia.org/wiki/Mask_(computing)" target="_blank">bitmask</a> system in its initialization program. Although you don't have the correct decoder chip handy, you can emulate it in software!
The initialization program (your puzzle input) can either update the bitmask or write a value to memory.  Values and memory addresses are both 36-bit unsigned integers.  For example, ignoring bitmasks for a moment, a line like mem[8] = 11 would write the value 11 to memory address 8.
The bitmask is always given as a string of 36 bits, written with the most significant bit (representing 2^35) on the left and the least significant bit (2^0, that is, the 1s bit) on the right. The current bitmask is applied to values immediately before they are written to memory: a 0 or 1 overwrites the corresponding bit in the value, while an X leaves the bit in the value unchanged.
For example, consider the following program:

#+begin_src text
mask = XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
mem[8] = 11
mem[7] = 101
mem[8] = 0

#+end_src

This program starts by specifying a bitmask (mask = ....). The mask it specifies will overwrite two bits in every written value: the 2s bit is overwritten with 0, and the 64s bit is overwritten with 1.
The program then attempts to write the value 11 to memory address 8. By expanding everything out to individual bits, the mask is applied as follows:

#+begin_src text
value:  000000000000000000000000000000001011  (decimal 11)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 00000000000000000000000000000~1~0010~0~1  (decimal 73)

#+end_src

So, because of the mask, the value 73 is written to memory address 8 instead. Then, the program tries to write 101 to address 7:

#+begin_src text
value:  000000000000000000000000000001100101  (decimal 101)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 00000000000000000000000000000~1~1001~0~1  (decimal 101)

#+end_src

This time, the mask has no effect, as the bits it overwrote were already the values the mask tried to set. Finally, the program tries to write 0 to address 8:

#+begin_src text
value:  000000000000000000000000000000000000  (decimal 0)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 00000000000000000000000000000~1~0000~0~0  (decimal 64)

#+end_src

64 is written to address 8 instead, overwriting the value that was there previously.
To initialize your ferry's docking program, you need the sum of all values left in memory after the initialization program completes. (The entire 36-bit address space begins initialized to the value 0 at every address.) In the above example, only two values in memory are not zero - 101 (at address 7) and 64 (at address 8) - producing a sum of ~165~.
Execute the initialization program. ~What is the sum of all values left in memory after it completes?~ (Do not truncate the sum to 36 bits.)
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-14 :var input_data=input-2020-14 :tangle /tmp/advent_of_code/aoc2020-14-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-14 :var input_data=input-2020-14 :tangle /tmp/advent_of_code/aoc2020-14-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-14 :var input_data=input-2020-14 :tangle /tmp/advent_of_code/aoc2020-14-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-14 :var input_data=input-2020-14 :tangle /tmp/advent_of_code/aoc2020-14-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-14 :var input_data=input-2020-14 :tangle /tmp/advent_of_code/aoc2020-14-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-14 :var input_data=input-2020-14 :tangle /tmp/advent_of_code/aoc2020-14-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-14 :var input_data=input-2020-14 :tangle /tmp/advent_of_code/aoc2020-14-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-14 :var input_data=input-2020-14 :tangle /tmp/advent_of_code/aoc2020-14-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-14 :var input_data=input-2020-14 :tangle /tmp/advent_of_code/aoc2020-14-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-14 :var input_data=input-2020-14 :tangle /tmp/advent_of_code/aoc2020-14-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-14 :var input_data=input-2020-14 :tangle /tmp/advent_of_code/aoc2020-14-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-14 :var input_data=input-2020-14 :tangle /tmp/advent_of_code/aoc2020-14-2.pl :results output 
#+end_src
*** Day 15: Rambunctious Recitation
**** Part 1
***** Description
While you wait for your flight, you decide to check in with the Elves back at the North Pole. They're playing a ~memory game~ and are <span title="Of course they are.">ever so excited</span> to explain the rules!
In this game, the players take turns saying ~numbers~. They begin by taking turns reading from a list of ~starting numbers~ (your puzzle input). Then, each turn consists of considering the ~most recently spoken number~:

~If that was the ~first~ time the number has been spoken, the current player says ~0~.~
~Otherwise, the number had been spoken before; the current player announces ~how many turns apart~ the number is from when it was previously spoken.~

So, after the starting numbers, each turn results in that player speaking aloud either ~0~ (if the last number is new) or an ~age~ (if the last number is a repeat).
For example, suppose the starting numbers are 0,3,6:

~~Turn 1~: The 1st number spoken is a starting number, ~0~.~
~~Turn 2~: The 2nd number spoken is a starting number, ~3~.~
~~Turn 3~: The 3rd number spoken is a starting number, ~6~.~
~~Turn 4~: Now, consider the last number spoken, 6. Since that was the first time the number had been spoken, the 4th number spoken is ~0~.~
~~Turn 5~: Next, again consider the last number spoken, 0. Since it ~had~ been spoken before, the next number to speak is the difference between the turn number when it was last spoken (the previous turn, 4) and the turn number of the time it was most recently spoken before then (turn 1). Thus, the 5th number spoken is 4 - 1, ~3~.~
~~Turn 6~: The last number spoken, 3 had also been spoken before, most recently on turns 5 and 2. So, the 6th number spoken is 5 - 2, ~3~.~
~~Turn 7~: Since 3 was just spoken twice in a row, and the last two turns are 1 turn apart, the 7th number spoken is ~1~.~
~~Turn 8~: Since 1 is new, the 8th number spoken is ~0~.~
~~Turn 9~: 0 was last spoken on turns 8 and 4, so the 9th number spoken is the difference between them, ~4~.~
~~Turn 10~: 4 is new, so the 10th number spoken is ~0~.~

(The game ends when the Elves get sick of playing or dinner is ready, whichever comes first.)
Their question for you is: what will be the ~2020th~ number spoken? In the example above, the 2020th number spoken will be 436.
Here are a few more examples:

~Given the starting numbers 1,3,2, the 2020th number spoken is 1.~
~Given the starting numbers 2,1,3, the 2020th number spoken is 10.~
~Given the starting numbers 1,2,3, the 2020th number spoken is 27.~
~Given the starting numbers 2,3,1, the 2020th number spoken is 78.~
~Given the starting numbers 3,2,1, the 2020th number spoken is 438.~
~Given the starting numbers 3,1,2, the 2020th number spoken is 1836.~

Given your starting numbers, ~what will be the 2020th number spoken?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-15 :var input_data=input-2020-15 :tangle /tmp/advent_of_code/aoc2020-15-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-15 :var input_data=input-2020-15 :tangle /tmp/advent_of_code/aoc2020-15-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-15 :var input_data=input-2020-15 :tangle /tmp/advent_of_code/aoc2020-15-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-15 :var input_data=input-2020-15 :tangle /tmp/advent_of_code/aoc2020-15-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-15 :var input_data=input-2020-15 :tangle /tmp/advent_of_code/aoc2020-15-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-15 :var input_data=input-2020-15 :tangle /tmp/advent_of_code/aoc2020-15-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-15 :var input_data=input-2020-15 :tangle /tmp/advent_of_code/aoc2020-15-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-15 :var input_data=input-2020-15 :tangle /tmp/advent_of_code/aoc2020-15-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-15 :var input_data=input-2020-15 :tangle /tmp/advent_of_code/aoc2020-15-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-15 :var input_data=input-2020-15 :tangle /tmp/advent_of_code/aoc2020-15-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-15 :var input_data=input-2020-15 :tangle /tmp/advent_of_code/aoc2020-15-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-15 :var input_data=input-2020-15 :tangle /tmp/advent_of_code/aoc2020-15-2.pl :results output 
#+end_src
*** Day 16: Ticket Translation
**** Part 1
***** Description
Unfortunately, you <span title="This actually happened to me once, but I solved it by just asking someone.">can't actually ~read~ the words on the ticket</span>. You can, however, read the numbers, and so you figure out ~the fields these tickets must have~ and ~the valid ranges~ for values in those fields.
You collect the ~rules for ticket fields~, the ~numbers on your ticket~, and the ~numbers on other nearby tickets~ for the same train service (via the airport security cameras) together into a single document you can reference (your puzzle input).
The ~rules for ticket fields~ specify a list of fields that exist ~somewhere~ on the ticket and the ~valid ranges of values~ for each field. For example, a rule like class: 1-3 or 5-7 means that one of the fields in every ticket is named class and can be any value in the ranges 1-3 or 5-7 (inclusive, such that 3 and 5 are both valid in this field, but 4 is not).
Each ticket is represented by a single line of comma-separated values. The values are the numbers on the ticket in the order they appear; every ticket has the same format. For example, consider this ticket:

#+begin_src text
.--------------------------------------------------------.
| ????: 101    ?????: 102   ??????????: 103     ???: 104 |
|                                                        |
| ??: 301  ??: 302             ???????: 303      ??????? |
| ??: 401  ??: 402           ???? ????: 403    ????????? |
'--------------------------------------------------------'

#+end_src

Here, ? represents text in a language you don't understand. This ticket might be represented as 101,102,103,104,301,302,303,401,402,403; of course, the actual train tickets you're looking at are ~much~ more complicated. In any case, you've extracted just the numbers in such a way that the first number is always the same specific field, the second number is always a different specific field, and so on - you just don't know what each position actually means!
Start by determining which tickets are ~completely invalid~; these are tickets that contain values which ~aren't valid for any field~. Ignore ~your ticket~ for now.
For example, suppose you have the following notes:

#+begin_src text
class: 1-3 or 5-7
row: 6-11 or 33-44
seat: 13-40 or 45-50

your ticket:
7,1,14

nearby tickets:
7,3,47
40,~4~,50
~55~,2,20
38,6,~12~

#+end_src

It doesn't matter which position corresponds to which field; you can identify invalid ~nearby tickets~ by considering only whether tickets contain ~values that are not valid for any field~. In this example, the values on the first ~nearby ticket~ are all valid for at least one field. This is not true of the other three ~nearby tickets~: the values 4, 55, and 12 are are not valid for any field. Adding together all of the invalid values produces your ~ticket scanning error rate~: 4 + 55 + 12 = ~71~.
Consider the validity of the ~nearby tickets~ you scanned. ~What is your ticket scanning error rate?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-16 :var input_data=input-2020-16 :tangle /tmp/advent_of_code/aoc2020-16-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-16 :var input_data=input-2020-16 :tangle /tmp/advent_of_code/aoc2020-16-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-16 :var input_data=input-2020-16 :tangle /tmp/advent_of_code/aoc2020-16-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-16 :var input_data=input-2020-16 :tangle /tmp/advent_of_code/aoc2020-16-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-16 :var input_data=input-2020-16 :tangle /tmp/advent_of_code/aoc2020-16-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-16 :var input_data=input-2020-16 :tangle /tmp/advent_of_code/aoc2020-16-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-16 :var input_data=input-2020-16 :tangle /tmp/advent_of_code/aoc2020-16-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-16 :var input_data=input-2020-16 :tangle /tmp/advent_of_code/aoc2020-16-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-16 :var input_data=input-2020-16 :tangle /tmp/advent_of_code/aoc2020-16-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-16 :var input_data=input-2020-16 :tangle /tmp/advent_of_code/aoc2020-16-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-16 :var input_data=input-2020-16 :tangle /tmp/advent_of_code/aoc2020-16-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-16 :var input_data=input-2020-16 :tangle /tmp/advent_of_code/aoc2020-16-2.pl :results output 
#+end_src
*** Day 17: Conway Cubes
**** Part 1
***** Description
The experimental energy source is based on cutting-edge technology: a set of <span title="Rest in peace, Conway.">Conway</span> Cubes contained in a pocket dimension! When you hear it's having problems, you can't help but agree to take a look.
The pocket dimension contains an infinite 3-dimensional grid. At every integer 3-dimensional coordinate (x,y,z), there exists a single cube which is either ~active~ or ~inactive~.
In the initial state of the pocket dimension, almost all cubes start ~inactive~. The only exception to this is a small flat region of cubes (your puzzle input); the cubes in this region start in the specified ~active~ (#) or ~inactive~ (.) state.
The energy source then proceeds to boot up by executing six ~cycles~.
Each cube only ever considers its ~neighbors~: any of the 26 other cubes where any of their coordinates differ by at most 1. For example, given the cube at x=1,y=2,z=3, its neighbors include the cube at x=2,y=2,z=2, the cube at x=0,y=2,z=3, and so on.
During a cycle, ~all~ cubes ~simultaneously~ change their state according to the following rules:

~If a cube is ~active~ and ~exactly 2 or 3~ of its neighbors are also active, the cube remains ~active~. Otherwise, the cube becomes ~inactive~.~
~If a cube is ~inactive~ but ~exactly 3~ of its neighbors are active, the cube becomes ~active~. Otherwise, the cube remains ~inactive~.~

The engineers responsible for this experimental energy source would like you to simulate the pocket dimension and determine what the configuration of cubes should be at the end of the six-cycle boot process.
For example, consider the following initial state:

#+begin_src text
.#.
..#
###

#+end_src

Even though the pocket dimension is 3-dimensional, this initial state represents a small 2-dimensional slice of it. (In particular, this initial state defines a 3x3x1 region of the 3-dimensional space.)
Simulating a few cycles from this initial state produces the following configurations, where the result of each cycle is shown layer-by-layer at each given z coordinate (and the frame of view follows the active cells in each cycle):

#+begin_src text
Before any cycles:

z=0
.#.
..#
###


After 1 cycle:

z=-1
#..
..#
.#.

z=0
#.#
.##
.#.

z=1
#..
..#
.#.


After 2 cycles:

z=-2
.....
.....
..#..
.....
.....

z=-1
..#..
.#..#
....#
.#...
.....

z=0
##...
##...
#....
....#
.###.

z=1
..#..
.#..#
....#
.#...
.....

z=2
.....
.....
..#..
.....
.....


After 3 cycles:

z=-2
.......
.......
..##...
..###..
.......
.......
.......

z=-1
..#....
...#...
#......
.....##
.#...#.
..#.#..
...#...

z=0
...#...
.......
#......
.......
.....##
.##.#..
...#...

z=1
..#....
...#...
#......
.....##
.#...#.
..#.#..
...#...

z=2
.......
.......
..##...
..###..
.......
.......
.......

#+end_src

After the full six-cycle boot process completes, ~112~ cubes are left in the ~active~ state.
Starting with your given initial configuration, simulate six cycles. ~How many cubes are left in the active state after the sixth cycle?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-17 :var input_data=input-2020-17 :tangle /tmp/advent_of_code/aoc2020-17-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-17 :var input_data=input-2020-17 :tangle /tmp/advent_of_code/aoc2020-17-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-17 :var input_data=input-2020-17 :tangle /tmp/advent_of_code/aoc2020-17-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-17 :var input_data=input-2020-17 :tangle /tmp/advent_of_code/aoc2020-17-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-17 :var input_data=input-2020-17 :tangle /tmp/advent_of_code/aoc2020-17-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-17 :var input_data=input-2020-17 :tangle /tmp/advent_of_code/aoc2020-17-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-17 :var input_data=input-2020-17 :tangle /tmp/advent_of_code/aoc2020-17-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-17 :var input_data=input-2020-17 :tangle /tmp/advent_of_code/aoc2020-17-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-17 :var input_data=input-2020-17 :tangle /tmp/advent_of_code/aoc2020-17-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-17 :var input_data=input-2020-17 :tangle /tmp/advent_of_code/aoc2020-17-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-17 :var input_data=input-2020-17 :tangle /tmp/advent_of_code/aoc2020-17-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-17 :var input_data=input-2020-17 :tangle /tmp/advent_of_code/aoc2020-17-2.pl :results output 
#+end_src
*** Day 18: Operation Order
**** Part 1
***** Description
Unfortunately, it seems like this "math" <a href="https://www.youtube.com/watch?v=3QtRK7Y2pPU&amp;t=15" target="_blank">follows different rules</a> than you remember.
The homework (your puzzle input) consists of a series of expressions that consist of addition (+), multiplication (*), and parentheses ((...)). Just like normal math, parentheses indicate that the expression inside must be evaluated before it can be used by the surrounding expression. Addition still finds the sum of the numbers on both sides of the operator, and multiplication still finds the product.
However, the rules of ~operator precedence~ have changed. Rather than evaluating multiplication before addition, the operators have the ~same precedence~, and are evaluated left-to-right regardless of the order in which they appear.
For example, the steps to evaluate the expression 1 + 2 * 3 + 4 * 5 + 6 are as follows:

#+begin_src text
~1 + 2~ * 3 + 4 * 5 + 6
  ~3   * 3~ + 4 * 5 + 6
      ~9   + 4~ * 5 + 6
         ~13   * 5~ + 6
             ~65   + 6~
                 ~71~

#+end_src

Parentheses can override this order; for example, here is what happens if parentheses are added to form 1 + (2 * 3) + (4 * (5 + 6)):

#+begin_src text
1 + ~(2 * 3)~ + (4 * (5 + 6))
~1 +    6~    + (4 * (5 + 6))
     7      + (4 * ~(5 + 6)~)
     7      + ~(4 *   11   )~
     ~7      +     44~
            ~51~

#+end_src

Here are a few more examples:

~2 * 3 + (4 * 5) becomes ~26~.~
~5 + (8 * 3 + 9 + 3 * 4 * 3) becomes ~437~.~
~5 * 9 * (7 * 3 * 3 + 9 * 3 + (8 + 6 * 4)) becomes ~12240~.~
~((2 + 4 * 9) * (6 + 9 * 8 + 6) + 6) + 2 + 4 * 2 becomes ~13632~.~

Before you can help with the homework, you need to understand it yourself. ~Evaluate the expression on each line of the homework; what is the sum of the resulting values?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-18 :var input_data=input-2020-18 :tangle /tmp/advent_of_code/aoc2020-18-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-18 :var input_data=input-2020-18 :tangle /tmp/advent_of_code/aoc2020-18-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-18 :var input_data=input-2020-18 :tangle /tmp/advent_of_code/aoc2020-18-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-18 :var input_data=input-2020-18 :tangle /tmp/advent_of_code/aoc2020-18-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-18 :var input_data=input-2020-18 :tangle /tmp/advent_of_code/aoc2020-18-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-18 :var input_data=input-2020-18 :tangle /tmp/advent_of_code/aoc2020-18-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-18 :var input_data=input-2020-18 :tangle /tmp/advent_of_code/aoc2020-18-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-18 :var input_data=input-2020-18 :tangle /tmp/advent_of_code/aoc2020-18-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-18 :var input_data=input-2020-18 :tangle /tmp/advent_of_code/aoc2020-18-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-18 :var input_data=input-2020-18 :tangle /tmp/advent_of_code/aoc2020-18-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-18 :var input_data=input-2020-18 :tangle /tmp/advent_of_code/aoc2020-18-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-18 :var input_data=input-2020-18 :tangle /tmp/advent_of_code/aoc2020-18-2.pl :results output 
#+end_src
*** Day 19: Monster Messages
**** Part 1
***** Description
They sent you a list of ~the rules valid messages should obey~ and a list of ~received messages~ they've collected so far (your puzzle input).
The ~rules for valid messages~ (the top part of your puzzle input) are numbered and build upon each other. For example:

#+begin_src text
0: 1 2
1: "a"
2: 1 3 | 3 1
3: "b"

#+end_src

Some rules, like 3: "b", simply match a single character (in this case, b).
The remaining rules list the sub-rules that must be followed; for example, the rule 0: 1 2 means that to match rule 0, the text being checked must match rule 1, and the text after the part that matched rule 1 must then match rule 2.
Some of the rules have multiple lists of sub-rules separated by a pipe (|). This means that ~at least one~ list of sub-rules must match. (The ones that match might be different each time the rule is encountered.) For example, the rule 2: 1 3 | 3 1 means that to match rule 2, the text being checked must match rule 1 followed by rule 3 ~or~ it must match rule 3 followed by rule 1.
Fortunately, there are no loops in the rules, so the list of possible matches will be finite. Since rule 1 matches a and rule 3 matches b, rule 2 matches either ab or ba. Therefore, rule 0 matches aab or aba.
Here's a more interesting example:

#+begin_src text
0: 4 1 5
1: 2 3 | 3 2
2: 4 4 | 5 5
3: 4 5 | 5 4
4: "a"
5: "b"

#+end_src

Here, because rule 4 matches a and rule 5 matches b, rule 2 matches two letters that are the same (aa or bb), and rule 3 matches two letters that are different (ab or ba).
Since rule 1 matches rules 2 and 3 once each in either order, it must match two pairs of letters, one pair with matching letters and one pair with different letters. This leaves eight possibilities: aaab, aaba, bbab, bbba, abaa, abbb, baaa, or babb.
Rule 0, therefore, matches a (rule 4), then any of the eight options from rule 1, then b (rule 5): aaaabb, aaabab, abbabb, abbbab, aabaab, aabbbb, abaaab, or ababbb.
The ~received messages~ (the bottom part of your puzzle input) need to be checked against the rules so you can determine which are valid and which are corrupted. Including the rules and the messages together, this might look like:

#+begin_src text
0: 4 1 5
1: 2 3 | 3 2
2: 4 4 | 5 5
3: 4 5 | 5 4
4: "a"
5: "b"

ababbb
bababa
abbbab
aaabbb
aaaabbb

#+end_src

Your goal is to determine ~the number of messages that completely match rule 0~. In the above example, ababbb and abbbab match, but bababa, aaabbb, and aaaabbb do not, producing the answer ~2~. The whole message must match all of rule 0; there can't be extra unmatched characters in the message. (For example, aaaabbb might appear to match rule 0 above, but it has an extra unmatched b on the end.)
~How many messages completely match rule 0?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-19 :var input_data=input-2020-19 :tangle /tmp/advent_of_code/aoc2020-19-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-19 :var input_data=input-2020-19 :tangle /tmp/advent_of_code/aoc2020-19-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-19 :var input_data=input-2020-19 :tangle /tmp/advent_of_code/aoc2020-19-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-19 :var input_data=input-2020-19 :tangle /tmp/advent_of_code/aoc2020-19-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-19 :var input_data=input-2020-19 :tangle /tmp/advent_of_code/aoc2020-19-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-19 :var input_data=input-2020-19 :tangle /tmp/advent_of_code/aoc2020-19-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-19 :var input_data=input-2020-19 :tangle /tmp/advent_of_code/aoc2020-19-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-19 :var input_data=input-2020-19 :tangle /tmp/advent_of_code/aoc2020-19-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-19 :var input_data=input-2020-19 :tangle /tmp/advent_of_code/aoc2020-19-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-19 :var input_data=input-2020-19 :tangle /tmp/advent_of_code/aoc2020-19-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-19 :var input_data=input-2020-19 :tangle /tmp/advent_of_code/aoc2020-19-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-19 :var input_data=input-2020-19 :tangle /tmp/advent_of_code/aoc2020-19-2.pl :results output 
#+end_src
*** Day 20: Jurassic Jigsaw
**** Part 1
***** Description
After decoding the satellite messages, you discover that the data actually contains many small images created by the satellite's ~camera array~. The camera array consists of many cameras; rather than produce a single square image, they produce many smaller square image ~tiles~ that need to be ~reassembled back into a single image~.
Each camera in the camera array returns a single monochrome ~image tile~ with a random unique ~ID number~.  The tiles (your puzzle input) arrived in a random order.
Worse yet, the camera array appears to be malfunctioning: each image tile has been ~rotated and flipped to a random orientation~. Your first task is to reassemble the original image by orienting the tiles so they fit together.
To show how the tiles should be reassembled, each tile's image data includes a border that should line up exactly with its adjacent tiles. All tiles have this border, and the border lines up exactly when the tiles are both oriented correctly. Tiles at the edge of the image also have this border, but the outermost edges won't line up with any other tiles.
For example, suppose you have the following nine tiles:

#+begin_src text
Tile 2311:
..##.#..#.
##..#.....
#...##..#.
####.#...#
##.##.###.
##...#.###
.#.#.#..##
..#....#..
###...#.#.
..###..###

Tile 1951:
#.##...##.
#.####...#
.....#..##
#...######
.##.#....#
.###.#####
###.##.##.
.###....#.
..#.#..#.#
#...##.#..

Tile 1171:
####...##.
#..##.#..#
##.#..#.#.
.###.####.
..###.####
.##....##.
.#...####.
#.##.####.
####..#...
.....##...

Tile 1427:
###.##.#..
.#..#.##..
.#.##.#..#
#.#.#.##.#
....#...##
...##..##.
...#.#####
.#.####.#.
..#..###.#
..##.#..#.

Tile 1489:
##.#.#....
..##...#..
.##..##...
..#...#...
#####...#.
#..#.#.#.#
...#.#.#..
##.#...##.
..##.##.##
###.##.#..

Tile 2473:
#....####.
#..#.##...
#.##..#...
######.#.#
.#...#.#.#
.#########
.###.#..#.
########.#
##...##.#.
..###.#.#.

Tile 2971:
..#.#....#
#...###...
#.#.###...
##.##..#..
.#####..##
.#..####.#
#..#.#..#.
..####.###
..#.#.###.
...#.#.#.#

Tile 2729:
...#.#.#.#
####.#....
..#.#.....
....#..#.#
.##..##.#.
.#.####...
####.#.#..
##.####...
##..#.##..
#.##...##.

Tile 3079:
#.#.#####.
.#..######
..#.......
######....
####.#..#.
.#...#.##.
#.#####.##
..#.###...
..#.......
..#.###...

#+end_src

By rotating, flipping, and rearranging them, you can find a square arrangement that causes all adjacent borders to line up:

#+begin_src text
#...##.#.. ..###..### #.#.#####.
..#.#..#.# ###...#.#. .#..######
.###....#. ..#....#.. ..#.......
###.##.##. .#.#.#..## ######....
.###.##### ##...#.### ####.#..#.
.##.#....# ##.##.###. .#...#.##.
#...###### ####.#...# #.#####.##
.....#..## #...##..#. ..#.###...
#.####...# ##..#..... ..#.......
#.##...##. ..##.#..#. ..#.###...

#.##...##. ..##.#..#. ..#.###...
##..#.##.. ..#..###.# ##.##....#
##.####... .#.####.#. ..#.###..#
####.#.#.. ...#.##### ###.#..###
.#.####... ...##..##. .######.##
.##..##.#. ....#...## #.#.#.#...
....#..#.# #.#.#.##.# #.###.###.
..#.#..... .#.##.#..# #.###.##..
####.#.... .#..#.##.. .######...
...#.#.#.# ###.##.#.. .##...####

...#.#.#.# ###.##.#.. .##...####
..#.#.###. ..##.##.## #..#.##..#
..####.### ##.#...##. .#.#..#.##
#..#.#..#. ...#.#.#.. .####.###.
.#..####.# #..#.#.#.# ####.###..
.#####..## #####...#. .##....##.
##.##..#.. ..#...#... .####...#.
#.#.###... .##..##... .####.##.#
#...###... ..##...#.. ...#..####
..#.#....# ##.#.#.... ...##.....

#+end_src

For reference, the IDs of the above tiles are:

#+begin_src text
~1951~    2311    ~3079~
2729    1427    2473
~2971~    1489    ~1171~

#+end_src

To check that you've assembled the image correctly, multiply the IDs of the four corner tiles together. If you do this with the assembled tiles from the example above, you get 1951 * 3079 * 2971 * 1171 = ~20899048083289~.
Assemble the tiles into an image. ~What do you get if you multiply together the IDs of the four corner tiles?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-20 :var input_data=input-2020-20 :tangle /tmp/advent_of_code/aoc2020-20-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-20 :var input_data=input-2020-20 :tangle /tmp/advent_of_code/aoc2020-20-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-20 :var input_data=input-2020-20 :tangle /tmp/advent_of_code/aoc2020-20-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-20 :var input_data=input-2020-20 :tangle /tmp/advent_of_code/aoc2020-20-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-20 :var input_data=input-2020-20 :tangle /tmp/advent_of_code/aoc2020-20-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-20 :var input_data=input-2020-20 :tangle /tmp/advent_of_code/aoc2020-20-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-20 :var input_data=input-2020-20 :tangle /tmp/advent_of_code/aoc2020-20-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-20 :var input_data=input-2020-20 :tangle /tmp/advent_of_code/aoc2020-20-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-20 :var input_data=input-2020-20 :tangle /tmp/advent_of_code/aoc2020-20-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-20 :var input_data=input-2020-20 :tangle /tmp/advent_of_code/aoc2020-20-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-20 :var input_data=input-2020-20 :tangle /tmp/advent_of_code/aoc2020-20-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-20 :var input_data=input-2020-20 :tangle /tmp/advent_of_code/aoc2020-20-2.pl :results output 
#+end_src
*** Day 21: Allergen Assessment
**** Part 1
***** Description
You don't speak the local language, so you can't read any ingredients lists. However, sometimes, allergens are listed in a language you ~do~ understand. You should be able to use this information to determine which ingredient contains which allergen and <span title="I actually considered doing this once. I do not recommend it.">work out which foods are safe</span> to take with you on your trip.
You start by compiling a list of foods (your puzzle input), one food per line. Each line includes that food's ~ingredients list~ followed by some or all of the allergens the food contains.
Each allergen is found in exactly one ingredient. Each ingredient contains zero or one allergen. ~Allergens aren't always marked~; when they're listed (as in (contains nuts, shellfish) after an ingredients list), the ingredient that contains each listed allergen will be ~somewhere in the corresponding ingredients list~. However, even if an allergen isn't listed, the ingredient that contains that allergen could still be present: maybe they forgot to label it, or maybe it was labeled in a language you don't know.
For example, consider the following list of foods:

#+begin_src text
mxmxvkd kfcds sqjhc nhms (contains dairy, fish)
trh fvjkl sbzzf mxmxvkd (contains dairy)
sqjhc fvjkl (contains soy)
sqjhc mxmxvkd sbzzf (contains fish)

#+end_src

The first food in the list has four ingredients (written in a language you don't understand): mxmxvkd, kfcds, sqjhc, and nhms. While the food might contain other allergens, a few allergens the food definitely contains are listed afterward: dairy and fish.
The first step is to determine which ingredients ~can't possibly~ contain any of the allergens in any food in your list. In the above example, none of the ingredients kfcds, nhms, sbzzf, or trh can contain an allergen. Counting the number of times any of these ingredients appear in any ingredients list produces ~5~: they all appear once each except sbzzf, which appears twice.
Determine which ingredients cannot possibly contain any of the allergens in your list. ~How many times do any of those ingredients appear?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-21 :var input_data=input-2020-21 :tangle /tmp/advent_of_code/aoc2020-21-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-21 :var input_data=input-2020-21 :tangle /tmp/advent_of_code/aoc2020-21-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-21 :var input_data=input-2020-21 :tangle /tmp/advent_of_code/aoc2020-21-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-21 :var input_data=input-2020-21 :tangle /tmp/advent_of_code/aoc2020-21-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-21 :var input_data=input-2020-21 :tangle /tmp/advent_of_code/aoc2020-21-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-21 :var input_data=input-2020-21 :tangle /tmp/advent_of_code/aoc2020-21-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-21 :var input_data=input-2020-21 :tangle /tmp/advent_of_code/aoc2020-21-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-21 :var input_data=input-2020-21 :tangle /tmp/advent_of_code/aoc2020-21-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-21 :var input_data=input-2020-21 :tangle /tmp/advent_of_code/aoc2020-21-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-21 :var input_data=input-2020-21 :tangle /tmp/advent_of_code/aoc2020-21-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-21 :var input_data=input-2020-21 :tangle /tmp/advent_of_code/aoc2020-21-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-21 :var input_data=input-2020-21 :tangle /tmp/advent_of_code/aoc2020-21-2.pl :results output 
#+end_src
*** Day 22: Crab Combat
**** Part 1
***** Description
Fortunately, it doesn't take long to teach the crab the rules.
Before the game starts, split the cards so each player has their own deck (your puzzle input). Then, the game consists of a series of ~rounds~: both players draw their top card, and the player with the higher-valued card wins the round. The winner keeps both cards, placing them on the bottom of their own deck so that the winner's card is above the other card. If this causes a player to have all of the cards, they win, and the game ends.
For example, consider the following starting decks:

#+begin_src text
Player 1:
9
2
6
3
1

Player 2:
5
8
4
7
10

#+end_src

This arrangement means that player 1's deck contains 5 cards, with 9 on top and 1 on the bottom; player 2's deck also contains 5 cards, with 5 on top and 10 on the bottom.
The first round begins with both players drawing the top card of their decks: 9 and 5. Player 1 has the higher card, so both cards move to the bottom of player 1's deck such that 9 is above 5. In total, it takes 29 rounds before a player has all of the cards:

#+begin_src text
-- Round 1 --
Player 1's deck: 9, 2, 6, 3, 1
Player 2's deck: 5, 8, 4, 7, 10
Player 1 plays: 9
Player 2 plays: 5
Player 1 wins the round!

-- Round 2 --
Player 1's deck: 2, 6, 3, 1, 9, 5
Player 2's deck: 8, 4, 7, 10
Player 1 plays: 2
Player 2 plays: 8
Player 2 wins the round!

-- Round 3 --
Player 1's deck: 6, 3, 1, 9, 5
Player 2's deck: 4, 7, 10, 8, 2
Player 1 plays: 6
Player 2 plays: 4
Player 1 wins the round!

-- Round 4 --
Player 1's deck: 3, 1, 9, 5, 6, 4
Player 2's deck: 7, 10, 8, 2
Player 1 plays: 3
Player 2 plays: 7
Player 2 wins the round!

-- Round 5 --
Player 1's deck: 1, 9, 5, 6, 4
Player 2's deck: 10, 8, 2, 7, 3
Player 1 plays: 1
Player 2 plays: 10
Player 2 wins the round!

...several more rounds pass...

-- Round 27 --
Player 1's deck: 5, 4, 1
Player 2's deck: 8, 9, 7, 3, 2, 10, 6
Player 1 plays: 5
Player 2 plays: 8
Player 2 wins the round!

-- Round 28 --
Player 1's deck: 4, 1
Player 2's deck: 9, 7, 3, 2, 10, 6, 8, 5
Player 1 plays: 4
Player 2 plays: 9
Player 2 wins the round!

-- Round 29 --
Player 1's deck: 1
Player 2's deck: 7, 3, 2, 10, 6, 8, 5, 9, 4
Player 1 plays: 1
Player 2 plays: 7
Player 2 wins the round!


== Post-game results ==
Player 1's deck: 
Player 2's deck: 3, 2, 10, 6, 8, 5, 9, 4, 7, 1

#+end_src

Once the game ends, you can calculate the winning player's ~score~. The bottom card in their deck is worth the value of the card multiplied by 1, the second-from-the-bottom card is worth the value of the card multiplied by 2, and so on. With 10 cards, the top card is worth the value on the card multiplied by 10. In this example, the winning player's score is:

#+begin_src text
   3 * 10
+  2 *  9
+ 10 *  8
+  6 *  7
+  8 *  6
+  5 *  5
+  9 *  4
+  4 *  3
+  7 *  2
+  1 *  1
= 306

#+end_src

So, once the game ends, the winning player's score is ~306~.
Play the small crab in a game of Combat using the two decks you just dealt. ~What is the winning player's score?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-22 :var input_data=input-2020-22 :tangle /tmp/advent_of_code/aoc2020-22-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-22 :var input_data=input-2020-22 :tangle /tmp/advent_of_code/aoc2020-22-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-22 :var input_data=input-2020-22 :tangle /tmp/advent_of_code/aoc2020-22-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-22 :var input_data=input-2020-22 :tangle /tmp/advent_of_code/aoc2020-22-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-22 :var input_data=input-2020-22 :tangle /tmp/advent_of_code/aoc2020-22-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-22 :var input_data=input-2020-22 :tangle /tmp/advent_of_code/aoc2020-22-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-22 :var input_data=input-2020-22 :tangle /tmp/advent_of_code/aoc2020-22-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-22 :var input_data=input-2020-22 :tangle /tmp/advent_of_code/aoc2020-22-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-22 :var input_data=input-2020-22 :tangle /tmp/advent_of_code/aoc2020-22-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-22 :var input_data=input-2020-22 :tangle /tmp/advent_of_code/aoc2020-22-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-22 :var input_data=input-2020-22 :tangle /tmp/advent_of_code/aoc2020-22-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-22 :var input_data=input-2020-22 :tangle /tmp/advent_of_code/aoc2020-22-2.pl :results output 
#+end_src
*** Day 23: Crab Cups
**** Part 1
***** Description
The cups will be arranged in a circle and labeled ~clockwise~ (your puzzle input). For example, if your labeling were 32415, there would be five cups in the circle; going clockwise around the circle from the first cup, the cups would be labeled 3, 2, 4, 1, 5, and then back to 3 again.
Before the crab starts, it will designate the first cup in your list as the ~current cup~. The crab is then going to do ~100 moves~.
Each ~move~, the crab does the following actions:

~The crab picks up the ~three cups~ that are immediately ~clockwise~ of the ~current cup~. They are removed from the circle; cup spacing is adjusted as necessary to maintain the circle.~
~The crab selects a ~destination cup~: the cup with a ~label~ equal to the ~current cup's~ label minus one. If this would select one of the cups that was just picked up, the crab will keep subtracting one until it finds a cup that wasn't just picked up. If at any point in this process the value goes below the lowest value on any cup's label, it ~wraps around~ to the highest value on any cup's label instead.~
~The crab places the cups it just picked up so that they are ~immediately clockwise~ of the destination cup. They keep the same order as when they were picked up.~
~The crab selects a new ~current cup~: the cup which is immediately clockwise of the current cup.~

For example, suppose your cup labeling were 389125467. If the crab were to do merely 10 moves, the following changes would occur:

#+begin_src text
-- move 1 --
cups: (3) 8  9  1  2  5  4  6  7 
pick up: 8, 9, 1
destination: 2

-- move 2 --
cups:  3 (2) 8  9  1  5  4  6  7 
pick up: 8, 9, 1
destination: 7

-- move 3 --
cups:  3  2 (5) 4  6  7  8  9  1 
pick up: 4, 6, 7
destination: 3

-- move 4 --
cups:  7  2  5 (8) 9  1  3  4  6 
pick up: 9, 1, 3
destination: 7

-- move 5 --
cups:  3  2  5  8 (4) 6  7  9  1 
pick up: 6, 7, 9
destination: 3

-- move 6 --
cups:  9  2  5  8  4 (1) 3  6  7 
pick up: 3, 6, 7
destination: 9

-- move 7 --
cups:  7  2  5  8  4  1 (9) 3  6 
pick up: 3, 6, 7
destination: 8

-- move 8 --
cups:  8  3  6  7  4  1  9 (2) 5 
pick up: 5, 8, 3
destination: 1

-- move 9 --
cups:  7  4  1  5  8  3  9  2 (6)
pick up: 7, 4, 1
destination: 5

-- move 10 --
cups: (5) 7  4  1  8  3  9  2  6 
pick up: 7, 4, 1
destination: 3

-- final --
cups:  5 (8) 3  7  4  1  9  2  6 

#+end_src

In the above example, the cups' values are the labels as they appear moving clockwise around the circle; the ~current cup~ is marked with ( ).
After the crab is done, what order will the cups be in? Starting ~after the cup labeled 1~, collect the other cups' labels clockwise into a single string with no extra characters; each number except 1 should appear exactly once. In the above example, after 10 moves, the cups clockwise from 1 are labeled 9, 2, 6, 5, and so on, producing ~92658374~. If the crab were to complete all 100 moves, the order after cup 1 would be ~67384529~.
Using your labeling, simulate 100 moves. ~What are the labels on the cups after cup 1?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-23 :var input_data=input-2020-23 :tangle /tmp/advent_of_code/aoc2020-23-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-23 :var input_data=input-2020-23 :tangle /tmp/advent_of_code/aoc2020-23-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-23 :var input_data=input-2020-23 :tangle /tmp/advent_of_code/aoc2020-23-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-23 :var input_data=input-2020-23 :tangle /tmp/advent_of_code/aoc2020-23-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-23 :var input_data=input-2020-23 :tangle /tmp/advent_of_code/aoc2020-23-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-23 :var input_data=input-2020-23 :tangle /tmp/advent_of_code/aoc2020-23-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-23 :var input_data=input-2020-23 :tangle /tmp/advent_of_code/aoc2020-23-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-23 :var input_data=input-2020-23 :tangle /tmp/advent_of_code/aoc2020-23-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-23 :var input_data=input-2020-23 :tangle /tmp/advent_of_code/aoc2020-23-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-23 :var input_data=input-2020-23 :tangle /tmp/advent_of_code/aoc2020-23-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-23 :var input_data=input-2020-23 :tangle /tmp/advent_of_code/aoc2020-23-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-23 :var input_data=input-2020-23 :tangle /tmp/advent_of_code/aoc2020-23-2.pl :results output 
#+end_src
*** Day 24: Lobby Layout
**** Part 1
***** Description
As you enter the lobby, you discover a small problem: the floor is being renovated. You can't even reach the check-in desk until they've finished installing the ~new tile floor~.
The tiles are all ~hexagonal~; they need to be arranged in a <a href="https://en.wikipedia.org/wiki/Hexagonal_tiling">hex grid</a> with a very specific color pattern. Not in the mood to wait, you offer to help figure out the pattern.
The tiles are all ~white~ on one side and ~black~ on the other. They start with the white side facing up. The lobby is large enough to fit whatever pattern might need to appear there.
A member of the renovation crew gives you a ~list of the tiles that need to be flipped over~ (your puzzle input). Each line in the list identifies a single tile that needs to be flipped by giving a series of steps starting from a ~reference tile~ in the very center of the room. (Every line starts from the same reference tile.)
Because the tiles are hexagonal, every tile has ~six neighbors~: east, southeast, southwest, west, northwest, and northeast. These directions are given in your list, respectively, as e, se, sw, w, nw, and ne. A tile is identified by a series of these directions with ~no delimiters~; for example, esenee identifies the tile you land on if you start at the reference tile and then move one tile east, one tile southeast, one tile northeast, and one tile east.
Each time a tile is identified, it flips from white to black or from black to white. Tiles might be flipped more than once. For example, a line like esew flips a tile immediately adjacent to the reference tile, and a line like nwwswee flips the reference tile itself.
Here is a larger example:

#+begin_src text
sesenwnenenewseeswwswswwnenewsewsw
neeenesenwnwwswnenewnwwsewnenwseswesw
seswneswswsenwwnwse
nwnwneseeswswnenewneswwnewseswneseene
swweswneswnenwsewnwneneseenw
eesenwseswswnenwswnwnwsewwnwsene
sewnenenenesenwsewnenwwwse
wenwwweseeeweswwwnwwe
wsweesenenewnwwnwsenewsenwwsesesenwne
neeswseenwwswnwswswnw
nenwswwsewswnenenewsenwsenwnesesenew
enewnwewneswsewnwswenweswnenwsenwsw
sweneswneswneneenwnewenewwneswswnese
swwesenesewenwneswnwwneseswwne
enesenwswwswneneswsenwnewswseenwsese
wnwnesenesenenwwnenwsewesewsesesew
nenewswnwewswnenesenwnesewesw
eneswnwswnwsenenwnwnwwseeswneewsenese
neswnwewnwnwseenwseesewsenwsweewe
wseweeenwnesenwwwswnew

#+end_src

In the above example, 10 tiles are flipped once (to black), and 5 more are flipped twice (to black, then back to white). After all of these instructions have been followed, a total of ~10~ tiles are ~black~.
Go through the renovation crew's list and determine which tiles they need to flip. After all of the instructions have been followed, ~how many tiles are left with the black side up?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-24 :var input_data=input-2020-24 :tangle /tmp/advent_of_code/aoc2020-24-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-24 :var input_data=input-2020-24 :tangle /tmp/advent_of_code/aoc2020-24-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-24 :var input_data=input-2020-24 :tangle /tmp/advent_of_code/aoc2020-24-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-24 :var input_data=input-2020-24 :tangle /tmp/advent_of_code/aoc2020-24-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-24 :var input_data=input-2020-24 :tangle /tmp/advent_of_code/aoc2020-24-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-24 :var input_data=input-2020-24 :tangle /tmp/advent_of_code/aoc2020-24-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-24 :var input_data=input-2020-24 :tangle /tmp/advent_of_code/aoc2020-24-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-24 :var input_data=input-2020-24 :tangle /tmp/advent_of_code/aoc2020-24-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-24 :var input_data=input-2020-24 :tangle /tmp/advent_of_code/aoc2020-24-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-24 :var input_data=input-2020-24 :tangle /tmp/advent_of_code/aoc2020-24-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-24 :var input_data=input-2020-24 :tangle /tmp/advent_of_code/aoc2020-24-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-24 :var input_data=input-2020-24 :tangle /tmp/advent_of_code/aoc2020-24-2.pl :results output 
#+end_src
*** Day 25: Combo Breaker
**** Part 1
***** Description
The room key is a small <a href="https://en.wikipedia.org/wiki/Radio-frequency_identification" target="_blank">RFID</a> card. Your room is on the 25th floor and the elevators are also temporarily out of service, so it takes what little energy you have left to even climb the stairs and navigate the halls. You finally reach the door to your room, swipe your card, and - ~beep~ - the light turns red.
Examining the card more closely, you discover a phone number for tech support.
"Hello! How can we help you today?" You explain the situation.
"Well, it sounds like the card isn't sending the right command to unlock the door. If you go back to the check-in desk, surely someone there can reset it for you." Still catching your breath, you describe the status of the elevator and the exact number of stairs you just had to climb.
"I see! Well, your only other option would be to reverse-engineer the cryptographic handshake the card does with the door and then inject your own commands into the data stream, but that's definitely impossible." You thank them for their time.
Unfortunately for the door, you know a thing or two about cryptographic handshakes.
The handshake used by the card and the door involves an operation that ~transforms~ a ~subject number~. To transform a subject number, start with the value 1. Then, a number of times called the ~loop size~, perform the following steps:

~Set the value to itself multiplied by the ~subject number~.~
~Set the value to the remainder after dividing the value by ~20201227~.~

The card always uses a specific, secret ~loop size~ when it transforms a subject number. The door always uses a different, secret loop size.
The cryptographic handshake works like this:

~The ~card~ transforms the subject number of ~7~ according to the ~card's~ secret loop size. The result is called the ~card's public key~.~
~The ~door~ transforms the subject number of ~7~ according to the ~door's~ secret loop size. The result is called the ~door's public key~.~
~The card and door use the wireless RFID signal to transmit the two public keys (your puzzle input) to the other device. Now, the ~card~ has the ~door's~ public key, and the ~door~ has the ~card's~ public key. Because you can eavesdrop on the signal, you have both public keys, but neither device's loop size.~
~The ~card~ transforms the subject number of ~the door's public key~ according to the ~card's~ loop size. The result is the ~encryption key~.~
~The ~door~ transforms the subject number of ~the card's public key~ according to the ~door's~ loop size. The result is the same ~encryption key~ as the ~card~ calculated.~

If you can use the two public keys to determine each device's loop size, you will have enough information to calculate the secret ~encryption key~ that the card and door use to communicate; this would let you send the unlock command directly to the door!
For example, suppose you know that the card's public key is 5764801. With a little trial and error, you can work out that the card's loop size must be ~8~, because transforming the initial subject number of 7 with a loop size of 8 produces 5764801.
Then, suppose you know that the door's public key is 17807724. By the same process, you can determine that the door's loop size is ~11~, because transforming the initial subject number of 7 with a loop size of 11 produces 17807724.
At this point, you can use either device's loop size with the other device's public key to calculate the ~encryption key~. Transforming the subject number of 17807724 (the door's public key) with a loop size of 8 (the card's loop size) produces the encryption key, ~14897079~. (Transforming the subject number of 5764801 (the card's public key) with a loop size of 11 (the door's loop size) produces the same encryption key: ~14897079~.)
~What encryption key is the handshake trying to establish?~
 
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-25 :var input_data=input-2020-25 :tangle /tmp/advent_of_code/aoc2020-25-1.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-25 :var input_data=input-2020-25 :tangle /tmp/advent_of_code/aoc2020-25-1.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-25 :var input_data=input-2020-25 :tangle /tmp/advent_of_code/aoc2020-25-1.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-25 :var input_data=input-2020-25 :tangle /tmp/advent_of_code/aoc2020-25-1.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-25 :var input_data=input-2020-25 :tangle /tmp/advent_of_code/aoc2020-25-1.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-25 :var input_data=input-2020-25 :tangle /tmp/advent_of_code/aoc2020-25-1.pl :results output 
#+end_src
**** Part 2
***** Description
Complete part 1 before continuing
***** TODO Racket
#+begin_src racket :var sample_data=sample-2020-25 :var input_data=input-2020-25 :tangle /tmp/advent_of_code/aoc2020-25-2.rkt :results output 
#+end_src
***** TODO Python
#+begin_src python :var sample_data=sample-2020-25 :var input_data=input-2020-25 :tangle /tmp/advent_of_code/aoc2020-25-2.py :results output 
#+end_src
***** TODO Rust
#+begin_src rust :var sample_data=sample-2020-25 :var input_data=input-2020-25 :tangle /tmp/advent_of_code/aoc2020-25-2.rs :results output 
#+end_src
***** TODO Bash
#+begin_src bash :var sample_data=sample-2020-25 :var input_data=input-2020-25 :tangle /tmp/advent_of_code/aoc2020-25-2.sh :results output 
#+end_src
***** TODO Awk
#+begin_src awk :var sample_data=sample-2020-25 :var input_data=input-2020-25 :tangle /tmp/advent_of_code/aoc2020-25-2.awk :results output 
#+end_src
***** TODO Perl
#+begin_src perl :var sample_data=sample-2020-25 :var input_data=input-2020-25 :tangle /tmp/advent_of_code/aoc2020-25-2.pl :results output 
#+end_src
* Inputs
** 2015
*** Day 01: Not Quite Lisp
**** Sample
#+NAME: sample-2015-01
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-01
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 02: I Was Told There Would Be No Math
**** Sample
#+NAME: sample-2015-02
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-02
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 03: Perfectly Spherical Houses in a Vacuum
**** Sample
#+NAME: sample-2015-03
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-03
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 04: The Ideal Stocking Stuffer
**** Sample
#+NAME: sample-2015-04
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-04
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 05: Doesn't He Have Intern-Elves For This?
**** Sample
#+NAME: sample-2015-05
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-05
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 06: Probably a Fire Hazard
**** Sample
#+NAME: sample-2015-06
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-06
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 07: Some Assembly Required
**** Sample
#+NAME: sample-2015-07
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-07
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 08: Matchsticks
**** Sample
#+NAME: sample-2015-08
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-08
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 09: All in a Single Night
**** Sample
#+NAME: sample-2015-09
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-09
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 10: Elves Look, Elves Say
**** Sample
#+NAME: sample-2015-10
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-10
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 11: Corporate Policy
**** Sample
#+NAME: sample-2015-11
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-11
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 12: JSAbacusFramework.io
**** Sample
#+NAME: sample-2015-12
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-12
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 13: Knights of the Dinner Table
**** Sample
#+NAME: sample-2015-13
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-13
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 14: Reindeer Olympics
**** Sample
#+NAME: sample-2015-14
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-14
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 15: Science for Hungry People
**** Sample
#+NAME: sample-2015-15
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-15
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 16: Aunt Sue
**** Sample
#+NAME: sample-2015-16
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-16
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 17: No Such Thing as Too Much
**** Sample
#+NAME: sample-2015-17
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-17
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 18: Like a GIF For Your Yard
**** Sample
#+NAME: sample-2015-18
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-18
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 19: Medicine for Rudolph
**** Sample
#+NAME: sample-2015-19
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-19
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 20: Infinite Elves and Infinite Houses
**** Sample
#+NAME: sample-2015-20
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-20
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 21: RPG Simulator 20XX
**** Sample
#+NAME: sample-2015-21
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-21
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 22: Wizard Simulator 20XX
**** Sample
#+NAME: sample-2015-22
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-22
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 23: Opening the Turing Lock
**** Sample
#+NAME: sample-2015-23
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-23
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 24: It Hangs in the Balance
**** Sample
#+NAME: sample-2015-24
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-24
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 25: Let It Snow
**** Sample
#+NAME: sample-2015-25
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2015-25
#+begin_src bash :results output :cache yes
echo ""
#+end_src

** 2016
*** Day 01: No Time for a Taxicab
**** Sample
#+NAME: sample-2016-01
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-01
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 02: Bathroom Security
**** Sample
#+NAME: sample-2016-02
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-02
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 03: Squares With Three Sides
**** Sample
#+NAME: sample-2016-03
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-03
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 04: Security Through Obscurity
**** Sample
#+NAME: sample-2016-04
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-04
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 05: How About a Nice Game of Chess?
**** Sample
#+NAME: sample-2016-05
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-05
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 06: Signals and Noise
**** Sample
#+NAME: sample-2016-06
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-06
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 07: Internet Protocol Version 7
**** Sample
#+NAME: sample-2016-07
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-07
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 08: Two-Factor Authentication
**** Sample
#+NAME: sample-2016-08
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-08
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 09: Explosives in Cyberspace
**** Sample
#+NAME: sample-2016-09
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-09
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 10: Balance Bots
**** Sample
#+NAME: sample-2016-10
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-10
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 11: Radioisotope Thermoelectric Generators
**** Sample
#+NAME: sample-2016-11
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-11
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 12: Leonardo's Monorail
**** Sample
#+NAME: sample-2016-12
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-12
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 13: A Maze of Twisty Little Cubicles
**** Sample
#+NAME: sample-2016-13
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-13
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 14: One-Time Pad
**** Sample
#+NAME: sample-2016-14
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-14
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 15: Timing is Everything
**** Sample
#+NAME: sample-2016-15
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-15
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 16: Dragon Checksum
**** Sample
#+NAME: sample-2016-16
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-16
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 17: Two Steps Forward
**** Sample
#+NAME: sample-2016-17
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-17
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 18: Like a Rogue
**** Sample
#+NAME: sample-2016-18
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-18
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 19: An Elephant Named Joseph
**** Sample
#+NAME: sample-2016-19
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-19
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 20: Firewall Rules
**** Sample
#+NAME: sample-2016-20
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-20
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 21: Scrambled Letters and Hash
**** Sample
#+NAME: sample-2016-21
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-21
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 22: Grid Computing
**** Sample
#+NAME: sample-2016-22
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-22
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 23: Safe Cracking
**** Sample
#+NAME: sample-2016-23
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-23
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 24: Air Duct Spelunking
**** Sample
#+NAME: sample-2016-24
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-24
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 25: Clock Signal
**** Sample
#+NAME: sample-2016-25
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2016-25
#+begin_src bash :results output :cache yes
echo ""
#+end_src

** 2017
*** Day 01: Inverse Captcha
**** Sample
#+NAME: sample-2017-01
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-01
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 02: Corruption Checksum
**** Sample
#+NAME: sample-2017-02
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-02
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 03: Spiral Memory
**** Sample
#+NAME: sample-2017-03
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-03
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 04: High-Entropy Passphrases
**** Sample
#+NAME: sample-2017-04
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-04
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 05: A Maze of Twisty Trampolines, All Alike
**** Sample
#+NAME: sample-2017-05
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-05
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 06: Memory Reallocation
**** Sample
#+NAME: sample-2017-06
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-06
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 07: Recursive Circus
**** Sample
#+NAME: sample-2017-07
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-07
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 08: I Heard You Like Registers
**** Sample
#+NAME: sample-2017-08
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-08
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 09: Stream Processing
**** Sample
#+NAME: sample-2017-09
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-09
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 10: Knot Hash
**** Sample
#+NAME: sample-2017-10
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-10
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 11: Hex Ed
**** Sample
#+NAME: sample-2017-11
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-11
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 12: Digital Plumber
**** Sample
#+NAME: sample-2017-12
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-12
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 13: Packet Scanners
**** Sample
#+NAME: sample-2017-13
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-13
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 14: Disk Defragmentation
**** Sample
#+NAME: sample-2017-14
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-14
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 15: Dueling Generators
**** Sample
#+NAME: sample-2017-15
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-15
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 16: Permutation Promenade
**** Sample
#+NAME: sample-2017-16
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-16
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 17: Spinlock
**** Sample
#+NAME: sample-2017-17
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-17
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 18: Duet
**** Sample
#+NAME: sample-2017-18
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-18
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 19: A Series of Tubes
**** Sample
#+NAME: sample-2017-19
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-19
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 20: Particle Swarm
**** Sample
#+NAME: sample-2017-20
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-20
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 21: Fractal Art
**** Sample
#+NAME: sample-2017-21
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-21
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 22: Sporifica Virus
**** Sample
#+NAME: sample-2017-22
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-22
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 23: Coprocessor Conflagration
**** Sample
#+NAME: sample-2017-23
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-23
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 24: Electromagnetic Moat
**** Sample
#+NAME: sample-2017-24
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-24
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 25: The Halting Problem
**** Sample
#+NAME: sample-2017-25
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2017-25
#+begin_src bash :results output :cache yes
echo ""
#+end_src

** 2018
*** Day 01: Chronal Calibration
**** Sample
#+NAME: sample-2018-01
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-01
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 02: Inventory Management System
**** Sample
#+NAME: sample-2018-02
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-02
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 03: No Matter How You Slice It
**** Sample
#+NAME: sample-2018-03
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-03
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 04: Repose Record
**** Sample
#+NAME: sample-2018-04
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-04
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 05: Alchemical Reduction
**** Sample
#+NAME: sample-2018-05
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-05
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 06: Chronal Coordinates
**** Sample
#+NAME: sample-2018-06
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-06
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 07: The Sum of Its Parts
**** Sample
#+NAME: sample-2018-07
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-07
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 08: Memory Maneuver
**** Sample
#+NAME: sample-2018-08
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-08
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 09: Marble Mania
**** Sample
#+NAME: sample-2018-09
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-09
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 10: The Stars Align
**** Sample
#+NAME: sample-2018-10
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-10
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 11: Chronal Charge
**** Sample
#+NAME: sample-2018-11
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-11
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 12: Subterranean Sustainability
**** Sample
#+NAME: sample-2018-12
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-12
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 13: Mine Cart Madness
**** Sample
#+NAME: sample-2018-13
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-13
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 14: Chocolate Charts
**** Sample
#+NAME: sample-2018-14
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-14
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 15: Beverage Bandits
**** Sample
#+NAME: sample-2018-15
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-15
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 16: Chronal Classification
**** Sample
#+NAME: sample-2018-16
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-16
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 17: Reservoir Research
**** Sample
#+NAME: sample-2018-17
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-17
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 18: Settlers of The North Pole
**** Sample
#+NAME: sample-2018-18
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-18
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 19: Go With The Flow
**** Sample
#+NAME: sample-2018-19
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-19
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 20: A Regular Map
**** Sample
#+NAME: sample-2018-20
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-20
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 21: Chronal Conversion
**** Sample
#+NAME: sample-2018-21
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-21
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 22: Mode Maze
**** Sample
#+NAME: sample-2018-22
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-22
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 23: Experimental Emergency Teleportation
**** Sample
#+NAME: sample-2018-23
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-23
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 24: Immune System Simulator 20XX
**** Sample
#+NAME: sample-2018-24
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-24
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 25: Four-Dimensional Adventure
**** Sample
#+NAME: sample-2018-25
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2018-25
#+begin_src bash :results output :cache yes
echo ""
#+end_src

** 2019
*** Day 01: The Tyranny of the Rocket Equation
**** Sample
#+NAME: sample-2019-01
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-01
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 02: 1202 Program Alarm
**** Sample
#+NAME: sample-2019-02
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-02
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 03: Crossed Wires
**** Sample
#+NAME: sample-2019-03
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-03
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 04: Secure Container
**** Sample
#+NAME: sample-2019-04
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-04
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 05: Sunny with a Chance of Asteroids
**** Sample
#+NAME: sample-2019-05
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-05
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 06: Universal Orbit Map
**** Sample
#+NAME: sample-2019-06
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-06
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 07: Amplification Circuit
**** Sample
#+NAME: sample-2019-07
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-07
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 08: Space Image Format
**** Sample
#+NAME: sample-2019-08
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-08
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 09: Sensor Boost
**** Sample
#+NAME: sample-2019-09
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-09
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 10: Monitoring Station
**** Sample
#+NAME: sample-2019-10
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-10
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 11: Space Police
**** Sample
#+NAME: sample-2019-11
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-11
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 12: The N-Body Problem
**** Sample
#+NAME: sample-2019-12
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-12
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 13: Care Package
**** Sample
#+NAME: sample-2019-13
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-13
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 14: Space Stoichiometry
**** Sample
#+NAME: sample-2019-14
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-14
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 15: Oxygen System
**** Sample
#+NAME: sample-2019-15
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-15
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 16: Flawed Frequency Transmission
**** Sample
#+NAME: sample-2019-16
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-16
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 17: Set and Forget
**** Sample
#+NAME: sample-2019-17
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-17
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 18: Many-Worlds Interpretation
**** Sample
#+NAME: sample-2019-18
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-18
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 19: Tractor Beam
**** Sample
#+NAME: sample-2019-19
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-19
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 20: Donut Maze
**** Sample
#+NAME: sample-2019-20
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-20
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 21: Springdroid Adventure
**** Sample
#+NAME: sample-2019-21
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-21
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 22: Slam Shuffle
**** Sample
#+NAME: sample-2019-22
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-22
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 23: Category Six
**** Sample
#+NAME: sample-2019-23
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-23
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 24: Planet of Discord
**** Sample
#+NAME: sample-2019-24
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-24
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 25: Cryostasis
**** Sample
#+NAME: sample-2019-25
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2019-25
#+begin_src bash :results output :cache yes
echo ""
#+end_src

** 2020
*** Day 01: Report Repair
**** Sample
#+NAME: sample-2020-01
#+begin_src bash :results output :cache yes
echo "1721 979 366 299 675 1456"
#+end_src

#+RESULTS[02c64a7fd029b24bf7c8b7875b996f2ab3eb8896]: sample-2020-01
: 1721 979 366 299 675 1456

**** Input
#+NAME: input-2020-01
#+begin_src bash :results output :cache yes
echo "1786 571 1689 1853 1817 1549 1079 1755 1973 1453 1139 1576 1928 1634 1961 1995 1272 1839 1976 1664 1956 1933 1981 1665 1057 1798 1485 2004 1990 2002 82 1922 1544 201 1730 1607 1597 1098 1490 1955 1194 1733 1245 1761 1709 1143 1828 1450 1569 1997 1943 1555 1958 1176 1858 1937 1560 1979 1962 1658 1959 2007 1636 1460 348 1084 1952 1162 1772 701 1462 1680 1639 1625 1060 1600 1631 1638 1350 1675 1366 1244 1413 994 1533 1199 1653 1902 1340 1819 1676 1081 1953 1993 1652 1214 1815 1977 1939 2000 1879 1948 1982 1983 1247 1969 1149 1682 1456 2001 1674 1531 1464 1243 1511 1867 1479 1873 1136 1087 1651 1855 1122 1505 1974 1692 1992 1361 1666 1100 1193 1978 1529 1903 1510 1152 1514 1591 1753 1744 1985 1459 1954 1579 1307 1975 1934 1589 971 1603 1980 1942 1160 1986 1963 1921 1481 1736 1616 1968 1201 1489 1781 1021 1452 1570 1326 1831 2006 1541 1690 1877 1447 1988 1411 1535 1799 1587 1255 1611 1419 1947 1626 132 1946 1950 1487 1496 1949 1155 1628 1738 2010 1446 1466 1630 1784 1989 1458 1741"
#+end_src

#+RESULTS[9f86d26f49eedccc98e76c9287a30e536baed504]: input-2020-01
: 1786 571 1689 1853 1817 1549 1079 1755 1973 1453 1139 1576 1928 1634 1961 1995 1272 1839 1976 1664 1956 1933 1981 1665 1057 1798 1485 2004 1990 2002 82 1922 1544 201 1730 1607 1597 1098 1490 1955 1194 1733 1245 1761 1709 1143 1828 1450 1569 1997 1943 1555 1958 1176 1858 1937 1560 1979 1962 1658 1959 2007 1636 1460 348 1084 1952 1162 1772 701 1462 1680 1639 1625 1060 1600 1631 1638 1350 1675 1366 1244 1413 994 1533 1199 1653 1902 1340 1819 1676 1081 1953 1993 1652 1214 1815 1977 1939 2000 1879 1948 1982 1983 1247 1969 1149 1682 1456 2001 1674 1531 1464 1243 1511 1867 1479 1873 1136 1087 1651 1855 1122 1505 1974 1692 1992 1361 1666 1100 1193 1978 1529 1903 1510 1152 1514 1591 1753 1744 1985 1459 1954 1579 1307 1975 1934 1589 971 1603 1980 1942 1160 1986 1963 1921 1481 1736 1616 1968 1201 1489 1781 1021 1452 1570 1326 1831 2006 1541 1690 1877 1447 1988 1411 1535 1799 1587 1255 1611 1419 1947 1626 132 1946 1950 1487 1496 1949 1155 1628 1738 2010 1446 1466 1630 1784 1989 1458 1741

*** Day 02: Password Philosophy
**** Sample
#+NAME: sample-2020-02
#+begin_src bash :results output :cache yes
echo "1-3 a: abcde
1-3 b: cdefg
2-9 c: ccccccccc"
#+end_src

#+RESULTS[db4e29c429421df265fd35297b9bb1649b7df71b]: sample-2020-02
: 1-3 a: abcde
: 1-3 b: cdefg
: 2-9 c: ccccccccc

**** Input
#+NAME: input-2020-02
#+begin_src bash :results output :cache yes
echo "15-16 m: mhmjmzrmmlmmmmmm
5-6 d: dcdddhzld
3-4 s: vqssdcbl
3-6 b: bbhbbbqbbb
10-11 q: cqqntqhqwwh
4-7 g: ggkgggw
4-7 f: fdfffflfvn
11-16 h: thhrhrwhbshshsdhhhhr
7-12 n: nnnnnnvnnnnn
4-5 f: ffxfhldh
9-17 m: mmmmmmmmjmmmmmmmw
2-5 h: hqrfzhhh
4-7 x: vxxfxxjxwvnlx
11-13 h: dhhhhhhhdhhhrh
4-8 q: qqphvphfrlqqkztgslzb
3-15 x: htblqcbdxdzgvhszxz
4-5 j: jjhnn
3-6 l: bwkjllgcjrzhr
5-8 s: ssmsspsss
1-15 d: ddhmhmvlkppkbbdxbc
7-8 l: ltllllllhgzlv
1-15 m: mtmmmvmmbmmfmmkmmmm
1-3 x: xrxzcxcx
5-6 t: tttttdtv
2-5 x: xxxxs
5-7 l: gclqlml
5-10 g: gggggggggn
6-9 j: xwjjfngjgjsjsr
2-7 b: hbqtchkcmblppvqp
16-17 j: jjjjjjjjjjjjjjmjjj
1-5 p: wpppdlpphppp
3-7 q: mspqqqqq
1-4 k: hkjk
3-6 l: llbllldzf
11-14 x: xxnxvxxxxlxxxkv
4-7 k: zkkksmjmrzxftx
2-4 l: lllwq
7-11 q: tbqqmmvkrsz
3-4 f: gwfs
3-5 z: ztszz
2-4 k: kkpzl
1-2 k: kkwckkzwskgbdc
5-7 x: mxxxdxf
1-3 p: pppp
6-8 c: rcqrmcqmpcc
5-6 s: srgvwsc
5-6 w: wwwwwww
2-6 w: xwwzfwr
1-8 z: djzzzcmz
10-14 b: dbwbbbbbldtbbbrbbq
5-15 v: wvzftvfvzkcvjdvvzcj
4-5 j: lrjdmjj
1-15 q: qqqqqqqqqqqqqqkqqq
1-2 w: vwkw
2-4 c: lccsfmkrnrldzbrc
5-14 r: rcpghlsspmvwvzmpvl
7-9 n: nnnnnnnnx
2-19 w: wwwwwwwwwwwwwwwhwbww
6-7 r: rrrrrzc
3-15 w: mnxmfqgklqddfww
9-13 s: tsslqtsszsqsssqssss
5-6 j: jjjtjrb
8-9 f: fffffffwfff
5-7 n: nnnnnnhn
8-17 d: dnfdqvwngbddvbndbsf
13-14 v: vvvvvvvvtvvvvt
2-3 h: hsbnhhhs
2-4 g: ggcgm
2-7 r: rvrrrrrvr
6-9 n: qpxchngsbhxrgqdgbqs
4-8 k: kkkkkkkkd
1-6 v: mrvlldzv
7-10 w: vvwkwrbnwczwww
10-14 k: kkkknkkkkpkkkdmkh
9-10 s: qqbwmssnssjs
5-6 z: bzvdjz
6-13 j: jjjjrzbrjzjmjzjsk
1-6 k: kkkkkrsskk
8-10 v: vvvvvvwvvzvb
10-12 m: mmmmmmmmmdmm
9-10 k: kkkkkkkkjkk
2-8 b: pbcsbbprc
6-7 x: xxxxnpxxxk
3-7 l: llllllml
4-10 j: jrjzjjjcjx
4-5 g: gggmgg
14-15 n: nnnndnnxnnnnntnn
4-6 h: hzqpgbhwh
4-6 b: plzbkbrpscqbxl
5-13 m: hptczmkkmplmw
7-8 r: vjhrhrkdrrrk
3-4 q: qqqq
11-13 s: sssnssssssmsss
11-13 x: xxbhkwvvxgxjh
1-2 f: ftlrdz
1-3 d: mdslnl
2-10 r: xrzbqcxlvtlrsznplk
8-10 w: wwwwmwwtww
2-10 r: zbzplcvnvrr
5-16 c: lcccccclcccgcccccc
3-7 w: wwpwwbww
1-4 s: svsss
6-8 j: jjllkwnjjjgcjpg
3-5 c: cccbb
1-14 j: jpkjjqjjgqmzbjjhjljj
4-9 w: dwwlwwdmkww
7-8 p: pppppppjhqp
1-14 d: djmfmdddkhfqdzfdddd
2-3 r: zrbjhpg
3-4 j: jjkj
3-4 q: qqqq
1-5 k: kkkkwk
6-13 t: ttzxtjtdjtmtttmtt
1-3 x: jxvx
11-12 f: fffffffffffkffffffff
4-5 l: lllhlm
8-10 n: hnnnnnkdfrnntdhnk
1-2 x: gxxx
8-12 w: pwwwwwwfwwww
1-19 p: ppnxfswpxfpbfcpnnpq
10-11 h: hhhphhhhhhgv
1-10 c: dccbvcccccc
7-12 v: vvvvvvrvdvvvvvvvvvvl
2-11 b: jbncfdbbbbcb
3-4 n: nnrn
3-12 s: btnfjtszszssdrsd
3-7 b: bznkfbb
5-6 r: rhprrhrrrhnzjhr
6-18 n: xznnnwwmwnvfnfnlhn
6-11 v: smsvpcjvvgvtvkmvv
12-14 s: sssssssssssssc
5-6 t: ttttfx
7-9 p: pppppnvppp
4-11 s: fbvfqsswshlgr
10-11 n: thnnnnvnnnnnvbnn
2-13 r: dqnvjskcqhmrrtn
10-11 k: kvhkskkfrkr
7-8 s: sssssssm
5-6 d: fddddvv
16-17 q: qqmkfqvvqdqqckqrw
7-13 d: lddrdgdddzddz
14-17 v: vvvvvvvvvqrvvvvvbnqx
1-4 c: ccqn
14-15 t: tbtrrqgtldttmktrt
8-14 c: csccctccrrcwcqc
1-4 n: nnnbnnn
11-14 p: pppppppppppppppppp
4-6 d: hcrkddqddm
1-2 b: xbbbb
2-7 f: cfwqnzbtfnt
7-11 q: qqqqkwqqlqqqq
2-7 g: gtgsgwg
3-4 w: wwks
2-6 j: rjjstgwskhwc
8-15 w: wwwwsgrwwhwjvgqw
5-6 f: ffffhr
1-4 n: kxcn
13-14 k: kkkrkzkkkkkrkhq
2-4 d: fdtpdlbp
4-5 g: ggggg
5-8 x: skzrxxsxxhknxzxxxpnf
4-7 h: ddhhbxnlhfb
4-15 q: wqqlqqqrgqqqwqqqqqq
2-3 j: jjwlnjb
7-13 k: kkxkknjkkkkkksk
3-6 g: ggmgggggggg
3-4 b: bbgbbfd
5-7 j: jjjjwjjj
4-5 x: hvnhxhxxkzxzxc
2-8 r: rlrrwrrrc
11-14 c: ccgccrcccccbhccccm
1-5 f: vfffffffffff
16-17 f: fffffffffffffffff
5-8 n: nwnnngppnn
10-12 m: mmmmmmmmmvmmm
7-9 l: llllllgll
12-16 v: vvvvvvvvvvvlvvvvv
10-12 w: wwwwwxvwwjwwdwwwq
2-8 x: cxjlkdwctx
10-11 d: mdddlndmsdd
1-3 h: bhkfwhjls
6-9 c: cccpcncccc
1-4 c: tzxzctxhpt
10-13 m: mmmsmwmmmsmmcmh
8-9 k: kkkdkkkrb
3-5 x: xkxjxx
6-7 q: cqmxqqqlhtqpgqsqwqqd
5-7 g: ggzggggqg
2-4 n: ncnvzvrk
6-7 k: kkkkkzk
3-7 n: nnnjcmpgtgxqdwjz
3-6 m: zzzvmmmmlmq
1-4 q: nqqqqq
4-5 n: cnnzvn
4-8 s: bscfsnss
8-9 b: pqbtmxfbt
4-13 h: shqjphgfvkrrj
3-8 n: cnphjnhbtndtcn
11-12 f: ffkfzfffbftfffff
6-8 p: ppwppxspppbp
4-5 d: ddddnddd
4-8 n: qnbhwnzxd
3-8 r: csflkrvrq
7-9 z: zzwtzzmzzzzzxdb
4-7 f: wgfffkw
3-6 d: wgmxddvdwtdtknvsz
6-17 w: mzmwwwwzkxwwcvpwrs
1-8 b: bbnltzsmbbfp
2-5 z: tpztzz
6-10 w: rwtwrvwpwwwwpx
11-15 s: sdsssssdsxlpsss
12-14 s: sssvsssssssssr
10-11 x: dqxfvxxxxlx
6-7 z: zqzzzlzz
1-2 t: ftvbp
10-15 d: dddddddddmwdddshdd
8-16 w: wwwfbwwfqwzwvwthjw
6-7 x: xxxxxxpx
11-13 h: hchhhhhhmhfhp
8-11 m: vmmmkmmmxvmmmt
12-18 w: jwmpwwwdwwwwkwswdwz
4-9 f: hwfftvxmpfffff
1-5 n: nhchnnkpn
2-16 l: nlxtpcdlzdkhnmqsvqfg
4-5 r: rrrrr
14-16 d: dddddpgdrddddcdbddd
4-5 j: gskjzxjjz
13-15 s: qsmccrpnsrrvwsk
16-17 f: ffffffflfffffffff
14-15 l: nllcllllvnlwltll
3-4 g: gxghgggdggg
5-10 x: xfxxqljxxkxxx
1-4 q: lmzzq
13-17 x: xxxxxxxxxxxxxxxxt
8-12 b: bbbmxbbbjbbbb
14-19 x: glxxxxhxxxxwxjxxxxc
6-19 d: ndflnddcxksdzdbwdddt
3-9 c: ccccccccl
2-17 z: zrxzbzwzzzzzfzzcz
1-4 m: fmmmml
9-17 l: lllllllllllllbllllll
7-10 r: wgrnrkxrrmrprxrr
2-3 f: vcfff
12-15 t: tttttttttttwtttt
1-7 c: xcccccc
1-9 t: kftttbttchttttttttt
1-4 c: cpkcwmdwxnwvjzfbj
12-16 n: nnnnnnnnlnnnnnnnn
3-4 q: qcjq
4-6 t: tdttkshpmlgqstpttfcc
3-4 j: jjmcxlb
3-19 w: qwdwwhwwjqmwwwwgqwfw
7-12 z: zzgzzzwzkzzb
14-15 c: nccccbdqwdccccd
2-4 k: kkkkrv
14-15 k: kkkkkkkkkkkkkkrkkkk
3-14 s: sspsssssssssstsssss
2-6 r: tdrrrwcrrcrr
1-2 g: gfgg
4-7 z: zczhzkzzccmpg
3-8 t: ttvtscttzcxtt
3-7 q: svkxfrxrvqqpmxzsbk
17-18 p: ppnppppppppppppppb
15-16 b: brbbbbbbbbbbbbpbb
2-4 x: shxx
6-15 m: mmmmmmmmmmmmmmvm
3-4 b: bbbbb
8-10 k: kgkmkkkjkkgkkmk
9-12 j: jtjlwjjjjjml
3-4 w: whwdpqfwghhj
12-13 s: ssssssssssssg
13-19 n: nwdnntnnnqnnqnrbmnmn
14-18 z: zzzzzzzzzzhzzzzzzl
4-11 b: bbbbbbbbbbhbbb
3-19 x: jwxjftcjnkmlgcfgxzmj
6-11 x: xxxxxxxzxmxx
2-4 g: vqgg
5-6 b: bbtbbvhpvbbm
7-9 t: csthttrtttt
10-13 q: qqqqnqgcqnqqqlqcq
8-10 j: jjjjjjjdjw
9-10 v: vrpnvvvvsvqvcvv
2-12 q: jqqqqqwqqqkqkqqq
4-12 z: zrcznzmzzwzzfs
3-6 n: ntnptpnvnns
5-10 d: ddddhddqdd
1-4 l: pcdsl
4-5 d: ddddz
3-10 v: kgnvtcvfvvqkvgwkvj
16-17 x: pdpxctpsxgpjshbxvvq
2-11 k: kkkskkkkkkz
1-4 d: ddddm
3-4 b: bbqm
4-7 b: bbrbbbb
18-19 h: hhhhhhhhhhhhhhhhbhwh
8-10 p: pvlxpppbppppptqbwgp
1-3 w: sfwgwnvghzrn
3-4 l: llwlln
15-19 j: jjjjjjjjjjjjjjbjjjjj
1-7 d: ddddndddd
6-14 c: ccccchcdcccccc
12-17 f: ffxffjffhffzsffffffv
5-9 b: pnbglbbbrdn
8-9 v: vvvvvvfwvvqgc
5-10 l: llklllgllzlm
2-5 t: tttttt
3-7 f: fsfhzcfffvffnrfv
2-5 q: gqqqq
6-7 c: ccccccj
9-13 g: vrgjgkggvpggggggg
4-10 n: nrqnnknbvntszznzmgbn
2-7 x: wslrxrx
4-6 s: ssszbwst
4-6 m: mzmcgnm
6-8 g: gdggggggg
3-6 q: qqqqqknrq
16-17 d: dddddddddddddddzd
4-11 b: bbbpbbbbbbvb
3-4 p: jrppp
2-7 n: wgznngfndc
2-9 f: kcfrnfcpknxfgj
11-14 l: nvdlmzgpllqzllvlqlt
5-6 g: ggggdsgg
15-17 r: kqflshskjhrcgrfcr
13-17 f: gpfwfffffffbfffffff
15-17 s: srssfssshssgsstss
4-8 f: fvfpfbffffb
11-16 w: wwwwwwwwwwwwwwwr
3-4 j: jhjvhwd
4-5 r: rrqtrr
6-14 w: dkwwqwdrxrwwbxwqgww
4-5 s: sssgk
2-4 d: ddtmxd
8-9 w: wwwwwwwwn
2-15 d: rhkgdbbzdszjmbm
2-7 h: jvqmhwbhfqkgzw
6-12 q: qtqqqfqqqqqd
3-5 g: gsxcggzfwgggsl
2-7 p: dprmlmpwpw
9-10 m: mmmmmmmmmkmm
1-4 z: zzzqkfzt
2-8 l: llgllllb
3-12 w: hwwcspbckppcgwb
2-3 s: tnsxtstsstb
1-2 m: fmsm
6-10 q: qnqfqqqqqv
5-10 x: tlgxxwcxgx
8-16 k: kmkknmkgkkkkbkkkkkr
4-16 b: nwbbfcfngbbspnxbj
2-9 m: mmmnmvmvjxmmdmr
5-7 k: fkkkjfbwfkk
2-4 m: tmkfjfqqjmgsjmtz
3-15 z: zzzzzzzzzzzqzzwzzzd
9-10 n: dnnnnnxtnnnnnn
2-3 w: wwwlcwzl
9-10 j: mzbjvzjjvjjgrjj
3-4 d: dhdd
2-6 r: jrcrwjr
9-10 v: bkvvvvvvvjvv
2-6 x: xnwnnx
18-19 k: kkkkkkkkkkkkkkkkkpk
3-5 j: gtjrr
5-6 j: jjjjjj
5-6 k: kkzknk
12-15 t: tttttttttbdlvtq
1-4 d: ddwvz
3-8 f: xlfffrpf
1-2 z: zzdscgwbxtxrd
5-14 n: nsnnnlnnznnxsnnnnnd
9-10 g: gwslkgdgwqdbgws
4-6 f: sfcgkffmfc
10-14 m: dmmwlqmmmmmmmmnm
8-12 n: nnnnnnnnvnnv
15-16 l: lllllllllllllvqlf
1-10 t: tftpttjtnt
2-7 t: ljzdkxtwvbmjtff
2-9 w: stwwlqcbtws
4-6 h: hjwhhvvtpg
3-5 v: vvgvv
8-12 d: ddhcdpdjdddhddmr
10-11 x: kxxllzjrdxlsxx
5-6 f: fffjfrff
17-18 b: bbbbbbbbbbbbhbbbbbbb
3-8 r: znrntdqtmrg
6-12 s: srsvsmsssssssssssss
2-13 z: dzfvpthfxnpnz
7-13 j: jjjjjjrjjcjjw
9-10 l: tllllllljl
12-14 m: mmmmmmmmmmmmmm
17-18 l: llllllllqlllllllggl
1-9 d: dkmqddddzdnrfckdz
6-7 m: gmmmmmlh
13-15 t: ttttxtttttttggbt
6-7 j: jmzvwkjjnjsnjkjxj
1-17 m: gmmnmdvfmmtmmqmmzcj
3-5 l: hvxsjt
7-8 x: kxqczpdxfpjp
2-5 k: kgkkhkdkk
5-7 v: nbjvcgsvf
8-9 d: cxddddnsxd
2-3 p: mmqnjbtbpnmp
11-12 m: jmmmmwvmmhtmmmmlmm
3-14 m: zmmjsqfmqrnzmlmwrjm
3-6 n: vnnnnjn
11-12 j: jjjjjjjcjjjs
13-17 r: rrrrrrrrrrrrrrrrrr
4-5 c: bcncn
2-3 j: bjftxcnzpnjrzxhxlp
9-12 z: tzrlxlzdxzsz
3-5 j: sjtltj
5-7 w: wwwwwww
5-7 p: ppzppcwkvwmwpscfpp
9-10 j: jcjjjjjjjj
3-4 m: mmrm
1-10 k: zkkktkkkkk
5-13 d: bpfldtnfrbdfk
2-3 s: zsskw
6-12 x: xxxxxkxxbxjxlzx
3-9 t: ntgdtbtwnntjbcsfz
6-10 j: sndjqjjdjbfjc
3-4 t: ckqtjtffctwtcp
2-3 v: wvhffpnngzv
7-8 r: tlrncrsg
7-10 g: gjggkfvffg
4-9 x: xpxlxxxmpr
6-9 r: srrrprrrr
7-10 v: gvvnnvhvvvvvdjjvv
4-6 s: psnsgsnfxlscwss
2-4 w: vwwpwx
2-4 b: bbbb
2-16 v: vvvvvvvvvmdvvvvv
3-5 f: ffkffjffff
6-9 q: lqqqqjqqxn
1-5 w: qcvwwwhw
2-10 w: wwwwwwwkjz
6-8 t: tttttttz
13-14 x: xxdxxxhbxxxgcdx
2-4 n: svkl
8-14 f: fffffcfffffffnffw
3-6 n: lsnnnpnnn
11-13 l: lllllllblllll
4-5 s: sssss
3-4 z: zbzt
1-4 x: xxxsx
8-9 c: wlxctcccrqccsccr
5-8 v: vvnvndfqq
4-6 r: rrrtrc
10-15 b: nbbbpfbbbcbzzxbf
4-5 s: sglpschlsgsqbskrd
13-17 k: bvfzktkkkzkkjkkwkf
1-11 x: zkxxxgxxkwxvxgx
15-16 d: dddddddddddddgdwd
2-3 p: pzpprsp
16-19 s: sssbssscjsshwmmszst
11-13 s: stsssssssgmssp
10-11 s: sssssssssgs
5-8 j: jjjjttkj
9-12 s: ssssgsssswsv
16-17 k: kkkkkkkkkkkkkkkwb
9-10 g: bzcdgvrvqg
4-5 n: nnnrn
4-12 n: knnrnnxnnnnjndwn
1-3 m: mtmspm
16-17 b: bbbbbbbbbbbbbbbxb
9-14 m: mmdmqwwbmmlxmjljmm
6-11 z: wzzzzzzzzzzzzszxzvz
2-8 q: qqqqrqqqq
3-4 f: ffhf
9-12 t: ttlqqthvttcttttm
5-8 w: zwwwwlmwwlww
5-7 z: zjjwzkkkjlwzvkp
7-10 z: zkzgzzzxtzz
12-13 v: vvmvvklvvvvgv
10-14 t: ttttttqttttsrttktv
7-10 l: llhlllzllv
1-4 j: blwjjmj
8-10 k: qpffpqskqk
5-9 w: wkdjxcwwswwwwwh
11-13 b: bbbbbbbbbbgtjb
14-16 c: ccccfcbccccccccccc
9-11 l: lflnpwbcmld
8-11 q: qqqqqqflqhtpqq
12-18 z: zzzzzzzzzzzmzzzzzl
4-5 x: xxfhxx
6-16 z: tfrhztxxzzqczznwzz
4-13 l: vlrlmlllldllq
14-15 b: bbwbvbbhbbbbkvnbbbb
3-5 x: frxxx
11-13 f: ffbfffnfffjlffffff
5-6 d: dkrdrgdd
6-8 g: gggwglggvtkglg
1-5 s: sqsnpp
2-4 b: bxjnb
1-2 h: hhfr
10-19 b: tzbpbsbbbtbbbbbbbbbb
3-4 p: pkmcpm
1-8 q: qqqqtqcnqxkqb
13-15 s: ssmssqssssssssts
4-6 q: qqdsqrqq
9-13 z: zzbzzzzpzzzzz
19-20 r: xlrrrgrrrcrktrrhrrrc
9-14 q: qzsrqqqjxwqqhqd
7-15 g: ggggggsggggggggp
4-5 w: wwwkq
7-15 h: ghgpkphhzpmhjpwxq
15-17 v: vcvvvdvvvvvvvpvvhv
1-2 j: qjqbfwbj
3-9 c: nvcwkcndt
14-15 c: cccccccccpccgkclcc
5-6 p: pppppp
12-14 h: hxtxhthhshkrmh
1-2 q: wqjqzqqk
14-15 f: fffffffffffffbqf
7-8 j: vjjjjjfh
7-12 p: trzzppxpptpfp
13-18 w: wwwwwwwmrwwwwwwkwwww
10-11 f: rfffszjfsvn
9-17 l: llllllmlllllllllkl
5-12 s: xssssqssshsss
2-6 x: fxxxsxbnx
4-6 n: nnnnxhnn
10-11 g: gggggggggqg
8-16 n: nknsfcnnnqgnnnxsnfnj
4-7 n: ndnnnnnn
8-9 q: shqphcskmqjqvqqqq
9-10 r: rrrrrjrrrrrr
16-18 z: zfzzzrzzzzzzzzzzzhzz
2-13 g: gkgggqggggggrgg
12-18 v: vvvvvvvvvvvvvvvvvvv
3-4 s: hssq
6-11 h: kdwftsxqcnhph
16-17 t: ttttttttttttttttt
6-11 f: fffffdffffsfffffffff
10-14 p: pppppjvpppppph
10-15 b: bbpbbbbbbtbbbbb
3-7 n: nnnnnnx
3-5 r: rrffrsr
10-13 r: brrrrrrrxrrrrr
6-7 f: ffffkjf
3-7 r: srdrrsrrfrcr
4-9 b: gflbcxtvknsbpjbwrk
8-10 p: pttpkfppcppdznpgpp
13-16 q: qqqqqqqqqqqqqqtqs
1-4 r: rrrwr
1-2 g: zggggggggggg
7-8 j: jjjjjjwb
18-20 t: pwnrvbdzxntvgjjjltqn
8-13 f: fffxffflffffff
4-5 k: cklkk
10-11 m: mmnmmmmmmnm
11-16 q: qqqqqqsqqfsqzqqqq
2-9 n: nnnnnnbnnc
7-11 d: sddnmgfkdddzdd
1-4 f: qfdlftk
8-10 p: pzpppxphphpp
2-4 m: mlwf
6-8 h: jxhhhfztzh
5-8 s: ssnnnssssstsssssd
3-5 x: hlxsx
7-8 h: qhhhhhhwdhph
2-7 v: gxdvcvw
14-15 n: nnnnnkhnfnnnfnnnnnn
9-10 l: lllllllhlnklx
13-18 j: jjjdjcljjjjjjjjjjhj
1-7 h: jkhhhhhhj
9-19 z: tzznzzztcbxkzvssrzzz
12-18 s: sswssscsstnssjssss
4-9 z: zzzxmzgkzspdmq
6-13 d: ndldddpddddddkmdd
8-9 q: zgqrkhxqq
3-6 m: mmmgfdw
1-3 l: dlls
10-11 b: kbbbsbbdbkbqbbbbs
2-4 b: bbbp
5-6 c: xctccckq
3-5 k: kkkkk
12-14 b: bbbbbbzbbnqbbb
6-8 q: jmmhqqlqqkgqcjvqq
11-12 g: ggggpggggghsgg
8-9 h: hhhhchhhbh
10-11 w: zwwcfgwwwwc
5-8 x: xxxxnxlxxx
1-4 f: fffhf
2-3 f: fbwfxr
5-6 f: vrfffd
14-15 r: lrrrrrrrrrrrrfc
7-8 t: tbnptvtt
16-19 r: rrgrrrrrrrrljrrrrrrr
2-4 b: bbpsh
7-13 m: gmmsmmlmmbmmmmmmmgkx
16-17 g: ggggggggggggggrfgg
1-2 g: fcfmr
5-7 l: lclllll
3-5 n: nnnccgvn
1-4 v: npvv
5-11 s: sshsxsswshss
9-12 x: mxxkxxxxsxpkxsxhnktx
3-4 f: fsff
5-11 b: bqzzbcbbbxbk
3-7 s: ssxsssv
6-14 p: pxppjppppppvjp
2-4 h: hhkch
5-7 s: sdshspsssqs
2-8 k: vwkkkkwkskjr
17-18 m: mmmmmmmmmmmrmmmmzm
12-15 w: nwrgwwwjpwwwwpv
3-4 t: ttft
5-11 f: kfffzffzfffk
15-16 d: ddhddddddddcddddd
3-10 l: wplpvlrcqwlblvlcqm
2-5 z: zpzzz
3-5 v: vvgvv
3-4 b: jbgbb
14-15 d: ddddddndddddddd
4-13 z: zszfktzrzjtzzbmn
1-8 b: xbbxrbbbbbb
3-4 t: tttftt
5-9 v: ptvvvcvvvvvnvvvv
1-2 n: tcnnnnln
5-6 h: hhhhhh
10-11 j: jvjjhfjbxjj
4-7 t: twtdttttttttt
12-16 z: zzzzzzzzzwzzzwzzzzzz
7-18 l: hnhcvlnxglxlldlfgvll
2-5 j: jjjjjj
2-8 n: nrknnntn
8-9 z: zzzzzzzqz
4-5 z: zzzzr
1-9 t: bztttgtllwq
8-12 n: ckjnntmkxxcnwkqznp
2-4 b: xbrvvhbbb
1-4 d: dddzqd
13-17 w: wwlwvlwpwwdwwwwqb
3-5 q: lqzmlq
8-9 z: bpzzzczzpzz
1-6 n: nbjqmnhxwh
6-8 q: qqqqqqqzq
16-18 r: rrrrrvrrrrnrrrrrrb
3-8 l: lbfdwlpzmkl
2-3 g: srwcwmgvzjjxj
8-17 w: wwwwwwwjwwwwwwwwww
19-20 t: tttttttttdttttttttvf
1-11 x: pwnwxxfxnkxxtzpglx
6-7 g: lgpglng
5-7 l: llllfll
5-6 p: ppppppp
3-4 x: xxdf
4-15 l: fgkzwrrpmvmhzplsqp
2-4 b: bbqjb
4-6 k: kbkkkwkkk
4-8 p: mppzpprpp
14-17 n: ttfvdtwxnnfdsnxbn
3-5 m: mmzmmm
6-7 k: kkkkndk
1-6 r: hkkrln
4-6 h: hhhhhmhhhhhhh
7-10 k: kkkkkkkkksk
3-4 g: fggggg
5-12 x: qhgrxxhrxjjxxhxgb
3-5 x: lxpxxb
4-7 f: frffsfjff
4-6 d: dpddjfxdrt
11-13 f: fffpxfcfffdfnfzf
12-18 r: rrrrwrrrrrwrrrcfrcr
18-19 q: kqqqqqqqqqqqqnqqqkqq
3-4 b: bgbrf
15-17 s: ssssssssssssssbdss
6-9 d: bnvlpxlctvdd
1-2 s: smsss
2-9 s: cpgrfdfmm
5-12 j: jjjxdqjctjjtnzcjq
9-16 g: xqzgsrdtcvblfpmg
11-15 q: qqqsqqqqwdqqmqqpqh
3-8 d: xddzddtdnk
5-8 p: blppgpppppppx
7-9 m: mqwlxbbcmqf
6-8 t: ltttbttsbtrtts
12-13 k: kqmfkcvkwsnddkk
16-17 t: hrkwqdtckqdktgctj
2-4 m: mmmm
2-11 l: tlflzkxlvlq
5-6 j: jjjjjl
2-13 x: wzfjxsbqznqlx
4-8 s: mssssfzpsh
7-17 v: vvxvvvllvxvvvhrvvv
3-6 h: qchchw
4-10 n: nllnnbnrvnnnmgnzb
16-17 v: vvvfvvvvvvvvpvvvjv
2-14 f: lpbfwlffxhlxfffkf
5-7 w: cfwkwnl
4-6 n: nnnnnn
10-11 d: dcddddddddd
1-2 d: nvrdpnvnlxccjrd
15-16 v: vvjvvvvvvvvvvvhzv
3-4 l: wwlpllqk
2-4 p: pvpp
2-3 b: bmbf
2-12 m: snpdndwgtfqjlzdmmth
5-8 j: rpjjjjlpsj
5-9 g: gdmvgsgjrhg
6-7 p: pppppdspp
2-9 k: dktlkrkwlnd
9-18 b: bbxbbbbbrbbbzbbbbvb
5-9 t: ttqdcwdjtwtqttttbc
8-10 d: njdddddtddhd
4-12 r: fkrfrrrrrrrgr
6-7 s: ssskgxssbs
2-6 m: mtmmmkmm
11-12 h: hhhhjhhhhhgh
8-9 q: kfqkscqnq
6-12 d: sdpddmvdvdxdl
1-8 f: cffzgfffkfff
4-9 v: vvvvcnljw
4-5 p: wplvpp
2-3 w: kxwwww
3-5 m: nmmmmm
2-6 t: ttntttjhctkztt
11-14 v: vvvvvvvvvvqvvf
7-8 z: zzgjqzzzzzdzzkzw
13-15 k: kkkkkkkkfkkkkkk
6-7 m: mmmmmfmgm
7-8 m: fgxsdqmnmmszv
1-3 p: pqppp
8-12 s: sssxqstsssnfsxss
7-10 q: qqqfqqxqqqq
2-5 x: djhvxxm
3-5 b: bjbbbrjgbbxkbgpqd
3-17 c: ccscccjccmclccccccc
8-12 d: djrdgddwxddxskt
7-9 h: hhhhhhzhmh
4-8 l: jwlplsct
6-10 q: qvqhqxnqqmz
1-5 w: wwpwqw
3-12 d: pltzkcsdhphdmdxkb
1-9 k: kkkkkkkkx
2-6 d: dbddqddd
11-13 n: njnrjnnnnnqzn
2-4 k: kkkkkk
11-14 g: gggggggggggcgngg
15-19 v: vxqvvvvvvvxvvvbvvvdv
9-10 s: ssscsssssf
1-14 m: mmmmfmpqmmmmml
6-8 t: sttqtbtjt
5-7 k: vkkshkw
5-7 x: xscxxxm
6-12 d: pddxdddqkdddzmddpd
2-14 t: gtmxtcttqtttxtv
7-14 r: rrrrrrrrrrrrrpr
15-17 d: ddddfdddddddddddmd
4-5 x: xqxxx
11-13 w: wwwwwwwwwwfww
5-6 j: jjjjjj
5-6 m: mmmmmm
1-3 b: fbblbbgbx
7-8 v: vvvvvxvrvd
6-11 f: ffffpwpfqfhfzxdc
11-17 m: mtmdkbvmjmxmmdmmgb
8-12 h: nhbtsbhjhgdh
7-11 w: wwwpwwdwwwd
11-12 f: hffrfffffffqqf
12-13 f: flfcffffffffqdff
2-3 v: hbbv
8-11 d: drdlbdhwdsddd
6-9 w: swrwnbwmkxwt
10-13 l: llflsllllntlll
8-11 v: xvvvvvtkmcvvvxh
3-4 h: hzhbh
11-12 b: bzbbbbbbbgzxbbbbbm
13-17 l: lqwxqmqmjlsmfwltkzl
1-5 l: mwllx
7-8 c: cccnccxcc
6-12 b: tbbsjbkprrdg
3-5 z: zmpzc
5-8 j: jjjltjjj
6-11 z: xzlzgzqhqwgz
4-5 m: mmmmmm
5-6 q: pqwfqh
9-14 p: pppppptfhpzjtct
6-10 w: wdwwwlwwdww
14-17 m: mmmmmsmmmmqmmwmmm
4-5 v: vvhpfnvv
1-7 q: qfqqbxqvqf
6-11 z: zzzzzzzzzzd
6-13 g: gggggfggggggg
12-13 d: ddpdjqdddddmd
8-10 n: nnndnnnnnn
6-7 z: zzgdzzdvz
6-8 n: vdnvnsnnnlnn
3-4 b: bblbl
1-3 f: zpfjkfr
7-9 h: fhtxkhwhgq
7-9 x: xxdxxxpxx
2-3 v: vmxv
18-19 z: zzzzzzzzzzzzzzzzzhrz
4-6 x: hjlsdv
2-3 x: jzxxvkhsxxck
1-9 s: sfjvsjqvss
8-12 j: xxcmpzjjtmkswwr
4-10 s: ssjtvssslwszss
9-16 h: rhhphhhhwwhhhgrhhh
7-8 h: hvhhhhhzh
7-10 m: mmmdqbtssvmfmmmgr
5-7 h: hhbhzhh
5-10 c: ccccqcwxcccc
4-6 q: bmhqqbpfrqfdkq
7-9 r: rcmrdrrrjlrscrrhkl
3-4 t: ttgz
8-12 g: mgggtggggzgzcphhx
6-8 d: dvddfctd
2-3 g: gmglf
1-2 m: dmqwpbhmmktcvc
6-8 z: bzwzzkxqpz
1-9 x: xxxxbwvxcxxcxwznw
3-6 z: zzzzzz
5-6 k: kkkkhk
12-13 q: zqqnrcqqqplqqndfg
9-12 l: jdvxtbqblmllfbnlff
3-6 v: vvkvvv
4-7 v: xbtzjdvp
8-10 h: hhmhhhhhhnmd
7-8 t: ttktgqfzxrdxqf
4-5 g: gggjf
6-9 q: qqqqmmqqqqq
1-10 w: rwjwwwwwrcw
9-13 b: ssbbbcbbbbbbd
2-3 g: bggggv
6-11 w: wwwwfwwxwwww
5-9 p: ppjppppzt
3-14 z: gpzzzdzzjzzpzzzz
1-7 v: vbbfvjz
2-5 q: qdwczqqq
1-5 r: rrrrhwtf
8-14 d: dddddddtdddddddd
7-8 p: ppppppzlp
5-6 s: lbssnssss
1-8 q: lqnpqqqqq
1-4 k: rkqkkk
1-9 z: zgkxmkmgqzg
1-5 b: cbbbbbf
1-4 c: dctcc
4-5 x: sxxtl
2-8 m: qmfqbfmlkkkjzhqjbxpd
8-16 h: lhlghlcbqgsmjhbh
8-9 x: xxxxxxxxx
10-11 l: cvndhntlghk
8-11 d: dddddddcddz
4-5 j: jvjpjj
1-2 d: bmhdpdr
1-4 j: jnjcjnjtd
4-8 m: djsvzshmxmgb
4-10 k: bhpkgzksrkkqk
4-6 l: lllllwlvwlglxqll
9-10 h: hhhhhhhhhm
3-4 q: qqsbq
7-9 l: dlllllgllllszg
10-12 l: lllllllllvlzl
1-5 k: kkkkr
10-11 w: wdwfkwwwwww
8-10 g: rzswrffrqgdhgzm
3-5 z: zzzzz
8-14 p: pplxppppzprpdpjpppdp
6-11 g: mkghrgcmhxggcpddvx
4-6 b: sjwbqv
1-2 q: qvpqlsqqqrnbp
8-20 w: wwwwwwwwwwwwwwwwwwwg
12-15 m: mmmmlmmmmmfwmmm
1-14 x: xxxxvxsxxxxwcjxvxxx
11-14 g: ggdggggggggggx
2-5 r: xrqtf
10-12 q: qqqvqcqjqjfqqxqqkqj
3-4 c: cvszc
2-7 w: mwwwwwvwx
6-8 r: hrgrckfb
4-8 d: ddddgxcznlnwdddd
1-4 c: drhvzzc
3-14 n: pfnjnnhpnppfnrbhz
3-4 n: bnnnb
13-15 h: hhhhhphhhhhthhgh
3-5 l: lfllpmknmplx
1-12 c: lcchctpccccccx
8-9 l: lznsllwlbllmllzl
7-9 w: wwwwqshnwkwwww
10-12 k: zxkknkxkrkckkr
9-12 r: rdrkbkgrrrrznrr
12-13 g: ggggggvgggggr
2-5 g: vgxggr
5-6 c: cccthsc
2-3 t: nptdqmfglpzdvwkspt
4-13 q: qqsxdqqfngqqkqq
17-19 r: rrrrrrrrrrrrrrrrxrf
7-11 t: ttttmthttttt
1-5 l: lllwl
8-12 x: xxxxxxxbxxxwxxx
10-11 d: dddddbfddddcdd
3-5 f: lfffb
1-4 f: ffff
1-9 s: swdckstss
7-9 p: pbfzppbmp
1-2 p: xpqssm
6-16 h: hlhhqdhhmhhhhhphhrh
4-5 b: pbbgxbhqbzvnwxxb
7-10 n: nrbdnnnwnnnlnn
1-2 r: mspcrbgfqs
12-16 l: rlvmtklhllrvljlllx
7-10 p: mpppppprpmjs
6-7 g: gpggwmggggv
1-4 q: qqdqlqq
9-18 x: xxxxxxxxtxxxxxfxxxx
2-4 h: hhhshh
3-4 q: qllq
5-11 g: ggggggggggsg
1-4 r: mrwbr
4-6 m: knhmnm
13-14 p: pppppppppppppp
9-12 v: vvtvvvvfvztvvvxwqlg
11-13 r: rrrrprrrrrzrr
7-11 z: zzzzzzjzzzzz
17-19 d: ddddddddddddddddjdd
4-5 c: ccncdc
4-6 x: gxxvqx
2-3 g: ggpg
6-11 m: blgvnmbxhpmxmb
2-15 w: wvdwwfqjwqwvmfrzw
3-4 s: ssdw
6-7 l: mmllqlcllklxcml
16-17 l: lllplllllllllllllnl
2-4 h: qtwhwz
5-7 v: xvvwfvfvv
4-10 k: kkkkkkkkqkkk
5-6 f: qzvvpf
4-11 d: whhddttshzds
10-13 q: qjlqqqqqpwqqgqq
11-12 w: nwwwdmvwwwwk
4-8 l: rlljllhljl
7-10 s: sssssssssd
2-8 c: qcgrtxrfccgc
7-8 n: pnnngnnnvnwdnn
8-10 c: cscckctxcrhgc
1-4 n: ngnncrnn
6-12 t: ztzqttbmtztpsnrnt
8-12 b: bbbbbbbbbbbb
1-4 z: czzzzzzz
1-2 k: kktmkf
10-14 x: xxxjsxxnxxxxxqxxpx
11-15 v: vxvvrvvvdvvvvvbv
7-9 s: nsslmtsdxbxfsfssswfx
12-15 l: lllllllllllfcltllll
6-7 q: qqqqtqdqq
15-19 n: nnnnnnnnnnnnnnbnnnn
6-8 s: ssttshsks
16-20 r: rrrrprrrjrlqrrsrrrrb
7-10 q: qqqqqqqqqq
3-4 w: wcbw
5-6 g: tcggrxgrgvl
10-12 l: kllswlmlglps
4-7 v: qkvvvvqxjktkvvvjv
5-13 r: rrrrqrrrrrrrrrr
1-2 n: nnnnmb
1-8 x: xktqbxgkkjwlt
3-4 k: kskk
16-17 k: kkdkkkkkkkkkkkkwk
10-15 n: vnnnnnnnnqjnnknnnr
8-15 m: mfmmgmmqmmmmmkmmmmmm
4-8 k: kkkgkkkjkkk
16-17 h: hhhhhhhhhhhlhhhqh
1-4 p: ppprpppppp
1-9 g: gbdxggmggrgw
1-5 f: vfffff
2-12 d: jzvwdmsqpdnh
12-13 w: wwcwgzwwwwwhwwwwww
9-10 z: zzdzzlzvgzzztzzz
4-5 f: ffftff
8-14 x: xxxxxxxrxxxxxx
1-4 r: kgrrvrrvrr
3-4 w: zkpwxkk
2-5 k: tkckkfcvxkxk
3-9 r: rbrrrrgrrrrkbrrr
3-4 t: ttxx
8-11 z: zzzzzzzzzzz
6-10 p: pnwhxpmxpfskq
1-16 d: dddddddddddddddgdddd
1-7 c: kctcccg
1-5 q: sqqqrqqq
14-16 f: fjfffffqfkfffjffff
3-8 v: knvrrqvtv
1-2 p: ptgswlvpdnmr
3-5 v: vvkmnvdwk
10-14 r: rrrrrrrrrhlrwrrrd
2-11 f: xffffxjfffzfffpf
1-5 p: nppppppp
15-16 x: xxxxxxxxxxxxxxsx
15-16 b: prhbmdvwcmtzpvbb
11-14 t: rngdttnzqtjtcttdvbmt
8-10 f: ffvldffqfqffgf
1-3 r: rzqrmz
7-8 n: tntnnnntn
6-14 s: qpvlfbsgswsnwsmpz
9-12 t: tvwstttttttktwt
4-6 g: vslqbgg
9-16 d: dsdddddddrdddddhdbdd"
#+end_src

#+RESULTS[1b92a409b4b67ce7225cf682a5d837d32f6e6912]: input-2020-02
#+begin_example
15-16 m: mhmjmzrmmlmmmmmm
5-6 d: dcdddhzld
3-4 s: vqssdcbl
3-6 b: bbhbbbqbbb
10-11 q: cqqntqhqwwh
4-7 g: ggkgggw
4-7 f: fdfffflfvn
11-16 h: thhrhrwhbshshsdhhhhr
7-12 n: nnnnnnvnnnnn
4-5 f: ffxfhldh
9-17 m: mmmmmmmmjmmmmmmmw
2-5 h: hqrfzhhh
4-7 x: vxxfxxjxwvnlx
11-13 h: dhhhhhhhdhhhrh
4-8 q: qqphvphfrlqqkztgslzb
3-15 x: htblqcbdxdzgvhszxz
4-5 j: jjhnn
3-6 l: bwkjllgcjrzhr
5-8 s: ssmsspsss
1-15 d: ddhmhmvlkppkbbdxbc
7-8 l: ltllllllhgzlv
1-15 m: mtmmmvmmbmmfmmkmmmm
1-3 x: xrxzcxcx
5-6 t: tttttdtv
2-5 x: xxxxs
5-7 l: gclqlml
5-10 g: gggggggggn
6-9 j: xwjjfngjgjsjsr
2-7 b: hbqtchkcmblppvqp
16-17 j: jjjjjjjjjjjjjjmjjj
1-5 p: wpppdlpphppp
3-7 q: mspqqqqq
1-4 k: hkjk
3-6 l: llbllldzf
11-14 x: xxnxvxxxxlxxxkv
4-7 k: zkkksmjmrzxftx
2-4 l: lllwq
7-11 q: tbqqmmvkrsz
3-4 f: gwfs
3-5 z: ztszz
2-4 k: kkpzl
1-2 k: kkwckkzwskgbdc
5-7 x: mxxxdxf
1-3 p: pppp
6-8 c: rcqrmcqmpcc
5-6 s: srgvwsc
5-6 w: wwwwwww
2-6 w: xwwzfwr
1-8 z: djzzzcmz
10-14 b: dbwbbbbbldtbbbrbbq
5-15 v: wvzftvfvzkcvjdvvzcj
4-5 j: lrjdmjj
1-15 q: qqqqqqqqqqqqqqkqqq
1-2 w: vwkw
2-4 c: lccsfmkrnrldzbrc
5-14 r: rcpghlsspmvwvzmpvl
7-9 n: nnnnnnnnx
2-19 w: wwwwwwwwwwwwwwwhwbww
6-7 r: rrrrrzc
3-15 w: mnxmfqgklqddfww
9-13 s: tsslqtsszsqsssqssss
5-6 j: jjjtjrb
8-9 f: fffffffwfff
5-7 n: nnnnnnhn
8-17 d: dnfdqvwngbddvbndbsf
13-14 v: vvvvvvvvtvvvvt
2-3 h: hsbnhhhs
2-4 g: ggcgm
2-7 r: rvrrrrrvr
6-9 n: qpxchngsbhxrgqdgbqs
4-8 k: kkkkkkkkd
1-6 v: mrvlldzv
7-10 w: vvwkwrbnwczwww
10-14 k: kkkknkkkkpkkkdmkh
9-10 s: qqbwmssnssjs
5-6 z: bzvdjz
6-13 j: jjjjrzbrjzjmjzjsk
1-6 k: kkkkkrsskk
8-10 v: vvvvvvwvvzvb
10-12 m: mmmmmmmmmdmm
9-10 k: kkkkkkkkjkk
2-8 b: pbcsbbprc
6-7 x: xxxxnpxxxk
3-7 l: llllllml
4-10 j: jrjzjjjcjx
4-5 g: gggmgg
14-15 n: nnnndnnxnnnnntnn
4-6 h: hzqpgbhwh
4-6 b: plzbkbrpscqbxl
5-13 m: hptczmkkmplmw
7-8 r: vjhrhrkdrrrk
3-4 q: qqqq
11-13 s: sssnssssssmsss
11-13 x: xxbhkwvvxgxjh
1-2 f: ftlrdz
1-3 d: mdslnl
2-10 r: xrzbqcxlvtlrsznplk
8-10 w: wwwwmwwtww
2-10 r: zbzplcvnvrr
5-16 c: lcccccclcccgcccccc
3-7 w: wwpwwbww
1-4 s: svsss
6-8 j: jjllkwnjjjgcjpg
3-5 c: cccbb
1-14 j: jpkjjqjjgqmzbjjhjljj
4-9 w: dwwlwwdmkww
7-8 p: pppppppjhqp
1-14 d: djmfmdddkhfqdzfdddd
2-3 r: zrbjhpg
3-4 j: jjkj
3-4 q: qqqq
1-5 k: kkkkwk
6-13 t: ttzxtjtdjtmtttmtt
1-3 x: jxvx
11-12 f: fffffffffffkffffffff
4-5 l: lllhlm
8-10 n: hnnnnnkdfrnntdhnk
1-2 x: gxxx
8-12 w: pwwwwwwfwwww
1-19 p: ppnxfswpxfpbfcpnnpq
10-11 h: hhhphhhhhhgv
1-10 c: dccbvcccccc
7-12 v: vvvvvvrvdvvvvvvvvvvl
2-11 b: jbncfdbbbbcb
3-4 n: nnrn
3-12 s: btnfjtszszssdrsd
3-7 b: bznkfbb
5-6 r: rhprrhrrrhnzjhr
6-18 n: xznnnwwmwnvfnfnlhn
6-11 v: smsvpcjvvgvtvkmvv
12-14 s: sssssssssssssc
5-6 t: ttttfx
7-9 p: pppppnvppp
4-11 s: fbvfqsswshlgr
10-11 n: thnnnnvnnnnnvbnn
2-13 r: dqnvjskcqhmrrtn
10-11 k: kvhkskkfrkr
7-8 s: sssssssm
5-6 d: fddddvv
16-17 q: qqmkfqvvqdqqckqrw
7-13 d: lddrdgdddzddz
14-17 v: vvvvvvvvvqrvvvvvbnqx
1-4 c: ccqn
14-15 t: tbtrrqgtldttmktrt
8-14 c: csccctccrrcwcqc
1-4 n: nnnbnnn
11-14 p: pppppppppppppppppp
4-6 d: hcrkddqddm
1-2 b: xbbbb
2-7 f: cfwqnzbtfnt
7-11 q: qqqqkwqqlqqqq
2-7 g: gtgsgwg
3-4 w: wwks
2-6 j: rjjstgwskhwc
8-15 w: wwwwsgrwwhwjvgqw
5-6 f: ffffhr
1-4 n: kxcn
13-14 k: kkkrkzkkkkkrkhq
2-4 d: fdtpdlbp
4-5 g: ggggg
5-8 x: skzrxxsxxhknxzxxxpnf
4-7 h: ddhhbxnlhfb
4-15 q: wqqlqqqrgqqqwqqqqqq
2-3 j: jjwlnjb
7-13 k: kkxkknjkkkkkksk
3-6 g: ggmgggggggg
3-4 b: bbgbbfd
5-7 j: jjjjwjjj
4-5 x: hvnhxhxxkzxzxc
2-8 r: rlrrwrrrc
11-14 c: ccgccrcccccbhccccm
1-5 f: vfffffffffff
16-17 f: fffffffffffffffff
5-8 n: nwnnngppnn
10-12 m: mmmmmmmmmvmmm
7-9 l: llllllgll
12-16 v: vvvvvvvvvvvlvvvvv
10-12 w: wwwwwxvwwjwwdwwwq
2-8 x: cxjlkdwctx
10-11 d: mdddlndmsdd
1-3 h: bhkfwhjls
6-9 c: cccpcncccc
1-4 c: tzxzctxhpt
10-13 m: mmmsmwmmmsmmcmh
8-9 k: kkkdkkkrb
3-5 x: xkxjxx
6-7 q: cqmxqqqlhtqpgqsqwqqd
5-7 g: ggzggggqg
2-4 n: ncnvzvrk
6-7 k: kkkkkzk
3-7 n: nnnjcmpgtgxqdwjz
3-6 m: zzzvmmmmlmq
1-4 q: nqqqqq
4-5 n: cnnzvn
4-8 s: bscfsnss
8-9 b: pqbtmxfbt
4-13 h: shqjphgfvkrrj
3-8 n: cnphjnhbtndtcn
11-12 f: ffkfzfffbftfffff
6-8 p: ppwppxspppbp
4-5 d: ddddnddd
4-8 n: qnbhwnzxd
3-8 r: csflkrvrq
7-9 z: zzwtzzmzzzzzxdb
4-7 f: wgfffkw
3-6 d: wgmxddvdwtdtknvsz
6-17 w: mzmwwwwzkxwwcvpwrs
1-8 b: bbnltzsmbbfp
2-5 z: tpztzz
6-10 w: rwtwrvwpwwwwpx
11-15 s: sdsssssdsxlpsss
12-14 s: sssvsssssssssr
10-11 x: dqxfvxxxxlx
6-7 z: zqzzzlzz
1-2 t: ftvbp
10-15 d: dddddddddmwdddshdd
8-16 w: wwwfbwwfqwzwvwthjw
6-7 x: xxxxxxpx
11-13 h: hchhhhhhmhfhp
8-11 m: vmmmkmmmxvmmmt
12-18 w: jwmpwwwdwwwwkwswdwz
4-9 f: hwfftvxmpfffff
1-5 n: nhchnnkpn
2-16 l: nlxtpcdlzdkhnmqsvqfg
4-5 r: rrrrr
14-16 d: dddddpgdrddddcdbddd
4-5 j: gskjzxjjz
13-15 s: qsmccrpnsrrvwsk
16-17 f: ffffffflfffffffff
14-15 l: nllcllllvnlwltll
3-4 g: gxghgggdggg
5-10 x: xfxxqljxxkxxx
1-4 q: lmzzq
13-17 x: xxxxxxxxxxxxxxxxt
8-12 b: bbbmxbbbjbbbb
14-19 x: glxxxxhxxxxwxjxxxxc
6-19 d: ndflnddcxksdzdbwdddt
3-9 c: ccccccccl
2-17 z: zrxzbzwzzzzzfzzcz
1-4 m: fmmmml
9-17 l: lllllllllllllbllllll
7-10 r: wgrnrkxrrmrprxrr
2-3 f: vcfff
12-15 t: tttttttttttwtttt
1-7 c: xcccccc
1-9 t: kftttbttchttttttttt
1-4 c: cpkcwmdwxnwvjzfbj
12-16 n: nnnnnnnnlnnnnnnnn
3-4 q: qcjq
4-6 t: tdttkshpmlgqstpttfcc
3-4 j: jjmcxlb
3-19 w: qwdwwhwwjqmwwwwgqwfw
7-12 z: zzgzzzwzkzzb
14-15 c: nccccbdqwdccccd
2-4 k: kkkkrv
14-15 k: kkkkkkkkkkkkkkrkkkk
3-14 s: sspsssssssssstsssss
2-6 r: tdrrrwcrrcrr
1-2 g: gfgg
4-7 z: zczhzkzzccmpg
3-8 t: ttvtscttzcxtt
3-7 q: svkxfrxrvqqpmxzsbk
17-18 p: ppnppppppppppppppb
15-16 b: brbbbbbbbbbbbbpbb
2-4 x: shxx
6-15 m: mmmmmmmmmmmmmmvm
3-4 b: bbbbb
8-10 k: kgkmkkkjkkgkkmk
9-12 j: jtjlwjjjjjml
3-4 w: whwdpqfwghhj
12-13 s: ssssssssssssg
13-19 n: nwdnntnnnqnnqnrbmnmn
14-18 z: zzzzzzzzzzhzzzzzzl
4-11 b: bbbbbbbbbbhbbb
3-19 x: jwxjftcjnkmlgcfgxzmj
6-11 x: xxxxxxxzxmxx
2-4 g: vqgg
5-6 b: bbtbbvhpvbbm
7-9 t: csthttrtttt
10-13 q: qqqqnqgcqnqqqlqcq
8-10 j: jjjjjjjdjw
9-10 v: vrpnvvvvsvqvcvv
2-12 q: jqqqqqwqqqkqkqqq
4-12 z: zrcznzmzzwzzfs
3-6 n: ntnptpnvnns
5-10 d: ddddhddqdd
1-4 l: pcdsl
4-5 d: ddddz
3-10 v: kgnvtcvfvvqkvgwkvj
16-17 x: pdpxctpsxgpjshbxvvq
2-11 k: kkkskkkkkkz
1-4 d: ddddm
3-4 b: bbqm
4-7 b: bbrbbbb
18-19 h: hhhhhhhhhhhhhhhhbhwh
8-10 p: pvlxpppbppppptqbwgp
1-3 w: sfwgwnvghzrn
3-4 l: llwlln
15-19 j: jjjjjjjjjjjjjjbjjjjj
1-7 d: ddddndddd
6-14 c: ccccchcdcccccc
12-17 f: ffxffjffhffzsffffffv
5-9 b: pnbglbbbrdn
8-9 v: vvvvvvfwvvqgc
5-10 l: llklllgllzlm
2-5 t: tttttt
3-7 f: fsfhzcfffvffnrfv
2-5 q: gqqqq
6-7 c: ccccccj
9-13 g: vrgjgkggvpggggggg
4-10 n: nrqnnknbvntszznzmgbn
2-7 x: wslrxrx
4-6 s: ssszbwst
4-6 m: mzmcgnm
6-8 g: gdggggggg
3-6 q: qqqqqknrq
16-17 d: dddddddddddddddzd
4-11 b: bbbpbbbbbbvb
3-4 p: jrppp
2-7 n: wgznngfndc
2-9 f: kcfrnfcpknxfgj
11-14 l: nvdlmzgpllqzllvlqlt
5-6 g: ggggdsgg
15-17 r: kqflshskjhrcgrfcr
13-17 f: gpfwfffffffbfffffff
15-17 s: srssfssshssgsstss
4-8 f: fvfpfbffffb
11-16 w: wwwwwwwwwwwwwwwr
3-4 j: jhjvhwd
4-5 r: rrqtrr
6-14 w: dkwwqwdrxrwwbxwqgww
4-5 s: sssgk
2-4 d: ddtmxd
8-9 w: wwwwwwwwn
2-15 d: rhkgdbbzdszjmbm
2-7 h: jvqmhwbhfqkgzw
6-12 q: qtqqqfqqqqqd
3-5 g: gsxcggzfwgggsl
2-7 p: dprmlmpwpw
9-10 m: mmmmmmmmmkmm
1-4 z: zzzqkfzt
2-8 l: llgllllb
3-12 w: hwwcspbckppcgwb
2-3 s: tnsxtstsstb
1-2 m: fmsm
6-10 q: qnqfqqqqqv
5-10 x: tlgxxwcxgx
8-16 k: kmkknmkgkkkkbkkkkkr
4-16 b: nwbbfcfngbbspnxbj
2-9 m: mmmnmvmvjxmmdmr
5-7 k: fkkkjfbwfkk
2-4 m: tmkfjfqqjmgsjmtz
3-15 z: zzzzzzzzzzzqzzwzzzd
9-10 n: dnnnnnxtnnnnnn
2-3 w: wwwlcwzl
9-10 j: mzbjvzjjvjjgrjj
3-4 d: dhdd
2-6 r: jrcrwjr
9-10 v: bkvvvvvvvjvv
2-6 x: xnwnnx
18-19 k: kkkkkkkkkkkkkkkkkpk
3-5 j: gtjrr
5-6 j: jjjjjj
5-6 k: kkzknk
12-15 t: tttttttttbdlvtq
1-4 d: ddwvz
3-8 f: xlfffrpf
1-2 z: zzdscgwbxtxrd
5-14 n: nsnnnlnnznnxsnnnnnd
9-10 g: gwslkgdgwqdbgws
4-6 f: sfcgkffmfc
10-14 m: dmmwlqmmmmmmmmnm
8-12 n: nnnnnnnnvnnv
15-16 l: lllllllllllllvqlf
1-10 t: tftpttjtnt
2-7 t: ljzdkxtwvbmjtff
2-9 w: stwwlqcbtws
4-6 h: hjwhhvvtpg
3-5 v: vvgvv
8-12 d: ddhcdpdjdddhddmr
10-11 x: kxxllzjrdxlsxx
5-6 f: fffjfrff
17-18 b: bbbbbbbbbbbbhbbbbbbb
3-8 r: znrntdqtmrg
6-12 s: srsvsmsssssssssssss
2-13 z: dzfvpthfxnpnz
7-13 j: jjjjjjrjjcjjw
9-10 l: tllllllljl
12-14 m: mmmmmmmmmmmmmm
17-18 l: llllllllqlllllllggl
1-9 d: dkmqddddzdnrfckdz
6-7 m: gmmmmmlh
13-15 t: ttttxtttttttggbt
6-7 j: jmzvwkjjnjsnjkjxj
1-17 m: gmmnmdvfmmtmmqmmzcj
3-5 l: hvxsjt
7-8 x: kxqczpdxfpjp
2-5 k: kgkkhkdkk
5-7 v: nbjvcgsvf
8-9 d: cxddddnsxd
2-3 p: mmqnjbtbpnmp
11-12 m: jmmmmwvmmhtmmmmlmm
3-14 m: zmmjsqfmqrnzmlmwrjm
3-6 n: vnnnnjn
11-12 j: jjjjjjjcjjjs
13-17 r: rrrrrrrrrrrrrrrrrr
4-5 c: bcncn
2-3 j: bjftxcnzpnjrzxhxlp
9-12 z: tzrlxlzdxzsz
3-5 j: sjtltj
5-7 w: wwwwwww
5-7 p: ppzppcwkvwmwpscfpp
9-10 j: jcjjjjjjjj
3-4 m: mmrm
1-10 k: zkkktkkkkk
5-13 d: bpfldtnfrbdfk
2-3 s: zsskw
6-12 x: xxxxxkxxbxjxlzx
3-9 t: ntgdtbtwnntjbcsfz
6-10 j: sndjqjjdjbfjc
3-4 t: ckqtjtffctwtcp
2-3 v: wvhffpnngzv
7-8 r: tlrncrsg
7-10 g: gjggkfvffg
4-9 x: xpxlxxxmpr
6-9 r: srrrprrrr
7-10 v: gvvnnvhvvvvvdjjvv
4-6 s: psnsgsnfxlscwss
2-4 w: vwwpwx
2-4 b: bbbb
2-16 v: vvvvvvvvvmdvvvvv
3-5 f: ffkffjffff
6-9 q: lqqqqjqqxn
1-5 w: qcvwwwhw
2-10 w: wwwwwwwkjz
6-8 t: tttttttz
13-14 x: xxdxxxhbxxxgcdx
2-4 n: svkl
8-14 f: fffffcfffffffnffw
3-6 n: lsnnnpnnn
11-13 l: lllllllblllll
4-5 s: sssss
3-4 z: zbzt
1-4 x: xxxsx
8-9 c: wlxctcccrqccsccr
5-8 v: vvnvndfqq
4-6 r: rrrtrc
10-15 b: nbbbpfbbbcbzzxbf
4-5 s: sglpschlsgsqbskrd
13-17 k: bvfzktkkkzkkjkkwkf
1-11 x: zkxxxgxxkwxvxgx
15-16 d: dddddddddddddgdwd
2-3 p: pzpprsp
16-19 s: sssbssscjsshwmmszst
11-13 s: stsssssssgmssp
10-11 s: sssssssssgs
5-8 j: jjjjttkj
9-12 s: ssssgsssswsv
16-17 k: kkkkkkkkkkkkkkkwb
9-10 g: bzcdgvrvqg
4-5 n: nnnrn
4-12 n: knnrnnxnnnnjndwn
1-3 m: mtmspm
16-17 b: bbbbbbbbbbbbbbbxb
9-14 m: mmdmqwwbmmlxmjljmm
6-11 z: wzzzzzzzzzzzzszxzvz
2-8 q: qqqqrqqqq
3-4 f: ffhf
9-12 t: ttlqqthvttcttttm
5-8 w: zwwwwlmwwlww
5-7 z: zjjwzkkkjlwzvkp
7-10 z: zkzgzzzxtzz
12-13 v: vvmvvklvvvvgv
10-14 t: ttttttqttttsrttktv
7-10 l: llhlllzllv
1-4 j: blwjjmj
8-10 k: qpffpqskqk
5-9 w: wkdjxcwwswwwwwh
11-13 b: bbbbbbbbbbgtjb
14-16 c: ccccfcbccccccccccc
9-11 l: lflnpwbcmld
8-11 q: qqqqqqflqhtpqq
12-18 z: zzzzzzzzzzzmzzzzzl
4-5 x: xxfhxx
6-16 z: tfrhztxxzzqczznwzz
4-13 l: vlrlmlllldllq
14-15 b: bbwbvbbhbbbbkvnbbbb
3-5 x: frxxx
11-13 f: ffbfffnfffjlffffff
5-6 d: dkrdrgdd
6-8 g: gggwglggvtkglg
1-5 s: sqsnpp
2-4 b: bxjnb
1-2 h: hhfr
10-19 b: tzbpbsbbbtbbbbbbbbbb
3-4 p: pkmcpm
1-8 q: qqqqtqcnqxkqb
13-15 s: ssmssqssssssssts
4-6 q: qqdsqrqq
9-13 z: zzbzzzzpzzzzz
19-20 r: xlrrrgrrrcrktrrhrrrc
9-14 q: qzsrqqqjxwqqhqd
7-15 g: ggggggsggggggggp
4-5 w: wwwkq
7-15 h: ghgpkphhzpmhjpwxq
15-17 v: vcvvvdvvvvvvvpvvhv
1-2 j: qjqbfwbj
3-9 c: nvcwkcndt
14-15 c: cccccccccpccgkclcc
5-6 p: pppppp
12-14 h: hxtxhthhshkrmh
1-2 q: wqjqzqqk
14-15 f: fffffffffffffbqf
7-8 j: vjjjjjfh
7-12 p: trzzppxpptpfp
13-18 w: wwwwwwwmrwwwwwwkwwww
10-11 f: rfffszjfsvn
9-17 l: llllllmlllllllllkl
5-12 s: xssssqssshsss
2-6 x: fxxxsxbnx
4-6 n: nnnnxhnn
10-11 g: gggggggggqg
8-16 n: nknsfcnnnqgnnnxsnfnj
4-7 n: ndnnnnnn
8-9 q: shqphcskmqjqvqqqq
9-10 r: rrrrrjrrrrrr
16-18 z: zfzzzrzzzzzzzzzzzhzz
2-13 g: gkgggqggggggrgg
12-18 v: vvvvvvvvvvvvvvvvvvv
3-4 s: hssq
6-11 h: kdwftsxqcnhph
16-17 t: ttttttttttttttttt
6-11 f: fffffdffffsfffffffff
10-14 p: pppppjvpppppph
10-15 b: bbpbbbbbbtbbbbb
3-7 n: nnnnnnx
3-5 r: rrffrsr
10-13 r: brrrrrrrxrrrrr
6-7 f: ffffkjf
3-7 r: srdrrsrrfrcr
4-9 b: gflbcxtvknsbpjbwrk
8-10 p: pttpkfppcppdznpgpp
13-16 q: qqqqqqqqqqqqqqtqs
1-4 r: rrrwr
1-2 g: zggggggggggg
7-8 j: jjjjjjwb
18-20 t: pwnrvbdzxntvgjjjltqn
8-13 f: fffxffflffffff
4-5 k: cklkk
10-11 m: mmnmmmmmmnm
11-16 q: qqqqqqsqqfsqzqqqq
2-9 n: nnnnnnbnnc
7-11 d: sddnmgfkdddzdd
1-4 f: qfdlftk
8-10 p: pzpppxphphpp
2-4 m: mlwf
6-8 h: jxhhhfztzh
5-8 s: ssnnnssssstsssssd
3-5 x: hlxsx
7-8 h: qhhhhhhwdhph
2-7 v: gxdvcvw
14-15 n: nnnnnkhnfnnnfnnnnnn
9-10 l: lllllllhlnklx
13-18 j: jjjdjcljjjjjjjjjjhj
1-7 h: jkhhhhhhj
9-19 z: tzznzzztcbxkzvssrzzz
12-18 s: sswssscsstnssjssss
4-9 z: zzzxmzgkzspdmq
6-13 d: ndldddpddddddkmdd
8-9 q: zgqrkhxqq
3-6 m: mmmgfdw
1-3 l: dlls
10-11 b: kbbbsbbdbkbqbbbbs
2-4 b: bbbp
5-6 c: xctccckq
3-5 k: kkkkk
12-14 b: bbbbbbzbbnqbbb
6-8 q: jmmhqqlqqkgqcjvqq
11-12 g: ggggpggggghsgg
8-9 h: hhhhchhhbh
10-11 w: zwwcfgwwwwc
5-8 x: xxxxnxlxxx
1-4 f: fffhf
2-3 f: fbwfxr
5-6 f: vrfffd
14-15 r: lrrrrrrrrrrrrfc
7-8 t: tbnptvtt
16-19 r: rrgrrrrrrrrljrrrrrrr
2-4 b: bbpsh
7-13 m: gmmsmmlmmbmmmmmmmgkx
16-17 g: ggggggggggggggrfgg
1-2 g: fcfmr
5-7 l: lclllll
3-5 n: nnnccgvn
1-4 v: npvv
5-11 s: sshsxsswshss
9-12 x: mxxkxxxxsxpkxsxhnktx
3-4 f: fsff
5-11 b: bqzzbcbbbxbk
3-7 s: ssxsssv
6-14 p: pxppjppppppvjp
2-4 h: hhkch
5-7 s: sdshspsssqs
2-8 k: vwkkkkwkskjr
17-18 m: mmmmmmmmmmmrmmmmzm
12-15 w: nwrgwwwjpwwwwpv
3-4 t: ttft
5-11 f: kfffzffzfffk
15-16 d: ddhddddddddcddddd
3-10 l: wplpvlrcqwlblvlcqm
2-5 z: zpzzz
3-5 v: vvgvv
3-4 b: jbgbb
14-15 d: ddddddndddddddd
4-13 z: zszfktzrzjtzzbmn
1-8 b: xbbxrbbbbbb
3-4 t: tttftt
5-9 v: ptvvvcvvvvvnvvvv
1-2 n: tcnnnnln
5-6 h: hhhhhh
10-11 j: jvjjhfjbxjj
4-7 t: twtdttttttttt
12-16 z: zzzzzzzzzwzzzwzzzzzz
7-18 l: hnhcvlnxglxlldlfgvll
2-5 j: jjjjjj
2-8 n: nrknnntn
8-9 z: zzzzzzzqz
4-5 z: zzzzr
1-9 t: bztttgtllwq
8-12 n: ckjnntmkxxcnwkqznp
2-4 b: xbrvvhbbb
1-4 d: dddzqd
13-17 w: wwlwvlwpwwdwwwwqb
3-5 q: lqzmlq
8-9 z: bpzzzczzpzz
1-6 n: nbjqmnhxwh
6-8 q: qqqqqqqzq
16-18 r: rrrrrvrrrrnrrrrrrb
3-8 l: lbfdwlpzmkl
2-3 g: srwcwmgvzjjxj
8-17 w: wwwwwwwjwwwwwwwwww
19-20 t: tttttttttdttttttttvf
1-11 x: pwnwxxfxnkxxtzpglx
6-7 g: lgpglng
5-7 l: llllfll
5-6 p: ppppppp
3-4 x: xxdf
4-15 l: fgkzwrrpmvmhzplsqp
2-4 b: bbqjb
4-6 k: kbkkkwkkk
4-8 p: mppzpprpp
14-17 n: ttfvdtwxnnfdsnxbn
3-5 m: mmzmmm
6-7 k: kkkkndk
1-6 r: hkkrln
4-6 h: hhhhhmhhhhhhh
7-10 k: kkkkkkkkksk
3-4 g: fggggg
5-12 x: qhgrxxhrxjjxxhxgb
3-5 x: lxpxxb
4-7 f: frffsfjff
4-6 d: dpddjfxdrt
11-13 f: fffpxfcfffdfnfzf
12-18 r: rrrrwrrrrrwrrrcfrcr
18-19 q: kqqqqqqqqqqqqnqqqkqq
3-4 b: bgbrf
15-17 s: ssssssssssssssbdss
6-9 d: bnvlpxlctvdd
1-2 s: smsss
2-9 s: cpgrfdfmm
5-12 j: jjjxdqjctjjtnzcjq
9-16 g: xqzgsrdtcvblfpmg
11-15 q: qqqsqqqqwdqqmqqpqh
3-8 d: xddzddtdnk
5-8 p: blppgpppppppx
7-9 m: mqwlxbbcmqf
6-8 t: ltttbttsbtrtts
12-13 k: kqmfkcvkwsnddkk
16-17 t: hrkwqdtckqdktgctj
2-4 m: mmmm
2-11 l: tlflzkxlvlq
5-6 j: jjjjjl
2-13 x: wzfjxsbqznqlx
4-8 s: mssssfzpsh
7-17 v: vvxvvvllvxvvvhrvvv
3-6 h: qchchw
4-10 n: nllnnbnrvnnnmgnzb
16-17 v: vvvfvvvvvvvvpvvvjv
2-14 f: lpbfwlffxhlxfffkf
5-7 w: cfwkwnl
4-6 n: nnnnnn
10-11 d: dcddddddddd
1-2 d: nvrdpnvnlxccjrd
15-16 v: vvjvvvvvvvvvvvhzv
3-4 l: wwlpllqk
2-4 p: pvpp
2-3 b: bmbf
2-12 m: snpdndwgtfqjlzdmmth
5-8 j: rpjjjjlpsj
5-9 g: gdmvgsgjrhg
6-7 p: pppppdspp
2-9 k: dktlkrkwlnd
9-18 b: bbxbbbbbrbbbzbbbbvb
5-9 t: ttqdcwdjtwtqttttbc
8-10 d: njdddddtddhd
4-12 r: fkrfrrrrrrrgr
6-7 s: ssskgxssbs
2-6 m: mtmmmkmm
11-12 h: hhhhjhhhhhgh
8-9 q: kfqkscqnq
6-12 d: sdpddmvdvdxdl
1-8 f: cffzgfffkfff
4-9 v: vvvvcnljw
4-5 p: wplvpp
2-3 w: kxwwww
3-5 m: nmmmmm
2-6 t: ttntttjhctkztt
11-14 v: vvvvvvvvvvqvvf
7-8 z: zzgjqzzzzzdzzkzw
13-15 k: kkkkkkkkfkkkkkk
6-7 m: mmmmmfmgm
7-8 m: fgxsdqmnmmszv
1-3 p: pqppp
8-12 s: sssxqstsssnfsxss
7-10 q: qqqfqqxqqqq
2-5 x: djhvxxm
3-5 b: bjbbbrjgbbxkbgpqd
3-17 c: ccscccjccmclccccccc
8-12 d: djrdgddwxddxskt
7-9 h: hhhhhhzhmh
4-8 l: jwlplsct
6-10 q: qvqhqxnqqmz
1-5 w: wwpwqw
3-12 d: pltzkcsdhphdmdxkb
1-9 k: kkkkkkkkx
2-6 d: dbddqddd
11-13 n: njnrjnnnnnqzn
2-4 k: kkkkkk
11-14 g: gggggggggggcgngg
15-19 v: vxqvvvvvvvxvvvbvvvdv
9-10 s: ssscsssssf
1-14 m: mmmmfmpqmmmmml
6-8 t: sttqtbtjt
5-7 k: vkkshkw
5-7 x: xscxxxm
6-12 d: pddxdddqkdddzmddpd
2-14 t: gtmxtcttqtttxtv
7-14 r: rrrrrrrrrrrrrpr
15-17 d: ddddfdddddddddddmd
4-5 x: xqxxx
11-13 w: wwwwwwwwwwfww
5-6 j: jjjjjj
5-6 m: mmmmmm
1-3 b: fbblbbgbx
7-8 v: vvvvvxvrvd
6-11 f: ffffpwpfqfhfzxdc
11-17 m: mtmdkbvmjmxmmdmmgb
8-12 h: nhbtsbhjhgdh
7-11 w: wwwpwwdwwwd
11-12 f: hffrfffffffqqf
12-13 f: flfcffffffffqdff
2-3 v: hbbv
8-11 d: drdlbdhwdsddd
6-9 w: swrwnbwmkxwt
10-13 l: llflsllllntlll
8-11 v: xvvvvvtkmcvvvxh
3-4 h: hzhbh
11-12 b: bzbbbbbbbgzxbbbbbm
13-17 l: lqwxqmqmjlsmfwltkzl
1-5 l: mwllx
7-8 c: cccnccxcc
6-12 b: tbbsjbkprrdg
3-5 z: zmpzc
5-8 j: jjjltjjj
6-11 z: xzlzgzqhqwgz
4-5 m: mmmmmm
5-6 q: pqwfqh
9-14 p: pppppptfhpzjtct
6-10 w: wdwwwlwwdww
14-17 m: mmmmmsmmmmqmmwmmm
4-5 v: vvhpfnvv
1-7 q: qfqqbxqvqf
6-11 z: zzzzzzzzzzd
6-13 g: gggggfggggggg
12-13 d: ddpdjqdddddmd
8-10 n: nnndnnnnnn
6-7 z: zzgdzzdvz
6-8 n: vdnvnsnnnlnn
3-4 b: bblbl
1-3 f: zpfjkfr
7-9 h: fhtxkhwhgq
7-9 x: xxdxxxpxx
2-3 v: vmxv
18-19 z: zzzzzzzzzzzzzzzzzhrz
4-6 x: hjlsdv
2-3 x: jzxxvkhsxxck
1-9 s: sfjvsjqvss
8-12 j: xxcmpzjjtmkswwr
4-10 s: ssjtvssslwszss
9-16 h: rhhphhhhwwhhhgrhhh
7-8 h: hvhhhhhzh
7-10 m: mmmdqbtssvmfmmmgr
5-7 h: hhbhzhh
5-10 c: ccccqcwxcccc
4-6 q: bmhqqbpfrqfdkq
7-9 r: rcmrdrrrjlrscrrhkl
3-4 t: ttgz
8-12 g: mgggtggggzgzcphhx
6-8 d: dvddfctd
2-3 g: gmglf
1-2 m: dmqwpbhmmktcvc
6-8 z: bzwzzkxqpz
1-9 x: xxxxbwvxcxxcxwznw
3-6 z: zzzzzz
5-6 k: kkkkhk
12-13 q: zqqnrcqqqplqqndfg
9-12 l: jdvxtbqblmllfbnlff
3-6 v: vvkvvv
4-7 v: xbtzjdvp
8-10 h: hhmhhhhhhnmd
7-8 t: ttktgqfzxrdxqf
4-5 g: gggjf
6-9 q: qqqqmmqqqqq
1-10 w: rwjwwwwwrcw
9-13 b: ssbbbcbbbbbbd
2-3 g: bggggv
6-11 w: wwwwfwwxwwww
5-9 p: ppjppppzt
3-14 z: gpzzzdzzjzzpzzzz
1-7 v: vbbfvjz
2-5 q: qdwczqqq
1-5 r: rrrrhwtf
8-14 d: dddddddtdddddddd
7-8 p: ppppppzlp
5-6 s: lbssnssss
1-8 q: lqnpqqqqq
1-4 k: rkqkkk
1-9 z: zgkxmkmgqzg
1-5 b: cbbbbbf
1-4 c: dctcc
4-5 x: sxxtl
2-8 m: qmfqbfmlkkkjzhqjbxpd
8-16 h: lhlghlcbqgsmjhbh
8-9 x: xxxxxxxxx
10-11 l: cvndhntlghk
8-11 d: dddddddcddz
4-5 j: jvjpjj
1-2 d: bmhdpdr
1-4 j: jnjcjnjtd
4-8 m: djsvzshmxmgb
4-10 k: bhpkgzksrkkqk
4-6 l: lllllwlvwlglxqll
9-10 h: hhhhhhhhhm
3-4 q: qqsbq
7-9 l: dlllllgllllszg
10-12 l: lllllllllvlzl
1-5 k: kkkkr
10-11 w: wdwfkwwwwww
8-10 g: rzswrffrqgdhgzm
3-5 z: zzzzz
8-14 p: pplxppppzprpdpjpppdp
6-11 g: mkghrgcmhxggcpddvx
4-6 b: sjwbqv
1-2 q: qvpqlsqqqrnbp
8-20 w: wwwwwwwwwwwwwwwwwwwg
12-15 m: mmmmlmmmmmfwmmm
1-14 x: xxxxvxsxxxxwcjxvxxx
11-14 g: ggdggggggggggx
2-5 r: xrqtf
10-12 q: qqqvqcqjqjfqqxqqkqj
3-4 c: cvszc
2-7 w: mwwwwwvwx
6-8 r: hrgrckfb
4-8 d: ddddgxcznlnwdddd
1-4 c: drhvzzc
3-14 n: pfnjnnhpnppfnrbhz
3-4 n: bnnnb
13-15 h: hhhhhphhhhhthhgh
3-5 l: lfllpmknmplx
1-12 c: lcchctpccccccx
8-9 l: lznsllwlbllmllzl
7-9 w: wwwwqshnwkwwww
10-12 k: zxkknkxkrkckkr
9-12 r: rdrkbkgrrrrznrr
12-13 g: ggggggvgggggr
2-5 g: vgxggr
5-6 c: cccthsc
2-3 t: nptdqmfglpzdvwkspt
4-13 q: qqsxdqqfngqqkqq
17-19 r: rrrrrrrrrrrrrrrrxrf
7-11 t: ttttmthttttt
1-5 l: lllwl
8-12 x: xxxxxxxbxxxwxxx
10-11 d: dddddbfddddcdd
3-5 f: lfffb
1-4 f: ffff
1-9 s: swdckstss
7-9 p: pbfzppbmp
1-2 p: xpqssm
6-16 h: hlhhqdhhmhhhhhphhrh
4-5 b: pbbgxbhqbzvnwxxb
7-10 n: nrbdnnnwnnnlnn
1-2 r: mspcrbgfqs
12-16 l: rlvmtklhllrvljlllx
7-10 p: mpppppprpmjs
6-7 g: gpggwmggggv
1-4 q: qqdqlqq
9-18 x: xxxxxxxxtxxxxxfxxxx
2-4 h: hhhshh
3-4 q: qllq
5-11 g: ggggggggggsg
1-4 r: mrwbr
4-6 m: knhmnm
13-14 p: pppppppppppppp
9-12 v: vvtvvvvfvztvvvxwqlg
11-13 r: rrrrprrrrrzrr
7-11 z: zzzzzzjzzzzz
17-19 d: ddddddddddddddddjdd
4-5 c: ccncdc
4-6 x: gxxvqx
2-3 g: ggpg
6-11 m: blgvnmbxhpmxmb
2-15 w: wvdwwfqjwqwvmfrzw
3-4 s: ssdw
6-7 l: mmllqlcllklxcml
16-17 l: lllplllllllllllllnl
2-4 h: qtwhwz
5-7 v: xvvwfvfvv
4-10 k: kkkkkkkkqkkk
5-6 f: qzvvpf
4-11 d: whhddttshzds
10-13 q: qjlqqqqqpwqqgqq
11-12 w: nwwwdmvwwwwk
4-8 l: rlljllhljl
7-10 s: sssssssssd
2-8 c: qcgrtxrfccgc
7-8 n: pnnngnnnvnwdnn
8-10 c: cscckctxcrhgc
1-4 n: ngnncrnn
6-12 t: ztzqttbmtztpsnrnt
8-12 b: bbbbbbbbbbbb
1-4 z: czzzzzzz
1-2 k: kktmkf
10-14 x: xxxjsxxnxxxxxqxxpx
11-15 v: vxvvrvvvdvvvvvbv
7-9 s: nsslmtsdxbxfsfssswfx
12-15 l: lllllllllllfcltllll
6-7 q: qqqqtqdqq
15-19 n: nnnnnnnnnnnnnnbnnnn
6-8 s: ssttshsks
16-20 r: rrrrprrrjrlqrrsrrrrb
7-10 q: qqqqqqqqqq
3-4 w: wcbw
5-6 g: tcggrxgrgvl
10-12 l: kllswlmlglps
4-7 v: qkvvvvqxjktkvvvjv
5-13 r: rrrrqrrrrrrrrrr
1-2 n: nnnnmb
1-8 x: xktqbxgkkjwlt
3-4 k: kskk
16-17 k: kkdkkkkkkkkkkkkwk
10-15 n: vnnnnnnnnqjnnknnnr
8-15 m: mfmmgmmqmmmmmkmmmmmm
4-8 k: kkkgkkkjkkk
16-17 h: hhhhhhhhhhhlhhhqh
1-4 p: ppprpppppp
1-9 g: gbdxggmggrgw
1-5 f: vfffff
2-12 d: jzvwdmsqpdnh
12-13 w: wwcwgzwwwwwhwwwwww
9-10 z: zzdzzlzvgzzztzzz
4-5 f: ffftff
8-14 x: xxxxxxxrxxxxxx
1-4 r: kgrrvrrvrr
3-4 w: zkpwxkk
2-5 k: tkckkfcvxkxk
3-9 r: rbrrrrgrrrrkbrrr
3-4 t: ttxx
8-11 z: zzzzzzzzzzz
6-10 p: pnwhxpmxpfskq
1-16 d: dddddddddddddddgdddd
1-7 c: kctcccg
1-5 q: sqqqrqqq
14-16 f: fjfffffqfkfffjffff
3-8 v: knvrrqvtv
1-2 p: ptgswlvpdnmr
3-5 v: vvkmnvdwk
10-14 r: rrrrrrrrrhlrwrrrd
2-11 f: xffffxjfffzfffpf
1-5 p: nppppppp
15-16 x: xxxxxxxxxxxxxxsx
15-16 b: prhbmdvwcmtzpvbb
11-14 t: rngdttnzqtjtcttdvbmt
8-10 f: ffvldffqfqffgf
1-3 r: rzqrmz
7-8 n: tntnnnntn
6-14 s: qpvlfbsgswsnwsmpz
9-12 t: tvwstttttttktwt
4-6 g: vslqbgg
9-16 d: dsdddddddrdddddhdbdd
#+end_example

*** Day 03: Toboggan Trajectory
**** Sample
#+NAME: sample-2020-03
#+begin_src bash :results output :cache yes
echo "..##.......
#...#...#..
.#....#..#.
..#.#...#.#
.#...##..#.
..#.##.....
.#.#.#....#
.#........#
#.##...#...
#...##....#
.#..#...#.#"
#+end_src

#+RESULTS[e40ce040ea2855b37b0509406f9069be17a4764f]: sample-2020-03
#+begin_example
..##.......
#...#...#..
.#....#..#.
..#.#...#.#
.#...##..#.
..#.##.....
.#.#.#....#
.#........#
#.##...#...
#...##....#
.#..#...#.#
#+end_example

**** Input
#+NAME: input-2020-03
#+begin_src bash :results output :cache yes
echo ".#..............##....#.#.####.
##..........#.....##...........
.......#....##...........#.#...
.........#.#...#..........#....
.........#..#................##
..#...#..#..#...........#......
...................#...##..##..
........#.....##...#.#.#...#...
#..#.##......#.#..#..........#.
......#.#...#.#...#........##.#
.....#.####........#...........
...###..#............#.........
.....#.......##......#...#.....
#......##......................
......#..............#.........
..##...#....###.##.............
#...#..........#.#.........#...
...........#........#...#......
.....##.........#......#..#....
#..............#....#.....#....
.#......#....#...#............#
.####..........##..#.#.........
....#...#......................
....................#....#.#...
..........###.#...............#
.#...........#...##............
.#.#..#.....#...#....#.......#.
.##........#..#....#...........
.........#.....#......###......
..............#..#.......#.....
........#..#.#...........#..#..
#.........#......#.....##.#.#..
........#.#.#....#.............
........#........#.#.##........
#......#.#..........#..#.......
..#....#...##......###..#..#...
............#..#.#.........#...
....#.#...........#..........##
.......#.#.#..#......#...#.....
..#.........##.#.........#...#.
......#....#.#....#........#.#.
.#....###....#..............#..
.#....#.......#....#..#.....#..
.....#.....#...................
..#.....#......#......#........
......##.##...#...#...#...#.##.
##...#....#...#..#...#...#.....
..#.....#...#...##.##...#......
.....#.............##...#......
.....................#.##..#...
#...#....#....#........#.....#.
..#...#.........#...#..#.....#.
#.#......#...................#.
..#...........##...............
..#....#........#..#...........
...........#...................
.............###......#....#...
...........#...#....#..#....#..
.....##............#.#.......#.
.....#..#....#...#....#........
...............##........#.#...
.........#...#.#....#.......#..
#..#.......#.......#...#.......
..#...........................#
......#.......#..#......#......
.#.......#..................##.
..#.........#..#.##.#....#...##
...#..#....#...#....#.#........
.#...#........##..#..#.......#.
.....#........#....#....#..#...
............#...........#......
..###.......#..#....#......#...
.....#...#.......#..#..........
..#........##.#....##..........
#....#.............#..##......#
....#.................##.......
...#.......#........#....##.#.#
##..##..#.....#.....#..........
...#...............#....#..#...
.#...##....#....#.....#....##..
...#.....#......#......#.......
#.....#.......##.....#..#....##
.....#.#...##.#......##....#.#.
..........#....#.#...#.........
.#..##...#.....................
...........##..#...#....#......
...#......#........#.......#...
.#......#..#........#.....#..#.
.......#........##..#.##....#..
.##..........#..#...#.....#....
.....##...............#.#......
..##.....#..#......#..##.#.#...
....#......#.##...........#....
#.#..#.......#......#.#........
...#.#..#....#............#..#.
...#..........###....#....#...#
........##...#.......#..#....#.
..#...#.....#..#........##.....
...#..#.##.#.#.##..............
.......#...#.........#.....#..#
..#.....#.#..........#..#......
......#..........#......#.....#
.#...........#........#......##
..##............#......#...#..#
#..................#...........
#....#..#.........#........#..#
..#.#....###..#...#...##...##..
...#....#..#.....#.............
.#........##.##...#....#...#...
.........#.......##.#.....##...
#.#.....##...#........#...#...#
.....#.#.##...#.....#.##..#....
........#...##...#...#.#..#..#.
.##....#.##...#.......#........
...#..#................#..#....
....#.......#......#...#.##....
#......###..#...#......#.......
..#...#...##...........##......
.......#...#..##....##......#..
....#.#.............#.#...##..#
..........#........#...#......#
............#.#.#....###.......
#..#...#.#.####...#..#...#.....
.##.......#.##...#.............
#..#...........#.#.##.......#..
...#..#.#...#...###..#.#..#.#..
..#...#.....#..#....#....#.....
.........##.......#............
.........##.##......###........
.............#.#....#..#.....#.
...#....#.#.......#......##....
............#..................
....##...#..........#...#..#...
#..#....#.....#.......#.##.#..#
.....#.........##.............#
#.....#.#...#............##..##
..............#....#.....#.....
.#....###..#.#.....###.#..#....
.....#....##...#....#......#...
..........#...#....#...........
............#....#..#.........#
..##.....#.#...#.......#...#...
...#...#..#......##...#.....##.
......#.##............##.#....#
....#......#...##.....#.....###
.#.###...............#...#.#...
..#....................##...#..
.......#.....##...........#....
#.........#....#....#....#....#
..#.#..##.#.#..................
.....#.......#................#
...........#.......#........#..
#...#.........#.#.....#.....#..
..........#..#...........#.....
#..#.##..##..#.#.##.........#..
#..#..#....##..#.........#.....
#.#.......................#.#..
.##......#.#...#......#....#...
..#.#................#..##.....
.......#..................#...#
.....#.........##.#....#.......
#..........#..#.#..........#..#
..#..#.....#.........#...#.....
..............#.....#..#...#.##
...............................
...#............##......#.....#
.......#..#.............#.#....
...........#..........#........
...#.####..#......#...#....#...
##......#.##.....#.............
....#.........#...#...........#
...#........#.......#.#..#.#.#.
..#.......#.........#....#.....
................#.#.#.##...#..#
#.##...#...#..#.....#.....#..#.
...............#...........#...
.....##.#...............##...#.
.#..##.##......................
.......#.........#..#..#.......
...#......#..................#.
...#.#..#....#....#............
...........#...#..#....##......
.....#...#..#.#....#....#....#.
.......#...#...#.#.#...........
....#......#......#...##..#....
##...#.#.....#..#.##...........
#.#..#.....#..#................
...#..#.#......#.#...........##
##....#...#.....###..#...#....#
...#.....#.#.#......##...#...#.
............#.......#..........
....#..........###.......#.....
.................##..##....#...
...........#........##..#......
...#.#...#.....#........#...#..
#...#.#......#.#...........#...
..#..........#....#..........#.
..#................#...........
#...#.#....#.#.......#.........
.#...........##..#....#....#..#
.##........#.....#...#..#....#.
......#......#...#.............
.......#..#...#.##....#..#.#...
.......#......#....#....#.#.#..
..........##.....#....##.#.....
.........##..#...#.....#..#....
...#....#..........#..#...#..#.
.......#.....##.#..#.....#...#.
#...#......#......#...#........
#..#....#.#......#......#......
.......#.##....................
...##...#.....#......##......#.
.#...................###.......
....#........###...#........#..
...#............#.....#..#.....
..................#......#....#
..##......#..##..##......#.#...
........##....##.......#...#...
.#.#....#.....#.....#....#....#
...##.#.............#....##....
.........#.....#...#......#....
..#.....#............#....##...
..##.....#.....##.##...........
#....#.#.......#..#......#.....
##.......#.....#.....####....#.
##...#.......#...#.....#.......
#.....#..##.##...##..#.....#..#
..........#......#..#.#........
..##.#......#..............#...
.#...#..........#.......#....#.
..#....##...#...........#....#.
..#.........#..#......#......#.
.##....#......#.#.........#..##
.......#...#....##............#
.##.................#.#........
...#.#...#..#..#.....#.#.......
.#.#.......#...................
..#..#.....#......#.....##..##.
.#........#.##......#..........
....##...#............#.#....#.
.......#.#..#....##.#....#....#
......####...#..#.....#........
..........#..#.........#.#..#.#
..........##.........#.##......
.##..#.#.....#.....#....#......
............#..#...............
.....##.........#...#...##...##
........#.##.#...#.....#....#.#
#......##.#.##..........##.....
#..#..#........#.........#..#..
...............#.#..##.........
.#.......##.#..#....#...#....##
.#..##.....##......#....#...#.#
........#...#.........#.....#.#
...........#............#...#..
................#...........#..
..............##........#....#.
..........#.....##.....#..#....
#......#....###..#..#..........
.....#.#.....##....#.#.......#.
...#...#...............#.#.....
.............#.......#.........
.....#.....#..#......#.....#...
.........#.................#.##
.#.....#.##..#.................
..#......#.......#.....#...#..#
..#..#.#.#...#.......#.##......
..........#..#.........#.......
.#..........#...#....#..#...##.
.#.#.#.###.....#...#.#.#.......
....##............#............
.#.#.............#..#......#.#.
.#.#..........##..#.....#..#.#.
...........#.##..#...#.#.....#.
...........#..#....#...........
..#................#.#...#....#
...............##........##....
....#.............#........#...
...#......#.#.#........#.......
#..............#..##.#..##.....
.#.#.###................##.....
.............#..#.........#....
.......##..#............#...#..
...#...#...........#.....#.....
........#......#.#.#......#..#.
#.##.......#......#..#..#.#....
...#........#...........#...#..
..#...........#.........#......
.............#....#....#.......
....#.........#........#......#
..#............##..#.........#.
.#...#...#..#...#........#..#..
...#....##..............#......
...........#...#....#.#.##..###
..#....#......#.........#..#...
.......#...#...................
.#...#.#...................#...
.#.....##.#.......#.#.#...##..#
.....#..#.#.........#...#..##..
.#..#.##.#......#......#.#...#.
......#..#....##..#....##....##
#...#......##........##........
.#.........###................#
.................#..###..#.#...
..#.#........#..#........#...#.
#.#....#....#..#...#.#......#..
.#.#.............###.........#.
.....#...............##...#...#
..............#...#........#..#
...................#..#.......#
#......................#.....#.
...#.........#..##...#...#.##..
.....#..........#.........#....
.....#...#............#..#.....
.............#............#....
...#.........#.................
#...........#.#...............#
.....#...#.....#..#.##.......##
...#....#.#...........#........
.........................#.#...
.#..#...........#.#........#...
.............#.#.....#..#....#.
.....#...#.###...#..#........#."
#+end_src

*** Day 04: Passport Processing
**** Sample
#+NAME: sample-2020-04
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-04
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 05: Binary Boarding
**** Sample
#+NAME: sample-2020-05
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-05
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 06: Custom Customs
**** Sample
#+NAME: sample-2020-06
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-06
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 07: Handy Haversacks
**** Sample
#+NAME: sample-2020-07
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-07
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 08: Handheld Halting
**** Sample
#+NAME: sample-2020-08
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-08
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 09: Encoding Error
**** Sample
#+NAME: sample-2020-09
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-09
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 10: Adapter Array
**** Sample
#+NAME: sample-2020-10
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-10
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 11: Seating System
**** Sample
#+NAME: sample-2020-11
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-11
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 12: Rain Risk
**** Sample
#+NAME: sample-2020-12
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-12
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 13: Shuttle Search
**** Sample
#+NAME: sample-2020-13
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-13
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 14: Docking Data
**** Sample
#+NAME: sample-2020-14
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-14
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 15: Rambunctious Recitation
**** Sample
#+NAME: sample-2020-15
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-15
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 16: Ticket Translation
**** Sample
#+NAME: sample-2020-16
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-16
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 17: Conway Cubes
**** Sample
#+NAME: sample-2020-17
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-17
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 18: Operation Order
**** Sample
#+NAME: sample-2020-18
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-18
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 19: Monster Messages
**** Sample
#+NAME: sample-2020-19
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-19
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 20: Jurassic Jigsaw
**** Sample
#+NAME: sample-2020-20
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-20
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 21: Allergen Assessment
**** Sample
#+NAME: sample-2020-21
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-21
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 22: Crab Combat
**** Sample
#+NAME: sample-2020-22
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-22
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 23: Crab Cups
**** Sample
#+NAME: sample-2020-23
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-23
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 24: Lobby Layout
**** Sample
#+NAME: sample-2020-24
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-24
#+begin_src bash :results output :cache yes
echo ""
#+end_src

*** Day 25: Combo Breaker
**** Sample
#+NAME: sample-2020-25
#+begin_src bash :results output :cache yes
echo ""
#+end_src
**** Input
#+NAME: input-2020-25
#+begin_src bash :results output :cache yes
echo ""
#+end_src

